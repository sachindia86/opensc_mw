diff --git a/src/libopensc/card-entersafe.c b/src/libopensc/card-entersafe.c
index 168894ab..ab8a593e 100644
--- a/src/libopensc/card-entersafe.c
+++ b/src/libopensc/card-entersafe.c
@@ -1,1695 +1,2019 @@
-/*
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/* Initially written by Weitao Sun (weitao@ftsafe.com) 2008 */
-
-#if HAVE_CONFIG_H
-#include "config.h"
-#endif
-#ifdef ENABLE_OPENSSL	/* empty file without openssl */
-
-#include <stdlib.h>
-#include <string.h>
-
-#include <openssl/evp.h>
-
-#include "internal.h"
-#include "asn1.h"
-#include "cardctl.h"
-
-static const struct sc_atr_table entersafe_atrs[] = {
-	{ 
-		 "3b:0f:00:65:46:53:05:19:05:71:df:00:00:00:00:00:00", 
-		 "ff:ff:ff:ff:ff:ff:ff:00:ff:ff:ff:00:00:00:00:00:00", 
-		 "ePass3000", SC_CARD_TYPE_ENTERSAFE_3K, 0, NULL },
-	{ 
-		 "3b:9f:95:81:31:fe:9f:00:65:46:53:05:30:06:71:df:00:00:00:80:6a:82:5e",
-		 "FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:00:FF:FF:FF:FF:FF:FF:00:00:00:00",
-		 "FTCOS/PK-01C", SC_CARD_TYPE_ENTERSAFE_FTCOS_PK_01C, 0, NULL },
-	 { 
-		"3b:fc:18:00:00:81:31:80:45:90:67:46:4a:00:64:18:14:00:00:00:00:02",
-		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:00",
-		"EJAVA/PK-01C", SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C, 0, NULL },
-	{
-		"3b:7c:18:00:00:90:67:46:4a:20:28:8c:58:00:00:00:00",
-		"ff:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff",
-		"EJAVA/PK-01C-T0",SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C_T0,0,NULL},
-	{
-		"3B:FC:18:00:00:81:31:80:45:90:67:46:4A:21:28:8C:58:00:00:00:00:B7",
-		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:00",
-		"EJAVA/H10CR/PK-01C-T1",SC_CARD_TYPE_ENTERSAFE_EJAVA_H10CR_PK_01C_T1,0,NULL},
-	{
-		"3B:FC:18:00:00:81:31:80:45:90:67:46:4A:20:25:c3:30:00:00:00:00",
-		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:00:00:00:00",
-		"EJAVA/D11CR/PK-01C-T1",SC_CARD_TYPE_ENTERSAFE_EJAVA_D11CR_PK_01C_T1,0,NULL},
-	{
-		"3B:FC:18:00:00:81:31:80:45:90:67:46:4A:00:6A:04:24:00:00:00:00:20",
-		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:00",
-		"EJAVA/C21C/PK-01C-T1",SC_CARD_TYPE_ENTERSAFE_EJAVA_C21C_PK_01C_T1,0,NULL},
-	{
-		"3B:FC:18:00:00:81:31:80:45:90:67:46:4A:00:68:08:04:00:00:00:00:0E",
-		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:00",
-		"EJAVA/A22CR/PK-01C-T1",SC_CARD_TYPE_ENTERSAFE_EJAVA_A22CR_PK_01C_T1,0,NULL},
-	{
-		"3B:FC:18:00:00:81:31:80:45:90:67:46:4A:10:27:61:30:00:00:00:00:0C",
-		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:00",
-		"EJAVA/A40CR/PK-01C-T1",SC_CARD_TYPE_ENTERSAFE_EJAVA_A40CR_PK_01C_T1,0,NULL},
-	{
-		"3b:fc:18:00:00:81:31:80:45:90:67:46:4a:00:68:08:06:00:00:00:00:0c",
-		"FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:00:FF:FF:FF:FF:FF:FF:00:00:00",
-		"FTCOS/PK-01C", SC_CARD_TYPE_ENTERSAFE_FTCOS_PK_01C, 0, NULL },
-	{ NULL, NULL, NULL, 0, 0, NULL }
-};
-
-static struct sc_card_operations entersafe_ops;
-static struct sc_card_operations *iso_ops = NULL;
-
-static struct sc_card_driver entersafe_drv = {
-	"entersafe",
-	"entersafe",
-	&entersafe_ops,
-	NULL, 0, NULL
-};
-
-static u8 trans_code_3k[] =
-{
-	 0x01,0x02,0x03,0x04,
-	 0x05,0x06,0x07,0x08,
-};
-
-static u8 trans_code_ftcos_pk_01c[] =
-{
-	 0x92,0x34,0x2E,0xEF,
-	 0x23,0x40,0x4F,0xD1,
-};
-
-static u8 init_key[] =
-{
-	 1,  2,  3,  4, 
-	 5,  6,  7,  8, 
-	 9,  10, 11, 12, 
-	 13, 14, 15, 16,
-};
-
-static u8 key_maintain[] =
-{
-	 0x12, 0x34, 0x56, 0x78, 
-	 0x21, 0x43, 0x65, 0x87, 
-	 0x11, 0x22, 0xaa, 0xbb,
-	 0x33, 0x44, 0xcd, 0xef
-};
-
-static void entersafe_reverse_buffer(u8* buff,size_t size)
-{
-	 u8 t;
-	 u8 * end=buff+size-1;
-
-	 while(buff<end)
-	 {
-		  t = *buff;
-		  *buff = *end;
-		  *end=t;
-		  ++buff;
-		  --end;
-	 }
-}
-
-static int entersafe_select_file(sc_card_t *card,
-								 const sc_path_t *in_path,
-								 sc_file_t **file_out);
-
-/* the entersafe part */
-static int entersafe_match_card(sc_card_t *card)
-{
-	int i;
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	i = _sc_match_atr(card, entersafe_atrs, &card->type);
-	if (i < 0)
-		return 0;		
-
-	return 1;
-}
-
-static int entersafe_init(sc_card_t *card)
-{
-	unsigned int flags;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	card->name = "entersafe";
-	card->cla  = 0x00;
-	card->drv_data = NULL;
-
-	flags =SC_ALGORITHM_ONBOARD_KEY_GEN
-		 | SC_ALGORITHM_RSA_RAW
-		 | SC_ALGORITHM_RSA_HASH_NONE;
-
-	_sc_card_add_rsa_alg(card, 512, flags, 0);
-	_sc_card_add_rsa_alg(card, 768, flags, 0);
-	_sc_card_add_rsa_alg(card,1024, flags, 0);
-	_sc_card_add_rsa_alg(card,2048, flags, 0);
-
-	card->caps = SC_CARD_CAP_RNG; 
-
-	/* we need read_binary&friends with max 224 bytes per read */
-	card->max_send_size = 224;
-	card->max_recv_size = 224;
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
-}
-
-static int entersafe_gen_random(sc_card_t *card,u8 *buff,size_t size)
-{
-	 int r=SC_SUCCESS;
-	 u8 rbuf[SC_MAX_APDU_BUFFER_SIZE]={0};
-	 sc_apdu_t apdu;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-   
-	 sc_format_apdu(card,&apdu,SC_APDU_CASE_2_SHORT,0x84,0x00,0x00);
-	 apdu.resp=rbuf;
-	 apdu.le=size;
-	 apdu.resplen=sizeof(rbuf);
-
-	 r=sc_transmit_apdu(card,&apdu);
-	 LOG_TEST_RET(card->ctx, r, "entersafe gen random failed");
-
-	 if(apdu.resplen!=size)
-		  LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
-	 memcpy(buff,rbuf,size);
-
-	 LOG_FUNC_RETURN(card->ctx, r);
-}
-
-static int entersafe_cipher_apdu(sc_card_t *card, sc_apdu_t *apdu,
-								 u8 *key, size_t keylen,
-								 u8 *buff, size_t buffsize)
-{
-	 EVP_CIPHER_CTX * ctx = NULL;
-	EVP_CIPHER *alg = NULL;
-
-	 u8 iv[8]={0};
-	 int len;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	 assert(card);
-	 assert(apdu);
-	 assert(key);
-	 assert(buff);
-
-	 /* padding as 0x80 0x00 0x00...... */
-	 memset(buff,0,buffsize);
-	 buff[0]=apdu->lc;
-	 memcpy(buff+1,apdu->data,apdu->lc);
-	 buff[apdu->lc+1]=0x80;
-
-	 ctx = EVP_CIPHER_CTX_new();
-	 if (ctx == NULL)
-		 LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
-	 EVP_CIPHER_CTX_set_padding(ctx,0);
-
-	if (keylen == 8) {
-	 	alg = sc_evp_cipher(card->ctx, "DES-ECB");
-		EVP_EncryptInit_ex(ctx, alg, NULL, key, iv);
-	} else if (keylen == 16) {
-	 	alg = sc_evp_cipher(card->ctx, "DES-EDE");
-		EVP_EncryptInit_ex(ctx, alg, NULL, key, iv);
-	} else {
-		EVP_CIPHER_CTX_free(ctx);
-		  LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
-	}
-
-	 len = apdu->lc;
-	 if(!EVP_EncryptUpdate(ctx, buff, &len, buff, buffsize)){
-		sc_evp_cipher_free(alg);
-		EVP_CIPHER_CTX_free(ctx);
-		  sc_log(card->ctx,  "entersafe encryption error.");
-		  LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
-	 }
-	 apdu->lc = len;
-
-	sc_evp_cipher_free(alg);
-	 EVP_CIPHER_CTX_free(ctx);
-
-	 if(apdu->lc!=buffsize)
-	 {
-		  sc_log(card->ctx,  "entersafe build cipher apdu failed.");
-		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INTERNAL);
-	 }
-
-	 apdu->data=buff;
-	 apdu->datalen=apdu->lc;
-
-	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_SUCCESS);
-}
-
-static int entersafe_mac_apdu(sc_card_t *card, sc_apdu_t *apdu,
-							  u8 * key,size_t keylen,
-							  u8 * buff,size_t buffsize)
-{
-	 int r;
-	 u8 iv[8];
-	 u8 *tmp=0,*tmp_rounded=NULL;
-	 size_t tmpsize=0,tmpsize_rounded=0;
-	 int outl=0;
-	 EVP_CIPHER_CTX * ctx = NULL;
-	EVP_CIPHER *alg = NULL;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	 assert(card);
-	 assert(apdu);
-	 assert(key);
-	 assert(buff);
-
-	 if(apdu->cse != SC_APDU_CASE_3_SHORT)
-		  return SC_ERROR_INTERNAL;
-	 if(keylen!=8 && keylen!=16)
-		  return SC_ERROR_INTERNAL;
-
-	 r=entersafe_gen_random(card,iv,sizeof(iv));
-	 LOG_TEST_RET(card->ctx,r,"entersafe gen random failed");
-
-	 /* encode the APDU in the buffer */
-	 if ((r=sc_apdu_get_octets(card->ctx, apdu, &tmp, &tmpsize,SC_PROTO_RAW)) != SC_SUCCESS)
-		  goto out;
-
-	 /* round to 8 */
-	 tmpsize_rounded=(tmpsize/8+1)*8;
-
-	 tmp_rounded = malloc(tmpsize_rounded);
-	 if (tmp_rounded == NULL)
-	 {
-		  r =  SC_ERROR_OUT_OF_MEMORY;
-		  goto out;
-	 }
-	 
-	 /*build content and padded buffer by 0x80 0x00 0x00..... */
-	 memset(tmp_rounded,0,tmpsize_rounded);
-	 memcpy(tmp_rounded,tmp,tmpsize);
-	 tmp_rounded[4]+=4;
-	 tmp_rounded[tmpsize]=0x80;
-
-	 /* block_size-1 blocks*/
-	 ctx = EVP_CIPHER_CTX_new();
-	 if (ctx == NULL) {
-		r =  SC_ERROR_OUT_OF_MEMORY;
-		goto out;
-	 }
-	 EVP_CIPHER_CTX_set_padding(ctx,0);
-	alg = sc_evp_cipher(card->ctx, "DES-CBC");
-	EVP_EncryptInit_ex(ctx, alg, NULL, key, iv);
-
-	 if(tmpsize_rounded>8){
-		  if(!EVP_EncryptUpdate(ctx,tmp_rounded,&outl,tmp_rounded,tmpsize_rounded-8)){
-			   r = SC_ERROR_INTERNAL;
-			   goto out;			   
-		  }
-	 }
-	 /* last block */
-	 if(keylen==8)
-	 {
-		  if(!EVP_EncryptUpdate(ctx,tmp_rounded+outl,&outl,tmp_rounded+outl,8)){
-			   r = SC_ERROR_INTERNAL;
-			   goto out;			   
-		  }
-	 }
-	 else
-	 {
-		  EVP_EncryptInit_ex(ctx, EVP_des_ede_cbc(), NULL, key,tmp_rounded+outl-8);
-		  if(!EVP_EncryptUpdate(ctx,tmp_rounded+outl,&outl,tmp_rounded+outl,8)){
-			   r = SC_ERROR_INTERNAL;
-			   goto out;			   
-		  }
-	 }
-
-	 memcpy(buff,apdu->data,apdu->lc);
-	 /* use first 4 bytes of last block as mac value*/
-	 memcpy(buff+apdu->lc,tmp_rounded+tmpsize_rounded-8,4);
-	 apdu->data=buff;
-	 apdu->lc+=4;
-	 apdu->datalen=apdu->lc;
-
-out:
-	 if(tmp)
-		  free(tmp);
-	 if(tmp_rounded)
-		  free(tmp_rounded);
-	 if (ctx) {
-		sc_evp_cipher_free(alg);
-		EVP_CIPHER_CTX_free(ctx);
-	}
-
-	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
-}
-
-static int entersafe_transmit_apdu(sc_card_t *card, sc_apdu_t *apdu,
-								   u8 * key, size_t keylen,
-								   int cipher,int mac)
-{
-	 u8 *cipher_data=0,*mac_data=0;
-	 size_t cipher_data_size,mac_data_size;
-	 int blocks;
-	 int r=SC_SUCCESS;
-	 u8 *sbuf=NULL;
-	 size_t ssize=0;
-
-	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	 assert(card);
-	 assert(apdu);
-
-	 if((cipher||mac) && (!key||(keylen!=8 && keylen!=16)))
-		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
-
-	 r = sc_apdu_get_octets(card->ctx, apdu, &sbuf, &ssize, SC_PROTO_RAW);
-	 if (r == SC_SUCCESS)
-		  sc_apdu_log(card->ctx, sbuf, ssize, 1);
-	 if(sbuf)
-		  free(sbuf);
-
-	 if(cipher)
-	 {
-		  blocks=(apdu->lc+2)/8+1;
-		  cipher_data_size=blocks*8;
-		  cipher_data=malloc(cipher_data_size);
-		  if(!cipher_data)
-		  {
-			   r = SC_ERROR_OUT_OF_MEMORY;
-			   goto out;
-		  }
-
-		  if((r = entersafe_cipher_apdu(card,apdu,key,keylen,cipher_data,cipher_data_size))<0)
-			   goto out;
-	 }
-	 if(mac)
-	 {	 
-		  mac_data_size=apdu->lc+4;
-		  mac_data=malloc(mac_data_size);
-		  if(!mac_data)
-		  {
-			   r = SC_ERROR_OUT_OF_MEMORY;
-			   goto out;
-		  }
-		  r = entersafe_mac_apdu(card,apdu,key,keylen,mac_data,mac_data_size);
-		  if(r < 0)
-			   goto out;
-	 }
-	 
-	 r = sc_transmit_apdu(card,apdu);
-
-out:
-	 if(cipher_data)
-		  free(cipher_data);
-	 if(mac_data)
-		  free(mac_data);
-
-	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
-}
-
-static int entersafe_read_binary(sc_card_t *card,
-								 unsigned int idx, u8 *buf, size_t count,
-								 unsigned long *flags)
-{
-	sc_apdu_t apdu;
-	u8 recvbuf[SC_MAX_APDU_BUFFER_SIZE];
-	int r;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	assert(count <= card->max_recv_size);
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0,
-		       (idx >> 8) & 0xFF, idx & 0xFF);
-
-	apdu.cla=idx > 0x7fff ? 0x80:0x00;
-	apdu.le = count;
-	apdu.resplen = count;
-	apdu.resp = recvbuf;
-
-	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	if (apdu.resplen == 0)
-		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));
-	memcpy(buf, recvbuf, apdu.resplen);
-
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, apdu.resplen);
-}
-
-static int entersafe_update_binary(sc_card_t *card,
-								   unsigned int idx, const u8 *buf,
-								   size_t count, unsigned long flags)
-{
-	sc_apdu_t apdu;
-	int r;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	assert(count <= card->max_send_size);
-
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xD6,
-		       (idx >> 8) & 0xFF, idx & 0xFF);
-	apdu.cla=idx > 0x7fff ? 0x80:0x00;
-	apdu.lc = count;
-	apdu.datalen = count;
-	apdu.data = buf;
-
-	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),
-		    "Card returned error");
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, count);
-}
-
-
-static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
-						  const u8 *buf, size_t buflen)
-{
-	 int r;
-
-	 assert(file);
-	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	 r = iso_ops->process_fci(card,file,buf,buflen);
-	 LOG_TEST_RET(card->ctx, r, "Process fci failed");
-
-	 if(file->namelen)
-	 {
-		  file->type = SC_FILE_TYPE_DF;
-		  file->ef_structure = SC_FILE_EF_UNKNOWN;
-	 }
-	 else
-	 {
-		  file->type = SC_FILE_TYPE_WORKING_EF;
-		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
-	 }
-
-	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
-}
-
-static int entersafe_select_fid(sc_card_t *card,
-								unsigned int id_hi, unsigned int id_lo,
-								sc_file_t **file_out)
-{
-	int r;
-	sc_file_t *file = NULL;
-	sc_path_t path;
-
-	memset(&path, 0, sizeof(sc_path_t));
-
-	path.type=SC_PATH_TYPE_FILE_ID;
-	path.value[0]=id_hi;
-	path.value[1]=id_lo;
-	path.len=2;
-
-	r = iso_ops->select_file(card,&path,&file);
-	if (r < 0)
-		sc_file_free(file);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-
-	/* update cache */
-	if (file->type == SC_FILE_TYPE_DF) {
-		 card->cache.current_path.type = SC_PATH_TYPE_PATH;
-		 card->cache.current_path.value[0] = 0x3f;
-		 card->cache.current_path.value[1] = 0x00;
-		 if (id_hi == 0x3f && id_lo == 0x00){
-			  card->cache.current_path.len = 2;
-		 } else {
-			  card->cache.current_path.len = 4;
-			  card->cache.current_path.value[2] = id_hi;
-			  card->cache.current_path.value[3] = id_lo;
-		 }
-	}
-	
-	if (file_out)
-		*file_out = file;
-	else
-		sc_file_free(file);
-
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_SUCCESS);
-}
-
-static int entersafe_select_aid(sc_card_t *card,
-								const sc_path_t *in_path,
-								sc_file_t **file_out)
-{
-	int r = 0;
-
-	if (card->cache.valid 
-		&& card->cache.current_path.type == SC_PATH_TYPE_DF_NAME
-		&& card->cache.current_path.len == in_path->len
-		&& memcmp(card->cache.current_path.value, in_path->value, in_path->len)==0 )
-	{
-		 if(file_out)
-		 {
-			  *file_out = sc_file_new();
-			  if(!file_out)
-				   LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
-		 }
-	}
-	else
-	{
-		 r = iso_ops->select_file(card,in_path,file_out);
-		 LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-
-		 /* update cache */
-		 card->cache.current_path.type = SC_PATH_TYPE_DF_NAME;
-		 card->cache.current_path.len = in_path->len;
-		 memcpy(card->cache.current_path.value,in_path->value,in_path->len);
-	}
-	if (file_out) {
-		 sc_file_t *file = *file_out;
-		 assert(file);
-
-		 file->type = SC_FILE_TYPE_DF;
-		 file->ef_structure = SC_FILE_EF_UNKNOWN;
-		 file->path.len = 0;
-		 file->size = 0;
-		 /* AID */
-		 memcpy(file->name,in_path->value,in_path->len);
-		 file->namelen = in_path->len;
-		 file->id = 0x0000;
-	}
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
-}
-
-static int entersafe_select_path(sc_card_t *card,
-								const u8 pathbuf[16], const size_t len,
-								sc_file_t **file_out)
-{
-	 u8 n_pathbuf[SC_MAX_PATH_SIZE];
-	 const u8 *path=pathbuf;
-	 size_t pathlen=len;
-	 int bMatch = -1;
-	 unsigned int i;
-	 int r;
-
-	 if (pathlen%2 != 0 || pathlen > 6 || pathlen <= 0)
-		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
-
-	 /* if pathlen == 6 then the first FID must be MF (== 3F00) */
-	 if (pathlen == 6 && ( path[0] != 0x3f || path[1] != 0x00 ))
-		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
-
-	 /* unify path (the first FID should be MF) */
-	 if (path[0] != 0x3f || path[1] != 0x00)
-	 {
-		  n_pathbuf[0] = 0x3f;
-		  n_pathbuf[1] = 0x00;
-		  memcpy(n_pathbuf+2, path, pathlen);
-		  path = n_pathbuf;
-		  pathlen += 2; 
-	 }
-	
-	 /* check current working directory */
-	 if (card->cache.valid 
-		 && card->cache.current_path.type == SC_PATH_TYPE_PATH
-		 && card->cache.current_path.len >= 2
-		 && card->cache.current_path.len <= pathlen )
-	 {
-		  bMatch = 0;
-		  for (i=0; i < card->cache.current_path.len; i+=2)
-			   if (card->cache.current_path.value[i] == path[i] 
-				   && card->cache.current_path.value[i+1] == path[i+1] )
-					bMatch += 2;
-	 }
-
-	 if ( card->cache.valid && bMatch > 2 )
-	 {
-		  if ( pathlen - bMatch == 2 )
-		  {
-			   /* we are in the right directory */
-			   return entersafe_select_fid(card, path[bMatch], path[bMatch+1], file_out);
-		  }
-		  else if ( pathlen - bMatch > 2 )
-		  {
-			   /* two more steps to go */
-			   sc_path_t new_path;
-	
-			   /* first step: change directory */
-			   r = entersafe_select_fid(card, path[bMatch], path[bMatch+1], NULL);
-			   LOG_TEST_RET(card->ctx, r, "SELECT FILE (DF-ID) failed");
-	
-		   	   memset(&new_path, 0, sizeof(sc_path_t));
-
-			   new_path.type = SC_PATH_TYPE_PATH;
-			   new_path.len  = pathlen - bMatch-2;
-			   memcpy(new_path.value, &(path[bMatch+2]), new_path.len);
-			   /* final step: select file */
-			   return entersafe_select_file(card, &new_path, file_out);
-		  }
-		  else /* if (bMatch - pathlen == 0) */
-		  {
-			   /* done: we are already in the
-				* requested directory */
-			   sc_log(card->ctx, 
-				"cache hit\n");
-			   /* copy file info (if necessary) */
-			   if (file_out) {
-					sc_file_t *file = sc_file_new();
-					if (!file)
-						 LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
-					file->id = (path[pathlen-2] << 8) +
-						 path[pathlen-1];
-					file->path = card->cache.current_path;
-					file->type = SC_FILE_TYPE_DF;
-					file->ef_structure = SC_FILE_EF_UNKNOWN;
-					file->size = 0;
-					file->namelen = 0;
-					file->magic = SC_FILE_MAGIC;
-					*file_out = file;
-			   }
-			   /* nothing left to do */
-			   return SC_SUCCESS;
-		  }
-	 }
-	 else
-	 {
-		  /* no usable cache */
-		  for ( i=0; i<pathlen-2; i+=2 )
-		  {
-			   r = entersafe_select_fid(card, path[i], path[i+1], NULL);
-			   LOG_TEST_RET(card->ctx, r, "SELECT FILE (DF-ID) failed");
-		  }
-		  return entersafe_select_fid(card, path[pathlen-2], path[pathlen-1], file_out);
-	 }
-}
-
-static int entersafe_select_file(sc_card_t *card,
-								 const sc_path_t *in_path,
-								 sc_file_t **file_out)
-{
-	 int r;
-	 char pbuf[SC_MAX_PATH_STRING_SIZE];
-	 assert(card);
-	 assert(in_path);
-	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-
-	  r = sc_path_print(pbuf, sizeof(pbuf), &card->cache.current_path);
-	  if (r != SC_SUCCESS)
-		 pbuf[0] = '\0';
-
-	  sc_log(card->ctx, 
-		   "current path (%s, %s): %s (len: %"SC_FORMAT_LEN_SIZE_T"u)\n",
-		   card->cache.current_path.type == SC_PATH_TYPE_DF_NAME ?
-		   "aid" : "path",
-		   card->cache.valid ? "valid" : "invalid", pbuf,
-		   card->cache.current_path.len);
-
-	 switch(in_path->type)
-	 {
-	 case SC_PATH_TYPE_FILE_ID:
-		  if (in_path->len != 2)
-			   SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_INVALID_ARGUMENTS);
-		  return entersafe_select_fid(card,in_path->value[0],in_path->value[1], file_out);
-	 case SC_PATH_TYPE_DF_NAME:
-		  return entersafe_select_aid(card,in_path,file_out);
-	 case SC_PATH_TYPE_PATH:
-		  return entersafe_select_path(card,in_path->value,in_path->len,file_out);
-	 default:
-		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
-	 }
-}
-
-static int entersafe_create_mf(sc_card_t *card, sc_entersafe_create_data * data)
-{
-	int r;
-	sc_apdu_t apdu;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	memcpy(data->data.df.init_key, init_key, sizeof(init_key));
-
-	sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xE0,0x00,0x00);
-	apdu.cla=0x84;
-	apdu.data=(u8*)&data->data.df;
-	apdu.datalen=apdu.lc=sizeof(data->data.df);
-
-	switch(card->type)
-	{
-	case SC_CARD_TYPE_ENTERSAFE_3K:
-	{
-		 r = entersafe_transmit_apdu(card, &apdu,trans_code_3k,sizeof(trans_code_3k),0,1);
-	}break;
-	case SC_CARD_TYPE_ENTERSAFE_FTCOS_PK_01C:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C_T0:	
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_H10CR_PK_01C_T1:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_D11CR_PK_01C_T1:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_C21C_PK_01C_T1:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_A22CR_PK_01C_T1:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_A40CR_PK_01C_T1:	
-	{
-		 r = entersafe_transmit_apdu(card, &apdu,trans_code_ftcos_pk_01c,sizeof(trans_code_ftcos_pk_01c),0,1);
-	}break;
-	default:
-	{
-		 r = SC_ERROR_INTERNAL;
-	}break;
-	}
-
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	return sc_check_sw(card, apdu.sw1, apdu.sw2);
-}
-static int entersafe_create_df(sc_card_t *card, sc_entersafe_create_data * data)
-{
-	int r;
-	sc_apdu_t apdu;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	memcpy(data->data.df.init_key, init_key, sizeof(init_key));
-
-	sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xE0,0x01,0x00);
-	apdu.cla=0x84;
-	apdu.data=(u8*)&data->data.df;
-	apdu.lc=apdu.datalen=sizeof(data->data.df);
-
-	r = entersafe_transmit_apdu(card, &apdu,init_key,sizeof(init_key),0,1);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	return sc_check_sw(card, apdu.sw1, apdu.sw2);
-}
-
-static int entersafe_create_ef(sc_card_t *card, sc_entersafe_create_data * data)
-{
-	int r;
-	sc_apdu_t apdu;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0x02, 0x00);
-	apdu.cla = 0x84;
-	apdu.data = (u8*)&data->data.ef;
-	apdu.lc = apdu.datalen = sizeof(data->data.ef);
-
-	r = entersafe_transmit_apdu(card, &apdu,init_key,sizeof(init_key),0,1);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	return sc_check_sw(card, apdu.sw1, apdu.sw2);
-}
-
-static u8 process_acl_entry(sc_file_t *in, unsigned int method, unsigned int in_def)
-{
-	u8 def = (u8)in_def;
-	const sc_acl_entry_t *entry = sc_file_get_acl_entry(in, method);
-	if (!entry)
-	{
-		return def;
-	}
-	else if (entry->method & SC_AC_CHV)
-	{
-		unsigned int key_ref = entry->key_ref;
-		if (key_ref == SC_AC_KEY_REF_NONE)
-			return def;
-		else
-			return ENTERSAFE_AC_ALWAYS&0x04;
-	}
-	else if (entry->method & SC_AC_NEVER)
-	{
-		return ENTERSAFE_AC_NEVER;
-	}
-	else
-	{
-		return def;
-	}
-}
-
-static int entersafe_create_file(sc_card_t *card, sc_file_t *file)
-{	
-	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-	 
-	 if (file->type == SC_FILE_TYPE_WORKING_EF) {
-		  sc_entersafe_create_data data;
-		  memset(&data,0,sizeof(data));
-
-		  data.data.ef.file_id[0] = (file->id>>8)&0xFF;	
-		  data.data.ef.file_id[1] = file->id&0xFF;	
-		  data.data.ef.size[0] = (file->size>>8)&0xFF;
-		  data.data.ef.size[1] = file->size&0xFF;
-		  memset(data.data.ef.ac,ENTERSAFE_AC_ALWAYS,sizeof(data.data.ef.ac));
-		  data.data.ef.ac[0] = process_acl_entry(file,SC_AC_OP_READ,ENTERSAFE_AC_ALWAYS);
-		  data.data.ef.ac[1] = process_acl_entry(file,SC_AC_OP_UPDATE,ENTERSAFE_AC_ALWAYS);
-
-		  return entersafe_create_ef(card, &data);
-	 } else
-		  return SC_ERROR_INVALID_ARGUMENTS;
-}
-
-static int entersafe_internal_set_security_env(sc_card_t *card,
-											   const sc_security_env_t *env,
-											   u8 ** data,size_t* size)
-{
-	sc_apdu_t apdu;
-	u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
-	u8 *p=sbuf;
-	int r;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	assert(card != NULL && env != NULL);
-	
-	switch (env->operation) {
-	case SC_SEC_OPERATION_DECIPHER:
-	case SC_SEC_OPERATION_SIGN:
-		 sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);
-		 apdu.p1 = 0x41;
-		 apdu.p2 = 0xB8;
-		 *p++ = 0x80;
-		 *p++ = 0x01;
-		 *p++ = 0x80;
-		 *p++ = 0x83;
-		 *p++ = 0x02;
-		 *p++ = env->key_ref[0];
-		 *p++ = 0x22;
-		 if(*size>1024/8)
-		 {
-			  if(*size == 2048/8)
-			  {
-				   *p++ = 0x89;
-				   *p++ = 0x40;
-				   memcpy(p,*data,0x40);
-				   p+=0x40;
-				   *data+=0x40;
-				   *size-=0x40;
-			  }
-			  else
-			  {
-				   SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
-			  }
-		 }
-		 break;
-	default:
-		 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
-	}
-	
-	apdu.le = 0;
-	apdu.lc = apdu.datalen = p - sbuf;
-	apdu.data = sbuf;
-	apdu.resplen = 0;
-
-	r = sc_transmit_apdu(card, &apdu);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	return sc_check_sw(card, apdu.sw1, apdu.sw2);
-}
-
-/**
- * We don't really set the security environment,but cache it.It will be set when
- * security operation is performed later.Because we may transport partial of
- * the sign/decipher data within the security environment apdu.
- */
-static int entersafe_set_security_env(sc_card_t *card,
-									  const sc_security_env_t *env,
-									  int se_num)
-{
-	 assert(card);
-	 assert(env);
-
-	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	 if(card->drv_data){
-		  free(card->drv_data);
-		  card->drv_data=0;
-	 }
-
-	 card->drv_data = calloc(1,sizeof(*env));
-	 if(!card->drv_data)
-		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_OUT_OF_MEMORY);
-
-	 memcpy(card->drv_data,env,sizeof(*env));
-	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_SUCCESS);
-}
-
-static int entersafe_restore_security_env(sc_card_t *card, int se_num)
-{
-	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-	 return SC_SUCCESS;
-}
-
-
-static int entersafe_compute_with_prkey(sc_card_t *card,
-										const u8 * data, size_t datalen,
-										u8 * out, size_t outlen)
-{
-	int r;
-	sc_apdu_t apdu;
-	u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
-	u8 rbuf[SC_MAX_APDU_BUFFER_SIZE];
-	u8* p=sbuf;
-	size_t size = datalen;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	if(!data)
-		 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_INVALID_ARGUMENTS);
-
-	memcpy(p,data,size);
-
-	if(!card->drv_data)
-		 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_INTERNAL);
-
-	r = entersafe_internal_set_security_env(card,card->drv_data,&p,&size);
-	LOG_TEST_RET(card->ctx, r, "internal set security env failed");
-   
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x86,0x80);
-	apdu.data=p;
-	apdu.lc = size;
-	apdu.datalen = size;
-	apdu.resp = rbuf;
-	apdu.resplen = sizeof(rbuf);
-	apdu.le = 256;
-
-	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-
-	if (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {
-		size_t len = apdu.resplen > outlen ? outlen : apdu.resplen;
-		memcpy(out, apdu.resp, len);
-		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len);
-	}
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));
-}
-
-static int entersafe_compute_signature(sc_card_t *card,
-									   const u8 * data, size_t datalen,
-									   u8 * out, size_t outlen)
-{
-	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-	 return entersafe_compute_with_prkey(card,data,datalen,out,outlen);
-}
-
-static int entersafe_decipher(sc_card_t *card,
-							  const u8 * crgram, size_t crgram_len,
-							  u8 * out, size_t outlen)
-{
-	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-	 return entersafe_compute_with_prkey(card,crgram,crgram_len,out,outlen);
-}
-
-static void entersafe_init_pin_info(struct sc_pin_cmd_pin *pin, unsigned int num)
-{
-	pin->encoding   = SC_PIN_ENCODING_ASCII;
-	pin->min_length = 4;
-	pin->max_length = 16;
-	pin->pad_length = 16;
-	pin->offset     = 5 + num * 16;
-	pin->pad_char   = 0x00;
-}
-
-static int entersafe_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data,
-			   int *tries_left)
-{
-	 int r;
-	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-	 entersafe_init_pin_info(&data->pin1,0);
-	 entersafe_init_pin_info(&data->pin2,1);
-	 data->flags |= SC_PIN_CMD_NEED_PADDING;
-
-	 if(data->cmd!=SC_PIN_CMD_UNBLOCK)
-	 {
-		  r = iso_ops->pin_cmd(card,data,tries_left);
-		  sc_log(card->ctx,  "Verify rv:%i", r);
-	 }
-	 else
-	 {
-		  {/*verify*/
-			   sc_apdu_t apdu;
-			   u8 sbuf[0x10]={0};
-
-			   memcpy(sbuf,data->pin1.data,data->pin1.len);
-			   sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT,0x20,0x00,data->pin_reference+1);
-			   apdu.lc = apdu.datalen = sizeof(sbuf);
-			   apdu.data = sbuf;
-
-			   r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
-			   LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-		  }
-
-		  {/*change*/
-			   sc_apdu_t apdu;
-			   u8 sbuf[0x12]={0};
-			   
-			   sbuf[0] = 0x33;
-			   sbuf[1] = 0x00;
-			   memcpy(sbuf+2,data->pin2.data,data->pin2.len);
-			   sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT,0xF4,0x0B,data->pin_reference);
-			   apdu.cla = 0x84;
-			   apdu.lc = apdu.datalen = sizeof(sbuf);
-			   apdu.data = sbuf;
-
-			   r = entersafe_transmit_apdu(card, &apdu,key_maintain,sizeof(key_maintain),1,1);
-			   LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-		  }
-	 }
-	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
-}
-
-static int entersafe_erase_card(sc_card_t *card)
-{
-	int r;
-	u8  sbuf[2];
-	sc_apdu_t apdu;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	sbuf[0] = 0x3f;
-	sbuf[1] = 0x00;
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 0x00, 0x00);
-	apdu.lc   = 2;
-	apdu.datalen = 2;
-	apdu.data = sbuf;
-	
-	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	sc_invalidate_cache(card);
-
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xEE, 0x00, 0x00);
-	apdu.cla=0x84;
-	apdu.lc=2;
-	apdu.datalen=2;
-	apdu.data=sbuf;
-
-	switch(card->type)
-	{
-	case SC_CARD_TYPE_ENTERSAFE_3K:
-	{
-		 r = entersafe_transmit_apdu(card, &apdu,trans_code_3k,sizeof(trans_code_3k),0,1);
-	}break;
-	case SC_CARD_TYPE_ENTERSAFE_FTCOS_PK_01C:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C_T0:		
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_H10CR_PK_01C_T1:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_D11CR_PK_01C_T1:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_C21C_PK_01C_T1:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_A22CR_PK_01C_T1:
-	case SC_CARD_TYPE_ENTERSAFE_EJAVA_A40CR_PK_01C_T1:
-	{
-		 r = entersafe_transmit_apdu(card, &apdu,trans_code_ftcos_pk_01c,sizeof(trans_code_ftcos_pk_01c),0,1);
-	}break;
-	default:
-	{
-		 r = SC_ERROR_INTERNAL;
-	}break;
-	}
-
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));
-}
-
-static void entersafe_encode_bignum(u8 tag,sc_pkcs15_bignum_t bignum,u8** ptr)
-{
-	 u8 *p=*ptr;
-
-	 *p++=tag;
-	 if(bignum.len<128)
-	 {
-		  *p++=(u8)bignum.len;
-	 }
-	 else
-	 {
-		  u8 bytes=1;
-		  size_t len=bignum.len;
-		  while(len)
-		  {
-			   len=len>>8;
-			   ++bytes;
-		  }
-		  bytes&=0x0F;
-		  *p++=0x80|bytes;
-		  while(bytes)
-		  {
-			   *p++=bignum.len>>((bytes-1)*8);
-			   --bytes;
-		  }
-	 }
-	 memcpy(p,bignum.data,bignum.len);
-	 entersafe_reverse_buffer(p,bignum.len);
-	 p+=bignum.len;
-	 *ptr = p;
-}
-
-static int entersafe_write_small_rsa_key(sc_card_t *card,u8 key_id,struct sc_pkcs15_prkey_rsa *rsa)
-{
-	 sc_apdu_t apdu;
-	 u8 sbuff[SC_MAX_APDU_BUFFER_SIZE];
-	 int r;
-	 u8 *p=sbuff;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	 {/* write prkey */
-		  *p++=0x00;			/* EC */
-		  *p++=0x00;			/* ver */
-		  entersafe_encode_bignum('E',rsa->exponent,&p);
-		  entersafe_encode_bignum('D',rsa->d,&p);
-
-		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF4,0x22,key_id);
-		  apdu.cla=0x84;
-		  apdu.data=sbuff;
-		  apdu.lc=apdu.datalen=p-sbuff;
-
-		  r=entersafe_transmit_apdu(card,&apdu,key_maintain,sizeof(key_maintain),1,1);
-		  LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-		  LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write prkey failed");
-	 }
-
-	 p=sbuff;
-	 {/* write pukey */
-		  *p++=0x00;			/* EC */
-		  *p++=0x00;			/* ver */
-		  entersafe_encode_bignum('E',rsa->exponent,&p);
-		  entersafe_encode_bignum('N',rsa->modulus,&p);
-
-		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF4,0x2A,key_id);
-		  apdu.cla=0x84;
-		  apdu.data=sbuff;
-		  apdu.lc=apdu.datalen=p-sbuff;
-
-		  r=entersafe_transmit_apdu(card,&apdu,key_maintain,sizeof(key_maintain),1,1);
-		  LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-		  LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write pukey failed");
-	 }
-
-	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
-}
-
-static int entersafe_write_rsa_key_factor(sc_card_t *card,
-										  u8 key_id,u8 usage,
-										  u8 factor,
-										  sc_pkcs15_bignum_t data)
-{
-	int r;
-	sc_apdu_t apdu;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	{/* MSE */
-		 u8 sbuff[4];
-		 sbuff[0]=0x84;
-		 sbuff[1]=0x02;
-		 sbuff[2]=key_id;
-		 sbuff[3]=usage;
-
-		 sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x22,0x01,0xB8);
-		 apdu.data=sbuff;
-		 apdu.lc=apdu.datalen=4;
-		 
-		 r=entersafe_transmit_apdu(card,&apdu,0,0,0,0);
-		 LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-		 LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write prkey factor failed(MSE)");
-	}
-
-	{/* Write 'x'; */
-		u8 sbuff[SC_MAX_APDU_BUFFER_SIZE];
-
-		 sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x46,factor,0x00);
-
-		 memcpy(sbuff,data.data,data.len);
-		 entersafe_reverse_buffer(sbuff,data.len);
-/*
- *  PK01C and PK13C smart card only support 1024 or 2048bit key .
- *  Size of exponent1 exponent2 coefficient of RSA private key keep the same as size of prime1
- *  So check factor is padded with zero or not
- */
-		 switch(factor){
-			 case 0x3:
-			 case 0x4:
-			 case 0x5:
-				 {
-					 if( data.len > 32 && data.len < 64 )
-					 {
-						 for(r = data.len ; r < 64 ; r ++)
-							 sbuff[r] = 0;
-						 data.len = 64;
-					 }
-					 else if( data.len > 64 && data.len < 128 )
-					 {
-						 for(r = data.len ; r < 128 ; r ++)
-							 sbuff[r] = 0;
-						 data.len = 128;
-					 }
-				 }
-				 break;
-			 default:
-				 break;
-		 }
-
-		 apdu.data=sbuff;
-		 apdu.lc=apdu.datalen=data.len;
-
-		 r = entersafe_transmit_apdu(card,&apdu,0,0,0,0);
-		 LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-		 LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write prkey factor failed");
-	}
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
-}
-
-static int entersafe_write_large_rsa_key(sc_card_t *card,u8 key_id,struct sc_pkcs15_prkey_rsa *rsa)
-{
-	 int r;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	 {/* write prkey */
-		  r = entersafe_write_rsa_key_factor(card,key_id,0x22,0x01,rsa->p);
-		  LOG_TEST_RET(card->ctx, r, "write p failed");
-		  r = entersafe_write_rsa_key_factor(card,key_id,0x22,0x02,rsa->q);
-		  LOG_TEST_RET(card->ctx, r, "write q failed");
-		  r = entersafe_write_rsa_key_factor(card,key_id,0x22,0x03,rsa->dmp1);
-		  LOG_TEST_RET(card->ctx, r, "write dmp1 failed");
-		  r = entersafe_write_rsa_key_factor(card,key_id,0x22,0x04,rsa->dmq1);
-		  LOG_TEST_RET(card->ctx, r, "write dmq1 failed");
-		  r = entersafe_write_rsa_key_factor(card,key_id,0x22,0x05,rsa->iqmp);
-		  LOG_TEST_RET(card->ctx, r, "write iqmp failed");
-	 }
-
-	 {/* write pukey */
-		  u8 sbuff[SC_MAX_APDU_BUFFER_SIZE];
-		  sc_apdu_t apdu;
-
-		  /* first 64(0x40) bytes of N */
-		  sbuff[0]=0x83;
-		  sbuff[1]=0x02;
-		  sbuff[2]=key_id;
-		  sbuff[3]=0x2A;
-		  sbuff[4]=0x89;
-		  sbuff[5]=0x40;
-		  memcpy(sbuff+6,rsa->modulus.data,0x40);
-
-		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x22,0x01,0xB8);
-		  apdu.data=sbuff;
-		  apdu.lc=apdu.datalen=0x46;
-
-		  r=entersafe_transmit_apdu(card,&apdu,0,0,0,0);
-		  LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-		  LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write pukey N(1) failed");
-
-		  /* left 192(0xC0) bytes of N */
-		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x46,0x0B,0x00);
-		  apdu.data=rsa->modulus.data+0x40;
-		  apdu.lc=apdu.datalen=0xC0;
-
-		  r=entersafe_transmit_apdu(card,&apdu,0,0,0,0);
-		  LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-		  LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write pukey N(2) failed");
-
-		  /* E */
-		  r = entersafe_write_rsa_key_factor(card,key_id,0x2A,0x0D,rsa->exponent);
-		  LOG_TEST_RET(card->ctx, r, "write exponent failed");
-	 }
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
-}
-
-static int entersafe_write_symmetric_key(sc_card_t *card,
-										 u8 key_id,u8 usage,
-										 u8 EC,u8 ver,
-										 u8 *data,size_t len)
-{
-	 sc_apdu_t apdu;
-	 u8 sbuff[SC_MAX_APDU_BUFFER_SIZE]={0};
-	 int r;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	 if(len>240)
-		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_INCORRECT_PARAMETERS);
-
-	 sbuff[0]=EC;
-	 sbuff[1]=ver;
-	 memcpy(&sbuff[2],data,len);
-
-	 sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF4,usage,key_id);
-	 apdu.cla=0x84;
-	 apdu.data=sbuff;
-	 apdu.lc=apdu.datalen=len+2;
-
-	 r=entersafe_transmit_apdu(card,&apdu,key_maintain,sizeof(key_maintain),1,1);
-	 LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	 LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write prkey failed");
-	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);
-}
-
-static int entersafe_write_key(sc_card_t *card, sc_entersafe_wkey_data *data)
-{
-	 struct sc_pkcs15_prkey_rsa* rsa=data->key_data.rsa;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	 switch(data->usage)
-	 {
-	 case 0x22:
-		  if(rsa->modulus.len < 256)
-			   return entersafe_write_small_rsa_key(card,data->key_id,rsa);
-		  else
-			   return entersafe_write_large_rsa_key(card,data->key_id,rsa);
-		  break;
-	 case 0x2A:
-		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_NOT_SUPPORTED);
-		  break;
-	 default:
-		  return entersafe_write_symmetric_key(card,data->key_id,data->usage,
-											   data->key_data.symmetric.EC,
-											   data->key_data.symmetric.ver,
-											   data->key_data.symmetric.key_val,
-											   data->key_data.symmetric.key_len);
-		  break;
-	 }
-	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
-}
-
-static int entersafe_gen_key(sc_card_t *card, sc_entersafe_gen_key_data *data)
-{
-	int	r;
-	size_t len = data->key_length >> 3;
-	sc_apdu_t apdu;
-	u8 rbuf[300];
-	u8 sbuf[4],*p;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	/* MSE */
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x01, 0xB8);
-	apdu.lc=0x04;
-	sbuf[0]=0x83;
-	sbuf[1]=0x02;
-	sbuf[2]=data->key_id;
-	sbuf[3]=0x2A;
-	apdu.data = sbuf;
-	apdu.datalen=4;
-	apdu.lc=4;
-	apdu.le=0;
-
-	r=entersafe_transmit_apdu(card, &apdu, 0,0,0,0);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	LOG_TEST_RET(card->ctx, sc_check_sw(card,apdu.sw1,apdu.sw2),"EnterSafe set MSE failed");
-
-	/* generate key */
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46,  0x00, 0x00);
-	apdu.le      = 0;
-	sbuf[0] = (u8)(data->key_length >> 8);
-	sbuf[1] = (u8)(data->key_length);
-	apdu.data    = sbuf;
-	apdu.lc      = 2;
-	apdu.datalen = 2;
-
-	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	LOG_TEST_RET(card->ctx, sc_check_sw(card,apdu.sw1,apdu.sw2),"EnterSafe generate key pair failed");
-
-	/* read public key via READ PUBLIC KEY */
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xE6,  0x2A, data->key_id);
-	apdu.cla     = 0x80;
-	apdu.resp    = rbuf;
-	apdu.resplen = sizeof(rbuf);
-	apdu.le      = 256;
-	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	LOG_TEST_RET(card->ctx, sc_check_sw(card,apdu.sw1,apdu.sw2),"EnterSafe get pukey failed");
-
-	data->modulus = malloc(len);
-	if (!data->modulus)
-		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_OUT_OF_MEMORY);
-
-	p=rbuf;
-	if (*p!='E') {
-		free(data->modulus);
-		data->modulus = NULL;
-		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_DATA);
-	}
-	p+=2+p[1];
-	/* N */
-	if (*p!='N') {
-		free(data->modulus);
-		data->modulus = NULL;
-		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_DATA);
-	}
-	++p;
-	if(*p++>0x80)
-	{
-		 u8 len_bytes=(*(p-1))&0x0f;
-		 size_t module_len=0;
-		 while(len_bytes!=0)
-		 {
-			  module_len=module_len<<8;
-			  module_len+=*p++;
-			  --len_bytes;
-		 }
-	}
-
-	entersafe_reverse_buffer(p,len);
-	memcpy(data->modulus,p,len);
-
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
-}
-
-static int entersafe_get_serialnr(sc_card_t *card, sc_serial_number_t *serial)
-{
-	int	r;
-	sc_apdu_t apdu;
-	u8 rbuf[SC_MAX_APDU_BUFFER_SIZE];
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-	assert(serial);
-
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT,0xEA,0x00,0x00);
-	apdu.cla=0x80;
-	apdu.resp=rbuf;
-	apdu.resplen=sizeof(rbuf);
-	apdu.le=0x08;
-
-	r=entersafe_transmit_apdu(card, &apdu,0,0,0,0);
-	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
-	LOG_TEST_RET(card->ctx, sc_check_sw(card,apdu.sw1,apdu.sw2),"EnterSafe get SN failed");
-
-	card->serialnr.len=serial->len=8;
-	memcpy(card->serialnr.value,rbuf,8);
-	memcpy(serial->value,rbuf,8);
-
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
-}
-
-static int entersafe_preinstall_rsa_2048(sc_card_t *card,u8 key_id)
-{
-	u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
-	sc_apdu_t apdu;
-	int ret=0;
-	static u8 const rsa_key_e[] =
-	{
-		'E', 0x04, 0x01, 0x00, 0x01, 0x00
-	};
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	/*  create rsa item in IKF */
-	sbuf[0] = 0x04; /* key len extern */
-	sbuf[1] = 0x0a; /* key len */
-	sbuf[2] = 0x22;	/* USAGE */
-	sbuf[3] = 0x34;	/* user ac */
-	sbuf[4] = 0x04;	/* change ac */
-	sbuf[5] = 0x34;	/* UPDATE AC */
-	sbuf[6] = 0x40;	/* ALGO */
-	sbuf[7] = 0x00;	/* EC */
-	sbuf[8] = 0x00;	/* VER */
-	memcpy(&sbuf[9], rsa_key_e, sizeof(rsa_key_e));
-	sbuf[9 + sizeof(rsa_key_e) + 0] = 'C'+'R'+'T';
-	sbuf[9 + sizeof(rsa_key_e) + 1] = 0x82;
-	sbuf[9 + sizeof(rsa_key_e) + 2] = 0x04;
-	sbuf[9 + sizeof(rsa_key_e) + 3] = 0x00;
-
-	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT,0xF0,0x00,key_id);
-	apdu.cla=0x84;
-	apdu.data=sbuf;
-	apdu.lc=apdu.datalen=9 + sizeof(rsa_key_e) + 4;
-
-	ret = entersafe_transmit_apdu(card,&apdu,init_key,sizeof(init_key),0,1);
-	LOG_TEST_RET(card->ctx, ret, "Preinstall rsa failed");
-
-	/*  create rsa item in PKF */
-	sbuf[0] = 0x01;	/* key len extern */
-	sbuf[1] = 0x0A;	/* key len */
-	sbuf[2] = 0x2A;	/* USAGE */
-	sbuf[3] = ENTERSAFE_AC_ALWAYS;	/* user ac */
-	sbuf[4] = 0x04;	/* change ac */
-	sbuf[5] = ENTERSAFE_AC_ALWAYS;	/* UPDATE AC */
-	sbuf[6] = 0x40;	/* ALGO */
-	sbuf[7] = 0x00;	/* EC */
-	sbuf[8] = 0x00;	/* VER */
-	memcpy(&sbuf[9], rsa_key_e, sizeof(rsa_key_e));		
-	sbuf[9 + sizeof(rsa_key_e) + 0] = 'N';
-	sbuf[9 + sizeof(rsa_key_e) + 1] = 0x82;
-	sbuf[9 + sizeof(rsa_key_e) + 2] = 0x01;
-	sbuf[9 + sizeof(rsa_key_e) + 3] = 0x00;
-
-	sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF0,0x00,key_id);
-	apdu.cla=0x84;
-	apdu.data=sbuf;
-	apdu.lc=apdu.datalen=9 + sizeof(rsa_key_e) + 4;
-
-	ret=entersafe_transmit_apdu(card,&apdu,init_key,sizeof(init_key),0,1);
-	LOG_TEST_RET(card->ctx, ret, "Preinstall rsa failed");
-
-	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
-}
-
-static int entersafe_preinstall_keys(sc_card_t *card,int (*install_rsa)(sc_card_t *,u8))
-{
-	 int r;
-	 u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
-	 sc_apdu_t apdu;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	 {/* RSA */
-		  u8 rsa_index;
-		  for(rsa_index=ENTERSAFE_MIN_KEY_ID;
-			  rsa_index<=ENTERSAFE_MAX_KEY_ID;
-			  ++rsa_index)
-		  {
-			   r=install_rsa(card,rsa_index);
-			   LOG_TEST_RET(card->ctx, r, "Preinstall rsa key failed");
-		  }
-	 }
-
-	 {/* key maintain */
-		  /* create key maintain*/
-		  sbuf[0] = 0;	/* key len extern */
-		  sbuf[1] = sizeof(key_maintain);	/* key len */
-		  sbuf[2] = 0x03;	/* USAGE */
-		  sbuf[3] = ENTERSAFE_AC_ALWAYS;	/* use AC	*/
-		  sbuf[4] = ENTERSAFE_AC_ALWAYS;	/* CHANGE AC */
-		  sbuf[5] = ENTERSAFE_AC_NEVER;	/* UPDATE AC */
-		  sbuf[6] = 0x01;	/* ALGO */
-		  sbuf[7] = 0x00;	/* EC */
-		  sbuf[8] = 0x00;	/* VER */
-		  memcpy(&sbuf[9], key_maintain, sizeof(key_maintain));
-
-		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF0,0x00,0x00);
-		  apdu.cla=0x84;
-		  apdu.data=sbuf;
-		  apdu.lc=apdu.datalen=0x19;
-
-		  r = entersafe_transmit_apdu(card,&apdu,init_key,sizeof(init_key),0,1);
-		  LOG_TEST_RET(card->ctx, r, "Preinstall key maintain failed");
-	 }
-
-	 {/* user PIN */
-		  memset(sbuf,0,sizeof(sbuf));
-		  sbuf[0] = 0;	/* key len extern */
-		  sbuf[1] = 16;	/* key len */
-		  sbuf[2] = 0x0B;	/* USAGE */
-		  sbuf[3] = ENTERSAFE_AC_ALWAYS;	/* use AC */
-		  sbuf[4] = 0X04;	/* CHANGE AC */
-		  sbuf[5] = 0x38;	/* UPDATE AC */
-		  sbuf[6] = 0x01;	/* ALGO */
-		  sbuf[7] = 0xFF;	/* EC */
-		  sbuf[8] = 0x00;	/* VER */
-
-		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF0,0x00,ENTERSAFE_USER_PIN_ID);
-		  apdu.cla=0x84;
-		  apdu.data=sbuf;
-		  apdu.lc=apdu.datalen=0x19;
-
-		  r = entersafe_transmit_apdu(card,&apdu,init_key,sizeof(init_key),0,1);
-		  LOG_TEST_RET(card->ctx, r, "Preinstall user PIN failed");
-	 }
-
-	 {/* user PUK */
-		  memset(sbuf,0,sizeof(sbuf));
-		  sbuf[0] = 0;	/* key len extern */
-		  sbuf[1] = 16;	/* key len */
-		  sbuf[2] = 0x0B;	/* USAGE */
-		  sbuf[3] = ENTERSAFE_AC_ALWAYS;	/* use AC */
-		  sbuf[4] = 0X08;	/* CHANGE AC */
-		  sbuf[5] = 0xC0;	/* UPDATE AC */
-		  sbuf[6] = 0x01;	/* ALGO */
-		  sbuf[7] = 0xFF;	/* EC */
-		  sbuf[8] = 0x00;	/* VER */
-
-		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF0,0x00,ENTERSAFE_USER_PIN_ID+1);
-		  apdu.cla=0x84;
-		  apdu.data=sbuf;
-		  apdu.lc=apdu.datalen=0x19;
-
-		  r = entersafe_transmit_apdu(card,&apdu,init_key,sizeof(init_key),0,1);
-		  LOG_TEST_RET(card->ctx, r, "Preinstall user PUK failed");
-	 }
-
-
-	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
-}
-
-static int entersafe_card_ctl_2048(sc_card_t *card, unsigned long cmd, void *ptr)
-{
-	sc_entersafe_create_data *tmp = (sc_entersafe_create_data *)ptr;
-
-	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
-
-	switch (cmd)
-	{
-	case SC_CARDCTL_ENTERSAFE_CREATE_FILE:
-		if (tmp->type == SC_ENTERSAFE_MF_DATA)
-			return entersafe_create_mf(card, tmp);
-		else if (tmp->type == SC_ENTERSAFE_DF_DATA)
-			return entersafe_create_df(card, tmp);
-		else if (tmp->type == SC_ENTERSAFE_EF_DATA)
-			return entersafe_create_ef(card, tmp);
-		else
-			return SC_ERROR_INTERNAL;
-	case SC_CARDCTL_ENTERSAFE_WRITE_KEY:
-		return entersafe_write_key(card, (sc_entersafe_wkey_data *)ptr);
-	case SC_CARDCTL_ENTERSAFE_GENERATE_KEY:
-		return entersafe_gen_key(card, (sc_entersafe_gen_key_data *)ptr);
-	case SC_CARDCTL_ERASE_CARD:
-		return entersafe_erase_card(card);
-	case SC_CARDCTL_GET_SERIALNR:
-		return entersafe_get_serialnr(card, (sc_serial_number_t *)ptr);
-	case SC_CARDCTL_ENTERSAFE_PREINSTALL_KEYS:
-		 return entersafe_preinstall_keys(card,entersafe_preinstall_rsa_2048);
-	default:
-		return SC_ERROR_NOT_SUPPORTED;
-	}
-}
-
-static struct sc_card_driver * sc_get_driver(void)
-{
-	struct sc_card_driver *iso_drv = sc_get_iso7816_driver();
-
-	if (iso_ops == NULL)
-		iso_ops = iso_drv->ops;
-  
-	entersafe_ops = *iso_drv->ops;
-	entersafe_ops.match_card = entersafe_match_card;
-	entersafe_ops.init   = entersafe_init;
-	entersafe_ops.read_binary = entersafe_read_binary;
-	entersafe_ops.write_binary = NULL;
-	entersafe_ops.update_binary = entersafe_update_binary;
-	entersafe_ops.select_file = entersafe_select_file;
-	entersafe_ops.restore_security_env = entersafe_restore_security_env;
-	entersafe_ops.set_security_env  = entersafe_set_security_env;
-	entersafe_ops.decipher = entersafe_decipher;
-	entersafe_ops.compute_signature = entersafe_compute_signature;
-	entersafe_ops.create_file = entersafe_create_file;
-	entersafe_ops.delete_file = NULL;
-	entersafe_ops.pin_cmd = entersafe_pin_cmd;
-	entersafe_ops.card_ctl    = entersafe_card_ctl_2048;
-	entersafe_ops.process_fci = entersafe_process_fci;
-	return &entersafe_drv;
-}
-
-struct sc_card_driver * sc_get_entersafe_driver(void)
-{
-	return sc_get_driver();
-}
-#endif
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/* Initially written by Weitao Sun (weitao@ftsafe.com) 2008 */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+#ifdef ENABLE_OPENSSL	/* empty file without openssl */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+
+#include "internal.h"
+#include "asn1.h"
+#include "cardctl.h"
+
+#define LENGTH_PART1_HARDCODED 110
+#define LENGTH_PART1_FROM_PUBKEY 120
+#define FINAL_PART1 230
+#define LENGTH_PART2_HARDCODED 10
+#define LENGTH_PART2_FROM_PUBKEY 136
+#define FINAL_PART2 146
+#define LENGTH_PRIVKEY_HARDCODED 119
+
+
+static const struct sc_atr_table entersafe_atrs[] = {
+		{ 	 "3b:d5:18:ff:81:91:fe:1f:c3:80:73:c8:21:10:0a",
+				 NULL,
+				 "NXP/ChipDoc",
+				 SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C,
+				 0,
+				 NULL },
+	{ 
+		 "3b:9f:95:81:31:fe:9f:00:65:46:53:05:30:06:71:df:00:00:00:80:6a:82:5e",
+		 "FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:00:FF:FF:FF:FF:FF:FF:00:00:00:00",
+		 "FTCOS/PK-01C", SC_CARD_TYPE_ENTERSAFE_FTCOS_PK_01C, 0, NULL },
+	 /*{
+		"3b:fc:18:00:00:81:31:80:45:90:67:46:4a:00:64:18:14:00:00:00:00:02",
+		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:00",
+		"EJAVA/PK-01C", SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C, 0, NULL },*/
+	{
+		"3b:7c:18:00:00:90:67:46:4a:20:28:8c:58:00:00:00:00",
+		"ff:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff",
+		"EJAVA/PK-01C-T0",SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C_T0,0,NULL},
+	{
+		"3B:FC:18:00:00:81:31:80:45:90:67:46:4A:21:28:8C:58:00:00:00:00:B7",
+		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:00",
+		"EJAVA/H10CR/PK-01C-T1",SC_CARD_TYPE_ENTERSAFE_EJAVA_H10CR_PK_01C_T1,0,NULL},
+	{
+		"3B:FC:18:00:00:81:31:80:45:90:67:46:4A:20:25:c3:30:00:00:00:00",
+		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:00:00:00:00",
+		"EJAVA/D11CR/PK-01C-T1",SC_CARD_TYPE_ENTERSAFE_EJAVA_D11CR_PK_01C_T1,0,NULL},
+	{
+		"3B:FC:18:00:00:81:31:80:45:90:67:46:4A:00:6A:04:24:00:00:00:00:20",
+		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:00",
+		"EJAVA/C21C/PK-01C-T1",SC_CARD_TYPE_ENTERSAFE_EJAVA_C21C_PK_01C_T1,0,NULL},
+	{
+		"3B:FC:18:00:00:81:31:80:45:90:67:46:4A:00:68:08:04:00:00:00:00:0E",
+		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:00",
+		"EJAVA/A22CR/PK-01C-T1",SC_CARD_TYPE_ENTERSAFE_EJAVA_A22CR_PK_01C_T1,0,NULL},
+	{
+		"3B:FC:18:00:00:81:31:80:45:90:67:46:4A:10:27:61:30:00:00:00:00:0C",
+		"ff:00:00:00:00:00:00:00:00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:00",
+		"EJAVA/A40CR/PK-01C-T1",SC_CARD_TYPE_ENTERSAFE_EJAVA_A40CR_PK_01C_T1,0,NULL},
+	{
+		"3b:fc:18:00:00:81:31:80:45:90:67:46:4a:00:68:08:06:00:00:00:00:0c",
+		"FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:00:FF:FF:FF:FF:FF:FF:00:00:00",
+		"FTCOS/PK-01C", SC_CARD_TYPE_ENTERSAFE_FTCOS_PK_01C, 0, NULL },
+	{ NULL, NULL, NULL, 0, 0, NULL }
+};
+
+static struct sc_card_operations entersafe_ops;
+static struct sc_card_operations *iso_ops = NULL;
+
+static struct sc_card_driver entersafe_drv = {
+	"entersafe",
+	"entersafe",
+	&entersafe_ops,
+	NULL, 0, NULL
+};
+
+static u8 trans_code_3k[] =
+{
+	 0x01,0x02,0x03,0x04,
+	 0x05,0x06,0x07,0x08,
+};
+
+static u8 trans_code_ftcos_pk_01c[] =
+{
+	 0x92,0x34,0x2E,0xEF,
+	 0x23,0x40,0x4F,0xD1,
+};
+
+static u8 init_key[] =
+{
+	 1,  2,  3,  4, 
+	 5,  6,  7,  8, 
+	 9,  10, 11, 12, 
+	 13, 14, 15, 16,
+};
+
+static u8 key_maintain[] =
+{
+	 0x12, 0x34, 0x56, 0x78, 
+	 0x21, 0x43, 0x65, 0x87, 
+	 0x11, 0x22, 0xaa, 0xbb,
+	 0x33, 0x44, 0xcd, 0xef
+};
+
+static void entersafe_reverse_buffer(u8* buff,size_t size)
+{
+	 u8 t;
+	 u8 * end=buff+size-1;
+
+	 while(buff<end)
+	 {
+		  t = *buff;
+		  *buff = *end;
+		  *end=t;
+		  ++buff;
+		  --end;
+	 }
+}
+
+static int entersafe_select_file(sc_card_t *card,
+								 const sc_path_t *in_path,
+								 sc_file_t **file_out);
+
+/* the entersafe part */
+static int entersafe_match_card(sc_card_t *card)
+{
+	int i;
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	i = _sc_match_atr(card, entersafe_atrs, &card->type);
+	if (i < 0)
+		return 0;		
+
+	return 1;
+}
+
+static int entersafe_init(sc_card_t *card)
+{
+	unsigned int flags;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	card->name = "entersafe";
+	card->cla  = 0x00;
+	card->drv_data = NULL;
+
+	flags =SC_ALGORITHM_ONBOARD_KEY_GEN
+		 | SC_ALGORITHM_RSA_RAW
+		 | SC_ALGORITHM_RSA_HASH_NONE;
+
+	_sc_card_add_rsa_alg(card, 512, flags, 0);
+	_sc_card_add_rsa_alg(card, 768, flags, 0);
+	_sc_card_add_rsa_alg(card,1024, flags, 0);
+	_sc_card_add_rsa_alg(card,2048, flags, 0);
+
+	card->caps = SC_CARD_CAP_RNG; 
+
+	/* we need read_binary&friends with max 224 bytes per read */
+	card->max_send_size = 224;
+	card->max_recv_size = 224;
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+}
+
+static int entersafe_gen_random(sc_card_t *card,u8 *buff,size_t size)
+{
+	 int r=SC_SUCCESS;
+	 u8 rbuf[SC_MAX_APDU_BUFFER_SIZE]={0};
+	 sc_apdu_t apdu;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+   
+	 sc_format_apdu(card,&apdu,SC_APDU_CASE_2_SHORT,0x84,0x00,0x00);
+	 apdu.resp=rbuf;
+	 apdu.le=size;
+	 apdu.resplen=sizeof(rbuf);
+
+	 r=sc_transmit_apdu(card,&apdu);
+	 LOG_TEST_RET(card->ctx, r, "entersafe gen random failed");
+
+	 if(apdu.resplen!=size)
+		  LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
+	 memcpy(buff,rbuf,size);
+
+	 LOG_FUNC_RETURN(card->ctx, r);
+}
+
+static int entersafe_cipher_apdu(sc_card_t *card, sc_apdu_t *apdu,
+								 u8 *key, size_t keylen,
+								 u8 *buff, size_t buffsize)
+{
+	 EVP_CIPHER_CTX * ctx = NULL;
+	EVP_CIPHER *alg = NULL;
+
+	 u8 iv[8]={0};
+	 int len;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	 assert(card);
+	 assert(apdu);
+	 assert(key);
+	 assert(buff);
+
+	 /* padding as 0x80 0x00 0x00...... */
+	 memset(buff,0,buffsize);
+	 buff[0]=apdu->lc;
+	 memcpy(buff+1,apdu->data,apdu->lc);
+	 buff[apdu->lc+1]=0x80;
+
+	 ctx = EVP_CIPHER_CTX_new();
+	 if (ctx == NULL)
+		 LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
+	 EVP_CIPHER_CTX_set_padding(ctx,0);
+
+	if (keylen == 8) {
+	 	alg = sc_evp_cipher(card->ctx, "DES-ECB");
+		EVP_EncryptInit_ex(ctx, alg, NULL, key, iv);
+	} else if (keylen == 16) {
+	 	alg = sc_evp_cipher(card->ctx, "DES-EDE");
+		EVP_EncryptInit_ex(ctx, alg, NULL, key, iv);
+	} else {
+		EVP_CIPHER_CTX_free(ctx);
+		  LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
+	}
+
+	 len = apdu->lc;
+	 if(!EVP_EncryptUpdate(ctx, buff, &len, buff, buffsize)){
+		sc_evp_cipher_free(alg);
+		EVP_CIPHER_CTX_free(ctx);
+		  sc_log(card->ctx,  "entersafe encryption error.");
+		  LOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);
+	 }
+	 apdu->lc = len;
+
+	sc_evp_cipher_free(alg);
+	 EVP_CIPHER_CTX_free(ctx);
+
+	 if(apdu->lc!=buffsize)
+	 {
+		  sc_log(card->ctx,  "entersafe build cipher apdu failed.");
+		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INTERNAL);
+	 }
+
+	 apdu->data=buff;
+	 apdu->datalen=apdu->lc;
+
+	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_SUCCESS);
+}
+
+static int entersafe_mac_apdu(sc_card_t *card, sc_apdu_t *apdu,
+							  u8 * key,size_t keylen,
+							  u8 * buff,size_t buffsize)
+{
+	 int r;
+	 u8 iv[8];
+	 u8 *tmp=0,*tmp_rounded=NULL;
+	 size_t tmpsize=0,tmpsize_rounded=0;
+	 int outl=0;
+	 EVP_CIPHER_CTX * ctx = NULL;
+	EVP_CIPHER *alg = NULL;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	 assert(card);
+	 assert(apdu);
+	 assert(key);
+	 assert(buff);
+
+	 if(apdu->cse != SC_APDU_CASE_3_SHORT)
+		  return SC_ERROR_INTERNAL;
+	 if(keylen!=8 && keylen!=16)
+		  return SC_ERROR_INTERNAL;
+
+	 r=entersafe_gen_random(card,iv,sizeof(iv));
+	 LOG_TEST_RET(card->ctx,r,"entersafe gen random failed");
+
+	 /* encode the APDU in the buffer */
+	 if ((r=sc_apdu_get_octets(card->ctx, apdu, &tmp, &tmpsize,SC_PROTO_RAW)) != SC_SUCCESS)
+		  goto out;
+
+	 /* round to 8 */
+	 tmpsize_rounded=(tmpsize/8+1)*8;
+
+	 tmp_rounded = malloc(tmpsize_rounded);
+	 if (tmp_rounded == NULL)
+	 {
+		  r =  SC_ERROR_OUT_OF_MEMORY;
+		  goto out;
+	 }
+	 
+	 /*build content and padded buffer by 0x80 0x00 0x00..... */
+	 memset(tmp_rounded,0,tmpsize_rounded);
+	 memcpy(tmp_rounded,tmp,tmpsize);
+	 tmp_rounded[4]+=4;
+	 tmp_rounded[tmpsize]=0x80;
+
+	 /* block_size-1 blocks*/
+	 ctx = EVP_CIPHER_CTX_new();
+	 if (ctx == NULL) {
+		r =  SC_ERROR_OUT_OF_MEMORY;
+		goto out;
+	 }
+	 EVP_CIPHER_CTX_set_padding(ctx,0);
+	alg = sc_evp_cipher(card->ctx, "DES-CBC");
+	EVP_EncryptInit_ex(ctx, alg, NULL, key, iv);
+
+	 if(tmpsize_rounded>8){
+		  if(!EVP_EncryptUpdate(ctx,tmp_rounded,&outl,tmp_rounded,tmpsize_rounded-8)){
+			   r = SC_ERROR_INTERNAL;
+			   goto out;			   
+		  }
+	 }
+	 /* last block */
+	 if(keylen==8)
+	 {
+		  if(!EVP_EncryptUpdate(ctx,tmp_rounded+outl,&outl,tmp_rounded+outl,8)){
+			   r = SC_ERROR_INTERNAL;
+			   goto out;			   
+		  }
+	 }
+	 else
+	 {
+		  EVP_EncryptInit_ex(ctx, EVP_des_ede_cbc(), NULL, key,tmp_rounded+outl-8);
+		  if(!EVP_EncryptUpdate(ctx,tmp_rounded+outl,&outl,tmp_rounded+outl,8)){
+			   r = SC_ERROR_INTERNAL;
+			   goto out;			   
+		  }
+	 }
+
+	 memcpy(buff,apdu->data,apdu->lc);
+	 /* use first 4 bytes of last block as mac value*/
+	 memcpy(buff+apdu->lc,tmp_rounded+tmpsize_rounded-8,4);
+	 apdu->data=buff;
+	 apdu->lc+=4;
+	 apdu->datalen=apdu->lc;
+
+out:
+	 if(tmp)
+		  free(tmp);
+	 if(tmp_rounded)
+		  free(tmp_rounded);
+	 if (ctx) {
+		sc_evp_cipher_free(alg);
+		EVP_CIPHER_CTX_free(ctx);
+	}
+
+	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
+}
+
+static int entersafe_transmit_apdu(sc_card_t *card, sc_apdu_t *apdu,
+								   u8 * key, size_t keylen,
+								   int cipher,int mac)
+{
+	 u8 *cipher_data=0,*mac_data=0;
+	 size_t cipher_data_size,mac_data_size;
+	 int blocks;
+	 int r=SC_SUCCESS;
+	 u8 *sbuf=NULL;
+	 size_t ssize=0;
+
+	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	 assert(card);
+	 assert(apdu);
+
+	 if((cipher||mac) && (!key||(keylen!=8 && keylen!=16)))
+		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
+
+	 r = sc_apdu_get_octets(card->ctx, apdu, &sbuf, &ssize, SC_PROTO_RAW);
+	 if (r == SC_SUCCESS)
+		  sc_apdu_log(card->ctx, sbuf, ssize, 1);
+	 if(sbuf)
+		  free(sbuf);
+
+	 if(cipher)
+	 {
+		  blocks=(apdu->lc+2)/8+1;
+		  cipher_data_size=blocks*8;
+		  cipher_data=malloc(cipher_data_size);
+		  if(!cipher_data)
+		  {
+			   r = SC_ERROR_OUT_OF_MEMORY;
+			   goto out;
+		  }
+
+		  if((r = entersafe_cipher_apdu(card,apdu,key,keylen,cipher_data,cipher_data_size))<0)
+			   goto out;
+	 }
+	 if(mac)
+	 {	 
+		  mac_data_size=apdu->lc+4;
+		  mac_data=malloc(mac_data_size);
+		  if(!mac_data)
+		  {
+			   r = SC_ERROR_OUT_OF_MEMORY;
+			   goto out;
+		  }
+		  r = entersafe_mac_apdu(card,apdu,key,keylen,mac_data,mac_data_size);
+		  if(r < 0)
+			   goto out;
+	 }
+	 
+	 r = sc_transmit_apdu(card,apdu);
+
+out:
+	 if(cipher_data)
+		  free(cipher_data);
+	 if(mac_data)
+		  free(mac_data);
+
+	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
+}
+
+static int entersafe_read_binary(sc_card_t *card,
+								 unsigned int idx, u8 *buf, size_t count,
+								 unsigned long *flags)
+{
+	sc_apdu_t apdu;
+	u8 recvbuf[SC_MAX_APDU_BUFFER_SIZE];
+	int r;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	assert(count <= card->max_recv_size);
+	sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0,
+		       (idx >> 8) & 0xFF, idx & 0xFF);
+
+	apdu.cla=idx > 0x7fff ? 0x80:0x00;
+	apdu.le = count;
+	apdu.resplen = count;
+	apdu.resp = recvbuf;
+
+	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+	if (apdu.resplen == 0)
+		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));
+	memcpy(buf, recvbuf, apdu.resplen);
+
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, apdu.resplen);
+}
+
+static int entersafe_update_binary(sc_card_t *card,
+								   unsigned int idx, const u8 *buf,
+								   size_t count, unsigned long flags)
+{
+	sc_apdu_t apdu;
+	int r;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	assert(count <= card->max_send_size);
+
+	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xD6,
+		       (idx >> 8) & 0xFF, idx & 0xFF);
+	apdu.cla=idx > 0x7fff ? 0x80:0x00;
+	apdu.lc = count;
+	apdu.datalen = count;
+	apdu.data = buf;
+
+	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+	LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),
+		    "Card returned error");
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, count);
+}
+
+
+static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
+						  const u8 *buf, size_t buflen)
+{
+	 int r;
+
+	 assert(file);
+	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	 r = iso_ops->process_fci(card,file,buf,buflen);
+	 LOG_TEST_RET(card->ctx, r, "Process fci failed");
+
+	 if(file->namelen)
+	 {
+		  file->type = SC_FILE_TYPE_DF;
+		  file->ef_structure = SC_FILE_EF_UNKNOWN;
+	 }
+	 else
+	 {
+		  file->type = SC_FILE_TYPE_WORKING_EF;
+		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
+	 }
+
+	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
+}
+
+static int entersafe_select_fid(sc_card_t *card,
+								unsigned int id_hi, unsigned int id_lo,
+								sc_file_t **file_out)
+{
+	int r;
+	sc_file_t *file = NULL;
+	sc_path_t path;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+	memset(&path, 0, sizeof(sc_path_t));
+
+	path.type=SC_PATH_TYPE_FILE_ID;
+	path.value[0]=id_hi;
+	path.value[1]=id_lo;
+	path.len=2;
+
+	r = iso_ops->select_file(card,&path,&file);
+	if (r < 0)
+		sc_file_free(file);
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+
+	/* update cache */
+	if (file->type == SC_FILE_TYPE_DF) {
+		 card->cache.current_path.type = SC_PATH_TYPE_PATH;
+		 card->cache.current_path.value[0] = 0x3f;
+		 card->cache.current_path.value[1] = 0x00;
+		 if (id_hi == 0x3f && id_lo == 0x00){
+			  card->cache.current_path.len = 2;
+		 } else {
+			  card->cache.current_path.len = 4;
+			  card->cache.current_path.value[2] = id_hi;
+			  card->cache.current_path.value[3] = id_lo;
+		 }
+	}
+	
+	if (file_out)
+		*file_out = file;
+	else
+		sc_file_free(file);
+
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_SUCCESS);
+}
+
+static int entersafe_select_aid(sc_card_t *card,
+								const sc_path_t *in_path,
+								sc_file_t **file_out)
+{
+	int r = 0;
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+	if (card->cache.valid 
+		&& card->cache.current_path.type == SC_PATH_TYPE_DF_NAME
+		&& card->cache.current_path.len == in_path->len
+		&& memcmp(card->cache.current_path.value, in_path->value, in_path->len)==0 )
+	{
+		 if(file_out)
+		 {
+			  *file_out = sc_file_new();
+			  if(!file_out)
+				   LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
+		 }
+	}
+	else
+	{
+		 r = iso_ops->select_file(card,in_path,file_out);
+		 LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+
+		 /* update cache */
+		 card->cache.current_path.type = SC_PATH_TYPE_DF_NAME;
+		 card->cache.current_path.len = in_path->len;
+		 memcpy(card->cache.current_path.value,in_path->value,in_path->len);
+	}
+	if (file_out) {
+		 sc_file_t *file = *file_out;
+		 assert(file);
+
+		 file->type = SC_FILE_TYPE_DF;
+		 file->ef_structure = SC_FILE_EF_UNKNOWN;
+		 file->path.len = 0;
+		 file->size = 0;
+		 /* AID */
+		 memcpy(file->name,in_path->value,in_path->len);
+		 file->namelen = in_path->len;
+		 file->id = 0x0000;
+	}
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
+}
+
+static int entersafe_select_path(sc_card_t *card,
+								const u8 pathbuf[16], const size_t len,
+								sc_file_t **file_out)
+{
+	 u8 n_pathbuf[SC_MAX_PATH_SIZE];
+	 const u8 *path=pathbuf;
+	 size_t pathlen=len;
+	 int bMatch = -1;
+	 unsigned int i;
+	 int r;
+
+	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE); //added by Neel
+
+	 if (pathlen%2 != 0 || pathlen > 6 || pathlen <= 0)
+		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
+
+	 /* if pathlen == 6 then the first FID must be MF (== 3F00) */
+	 if (pathlen == 6 && ( path[0] != 0x3f || path[1] != 0x00 ))
+		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
+
+	 /* unify path (the first FID should be MF) */
+	 if (path[0] != 0x3f || path[1] != 0x00)
+	 {
+		  n_pathbuf[0] = 0x3f;
+		  n_pathbuf[1] = 0x00;
+		  memcpy(n_pathbuf+2, path, pathlen);
+		  path = n_pathbuf;
+		  pathlen += 2; 
+	 }
+	
+	 /* check current working directory */
+	 if (card->cache.valid 
+		 && card->cache.current_path.type == SC_PATH_TYPE_PATH
+		 && card->cache.current_path.len >= 2
+		 && card->cache.current_path.len <= pathlen )
+	 {
+		  bMatch = 0;
+		  for (i=0; i < card->cache.current_path.len; i+=2)
+			   if (card->cache.current_path.value[i] == path[i] 
+				   && card->cache.current_path.value[i+1] == path[i+1] )
+					bMatch += 2;
+	 }
+
+	 if ( card->cache.valid && bMatch > 2 )
+	 {
+		  if ( pathlen - bMatch == 2 )
+		  {
+			   /* we are in the right directory */
+			   return entersafe_select_fid(card, path[bMatch], path[bMatch+1], file_out);
+		  }
+		  else if ( pathlen - bMatch > 2 )
+		  {
+			   /* two more steps to go */
+			   sc_path_t new_path;
+	
+			   /* first step: change directory */
+			   r = entersafe_select_fid(card, path[bMatch], path[bMatch+1], NULL);
+			   LOG_TEST_RET(card->ctx, r, "SELECT FILE (DF-ID) failed");
+	
+		   	   memset(&new_path, 0, sizeof(sc_path_t));
+
+			   new_path.type = SC_PATH_TYPE_PATH;
+			   new_path.len  = pathlen - bMatch-2;
+			   memcpy(new_path.value, &(path[bMatch+2]), new_path.len);
+			   /* final step: select file */
+			   return entersafe_select_file(card, &new_path, file_out);
+		  }
+		  else /* if (bMatch - pathlen == 0) */
+		  {
+			   /* done: we are already in the
+				* requested directory */
+			   sc_log(card->ctx, 
+				"cache hit\n");
+			   /* copy file info (if necessary) */
+			   if (file_out) {
+					sc_file_t *file = sc_file_new();
+					if (!file)
+						 LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
+					file->id = (path[pathlen-2] << 8) +
+						 path[pathlen-1];
+					file->path = card->cache.current_path;
+					file->type = SC_FILE_TYPE_DF;
+					file->ef_structure = SC_FILE_EF_UNKNOWN;
+					file->size = 0;
+					file->namelen = 0;
+					file->magic = SC_FILE_MAGIC;
+					*file_out = file;
+			   }
+			   /* nothing left to do */
+			   return SC_SUCCESS;
+		  }
+	 }
+	 else
+	 {
+		  /* no usable cache */
+		  for ( i=0; i<pathlen-2; i+=2 )
+		  {
+			   r = entersafe_select_fid(card, path[i], path[i+1], NULL);
+			   LOG_TEST_RET(card->ctx, r, "SELECT FILE (DF-ID) failed");
+		  }
+		  return entersafe_select_fid(card, path[pathlen-2], path[pathlen-1], file_out);
+	 }
+}
+
+static int entersafe_select_file(sc_card_t *card,
+								 const sc_path_t *in_path,
+								 sc_file_t **file_out)
+{
+	 int r;
+	 char pbuf[SC_MAX_PATH_STRING_SIZE];
+	 assert(card);
+	 assert(in_path);
+	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+
+	  r = sc_path_print(pbuf, sizeof(pbuf), &card->cache.current_path);
+	  if (r != SC_SUCCESS)
+		 pbuf[0] = '\0';
+
+	  sc_log(card->ctx, 
+		   "current path (%s, %s): %s (len: %"SC_FORMAT_LEN_SIZE_T"u)\n",
+		   card->cache.current_path.type == SC_PATH_TYPE_DF_NAME ?
+		   "aid" : "path",
+		   card->cache.valid ? "valid" : "invalid", pbuf,
+		   card->cache.current_path.len);
+
+	 switch(in_path->type)
+	 {
+	 case SC_PATH_TYPE_FILE_ID:
+		  if (in_path->len != 2)
+			   SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_INVALID_ARGUMENTS);
+		  return entersafe_select_fid(card,in_path->value[0],in_path->value[1], file_out);
+	 case SC_PATH_TYPE_DF_NAME:
+		  return entersafe_select_aid(card,in_path,file_out);
+	 case SC_PATH_TYPE_PATH:
+		  return entersafe_select_path(card,in_path->value,in_path->len,file_out);
+	 default:
+		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
+	 }
+}
+
+static int entersafe_create_mf(sc_card_t *card, sc_entersafe_create_data * data)
+{
+	int r;
+	sc_apdu_t apdu;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	memcpy(data->data.df.init_key, init_key, sizeof(init_key));
+
+	sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xE0,0x00,0x00);
+	apdu.cla=0x84;
+	apdu.data=(u8*)&data->data.df;
+	apdu.datalen=apdu.lc=sizeof(data->data.df);
+
+	switch(card->type)
+	{
+	case SC_CARD_TYPE_ENTERSAFE_3K:
+	{
+		 r = entersafe_transmit_apdu(card, &apdu,trans_code_3k,sizeof(trans_code_3k),0,1);
+	}break;
+	case SC_CARD_TYPE_ENTERSAFE_FTCOS_PK_01C:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C_T0:	
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_H10CR_PK_01C_T1:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_D11CR_PK_01C_T1:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_C21C_PK_01C_T1:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_A22CR_PK_01C_T1:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_A40CR_PK_01C_T1:	
+	{
+		 r = entersafe_transmit_apdu(card, &apdu,trans_code_ftcos_pk_01c,sizeof(trans_code_ftcos_pk_01c),0,1);
+	}break;
+	default:
+	{
+		 r = SC_ERROR_INTERNAL;
+	}break;
+	}
+
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+	return sc_check_sw(card, apdu.sw1, apdu.sw2);
+}
+static int entersafe_create_df(sc_card_t *card, sc_entersafe_create_data * data)
+{
+	int r;
+	sc_apdu_t apdu;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	memcpy(data->data.df.init_key, init_key, sizeof(init_key));
+
+	sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xE0,0x01,0x00);
+	apdu.cla=0x84;
+	apdu.data=(u8*)&data->data.df;
+	apdu.lc=apdu.datalen=sizeof(data->data.df);
+
+	r = entersafe_transmit_apdu(card, &apdu,init_key,sizeof(init_key),0,1);
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+	return sc_check_sw(card, apdu.sw1, apdu.sw2);
+}
+
+static int entersafe_create_ef(sc_card_t *card, sc_entersafe_create_data * data)
+{
+	int r;
+	sc_apdu_t apdu;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0x02, 0x00);
+	apdu.cla = 0x84;
+	apdu.data = (u8*)&data->data.ef;
+	apdu.lc = apdu.datalen = sizeof(data->data.ef);
+
+	r = entersafe_transmit_apdu(card, &apdu,init_key,sizeof(init_key),0,1);
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+	return sc_check_sw(card, apdu.sw1, apdu.sw2);
+}
+
+static u8 process_acl_entry(sc_file_t *in, unsigned int method, unsigned int in_def)
+{
+	u8 def = (u8)in_def;
+	const sc_acl_entry_t *entry = sc_file_get_acl_entry(in, method);
+	if (!entry)
+	{
+		return def;
+	}
+	else if (entry->method & SC_AC_CHV)
+	{
+		unsigned int key_ref = entry->key_ref;
+		if (key_ref == SC_AC_KEY_REF_NONE)
+			return def;
+		else
+			return ENTERSAFE_AC_ALWAYS&0x04;
+	}
+	else if (entry->method & SC_AC_NEVER)
+	{
+		return ENTERSAFE_AC_NEVER;
+	}
+	else
+	{
+		return def;
+	}
+}
+
+static int entersafe_create_file(sc_card_t *card, sc_file_t *file)
+{	
+	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+	 
+	 if (file->type == SC_FILE_TYPE_WORKING_EF) {
+		  sc_entersafe_create_data data;
+		  memset(&data,0,sizeof(data));
+
+		  data.data.ef.file_id[0] = (file->id>>8)&0xFF;	
+		  data.data.ef.file_id[1] = file->id&0xFF;	
+		  data.data.ef.size[0] = (file->size>>8)&0xFF;
+		  data.data.ef.size[1] = file->size&0xFF;
+		  memset(data.data.ef.ac,ENTERSAFE_AC_ALWAYS,sizeof(data.data.ef.ac));
+		  data.data.ef.ac[0] = process_acl_entry(file,SC_AC_OP_READ,ENTERSAFE_AC_ALWAYS);
+		  data.data.ef.ac[1] = process_acl_entry(file,SC_AC_OP_UPDATE,ENTERSAFE_AC_ALWAYS);
+
+		  return entersafe_create_ef(card, &data);
+	 } else
+		  return SC_ERROR_INVALID_ARGUMENTS;
+}
+
+static int entersafe_internal_set_security_env(sc_card_t *card,
+											   const sc_security_env_t *env,
+											   u8 ** data,size_t* size)
+{
+	sc_apdu_t apdu;
+	u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
+	u8 *p=sbuf;
+	int r;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	assert(card != NULL && env != NULL);
+	
+	switch (env->operation) {
+	case SC_SEC_OPERATION_DECIPHER:
+	case SC_SEC_OPERATION_SIGN:
+		 sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0, 0);
+		 apdu.p1 = 0x41;
+		 apdu.p2 = 0xB8;
+		 *p++ = 0x80;
+		 *p++ = 0x01;
+		 *p++ = 0x80;
+		 *p++ = 0x83;
+		 *p++ = 0x02;
+		 *p++ = env->key_ref[0];
+		 *p++ = 0x22;
+		 if(*size>1024/8)
+		 {
+			  if(*size == 2048/8)
+			  {
+				   *p++ = 0x89;
+				   *p++ = 0x40;
+				   memcpy(p,*data,0x40);
+				   p+=0x40;
+				   *data+=0x40;
+				   *size-=0x40;
+			  }
+			  else
+			  {
+				   SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
+			  }
+		 }
+		 break;
+	default:
+		 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);
+	}
+	
+	apdu.le = 0;
+	apdu.lc = apdu.datalen = p - sbuf;
+	apdu.data = sbuf;
+	apdu.resplen = 0;
+
+	r = sc_transmit_apdu(card, &apdu);
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+	return sc_check_sw(card, apdu.sw1, apdu.sw2);
+}
+
+/**
+ * We don't really set the security environment,but cache it.It will be set when
+ * security operation is performed later.Because we may transport partial of
+ * the sign/decipher data within the security environment apdu.
+ */
+static int entersafe_set_security_env(sc_card_t *card,
+									  const sc_security_env_t *env,
+									  int se_num)
+{
+	 assert(card);
+	 assert(env);
+
+	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	 if(card->drv_data){
+		  free(card->drv_data);
+		  card->drv_data=0;
+	 }
+
+	 card->drv_data = calloc(1,sizeof(*env));
+	 if(!card->drv_data)
+		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_OUT_OF_MEMORY);
+
+	 memcpy(card->drv_data,env,sizeof(*env));
+	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, SC_SUCCESS);
+}
+
+static int entersafe_restore_security_env(sc_card_t *card, int se_num)
+{
+	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+	 return SC_SUCCESS;
+}
+
+
+static int entersafe_compute_with_prkey(sc_card_t *card,
+										const u8 * data, size_t datalen,
+										u8 * out, size_t outlen)
+{
+	int r;
+	sc_apdu_t apdu;
+	u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
+	u8 rbuf[SC_MAX_APDU_BUFFER_SIZE];
+	u8* p=sbuf;
+	size_t size = datalen;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	if(!data)
+		 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_INVALID_ARGUMENTS);
+
+	memcpy(p,data,size);
+
+	if(!card->drv_data)
+		 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_INTERNAL);
+
+	r = entersafe_internal_set_security_env(card,card->drv_data,&p,&size);
+	LOG_TEST_RET(card->ctx, r, "internal set security env failed");
+   
+	sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x86,0x80);
+	apdu.data=p;
+	apdu.lc = size;
+	apdu.datalen = size;
+	apdu.resp = rbuf;
+	apdu.resplen = sizeof(rbuf);
+	apdu.le = 256;
+
+	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+
+	if (apdu.sw1 == 0x90 && apdu.sw2 == 0x00) {
+		size_t len = apdu.resplen > outlen ? outlen : apdu.resplen;
+		memcpy(out, apdu.resp, len);
+		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len);
+	}
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));
+}
+
+static int entersafe_compute_signature(sc_card_t *card,
+									   const u8 * data, size_t datalen,
+									   u8 * out, size_t outlen)
+{
+	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+	 return entersafe_compute_with_prkey(card,data,datalen,out,outlen);
+}
+
+static int entersafe_decipher(sc_card_t *card,
+							  const u8 * crgram, size_t crgram_len,
+							  u8 * out, size_t outlen)
+{
+	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+	 return entersafe_compute_with_prkey(card,crgram,crgram_len,out,outlen);
+}
+
+static void entersafe_init_pin_info(struct sc_pin_cmd_pin *pin, unsigned int num)
+{
+	pin->encoding   = SC_PIN_ENCODING_ASCII;
+	pin->min_length = 4;
+	pin->max_length = 16;
+	pin->pad_length = 16;
+	pin->offset     = 5 + num * 16;
+	pin->pad_char   = 0x00;
+}
+
+static int entersafe_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data,
+			   int *tries_left)
+{
+	 int r;
+	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+	 entersafe_init_pin_info(&data->pin1,0);
+	 entersafe_init_pin_info(&data->pin2,1);
+	 //data->flags |= SC_PIN_CMD_NEED_PADDING;
+
+	 if(data->cmd!=SC_PIN_CMD_UNBLOCK)
+	 {
+		  r = iso_ops->pin_cmd(card,data,tries_left);
+		  sc_log(card->ctx,  "Verify rv:%i", r);
+	 }
+	 else
+	 {
+		  {/*verify*/
+			   sc_apdu_t apdu;
+			   u8 sbuf[0x10]={0};
+
+			   memcpy(sbuf,data->pin1.data,data->pin1.len);
+			   sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT,0x20,0x00,data->pin_reference+1);
+			   apdu.lc = apdu.datalen = sizeof(sbuf);
+			   apdu.data = sbuf;
+
+			   r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+			   LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		  }
+
+		  {/*change*/
+			   sc_apdu_t apdu;
+			   u8 sbuf[0x12]={0};
+			   
+			   sbuf[0] = 0x33;
+			   sbuf[1] = 0x00;
+			   memcpy(sbuf+2,data->pin2.data,data->pin2.len);
+			   sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT,0xF4,0x0B,data->pin_reference);
+			   apdu.cla = 0x84;
+			   apdu.lc = apdu.datalen = sizeof(sbuf);
+			   apdu.data = sbuf;
+
+			   r = entersafe_transmit_apdu(card, &apdu,key_maintain,sizeof(key_maintain),1,1);
+			   LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		  }
+	 }
+	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
+}
+
+static int entersafe_erase_card(sc_card_t *card)
+{
+	int r;
+	u8  sbuf[2];
+	sc_apdu_t apdu;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	sbuf[0] = 0x3f;
+	sbuf[1] = 0x00;
+	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 0x00, 0x00);
+	apdu.lc   = 2;
+	apdu.datalen = 2;
+	apdu.data = sbuf;
+	
+	r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+	sc_invalidate_cache(card);
+
+	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xEE, 0x00, 0x00);
+	apdu.cla=0x84;
+	apdu.lc=2;
+	apdu.datalen=2;
+	apdu.data=sbuf;
+
+	switch(card->type)
+	{
+	case SC_CARD_TYPE_ENTERSAFE_3K:
+	{
+		 r = entersafe_transmit_apdu(card, &apdu,trans_code_3k,sizeof(trans_code_3k),0,1);
+	}break;
+	case SC_CARD_TYPE_ENTERSAFE_FTCOS_PK_01C:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_PK_01C_T0:		
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_H10CR_PK_01C_T1:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_D11CR_PK_01C_T1:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_C21C_PK_01C_T1:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_A22CR_PK_01C_T1:
+	case SC_CARD_TYPE_ENTERSAFE_EJAVA_A40CR_PK_01C_T1:
+	{
+		 r = entersafe_transmit_apdu(card, &apdu,trans_code_ftcos_pk_01c,sizeof(trans_code_ftcos_pk_01c),0,1);
+	}break;
+	default:
+	{
+		 r = SC_ERROR_INTERNAL;
+	}break;
+	}
+
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));
+}
+
+static void entersafe_encode_bignum(u8 tag,sc_pkcs15_bignum_t bignum,u8** ptr)
+{
+	 u8 *p=*ptr;
+
+	 *p++=tag;
+	 if(bignum.len<128)
+	 {
+		  *p++=(u8)bignum.len;
+	 }
+	 else
+	 {
+		  u8 bytes=1;
+		  size_t len=bignum.len;
+		  while(len)
+		  {
+			   len=len>>8;
+			   ++bytes;
+		  }
+		  bytes&=0x0F;
+		  *p++=0x80|bytes;
+		  while(bytes)
+		  {
+			   *p++=bignum.len>>((bytes-1)*8);
+			   --bytes;
+		  }
+	 }
+	 memcpy(p,bignum.data,bignum.len);
+	 entersafe_reverse_buffer(p,bignum.len);
+	 p+=bignum.len;
+	 *ptr = p;
+}
+
+static int entersafe_write_small_rsa_key(sc_card_t *card,u8 key_id,struct sc_pkcs15_prkey_rsa *rsa)
+{
+	 sc_apdu_t apdu;
+	 u8 sbuff[SC_MAX_APDU_BUFFER_SIZE];
+	 int r;
+	 u8 *p=sbuff;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	 {/* write prkey */
+		  *p++=0x00;			/* EC */
+		  *p++=0x00;			/* ver */
+		  entersafe_encode_bignum('E',rsa->exponent,&p);
+		  entersafe_encode_bignum('D',rsa->d,&p);
+
+		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF4,0x22,key_id);
+		  apdu.cla=0x84;
+		  apdu.data=sbuff;
+		  apdu.lc=apdu.datalen=p-sbuff;
+
+		  r=entersafe_transmit_apdu(card,&apdu,key_maintain,sizeof(key_maintain),1,1);
+		  LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		  LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write prkey failed");
+	 }
+
+	 p=sbuff;
+	 {/* write pukey */
+		  *p++=0x00;			/* EC */
+		  *p++=0x00;			/* ver */
+		  entersafe_encode_bignum('E',rsa->exponent,&p);
+		  entersafe_encode_bignum('N',rsa->modulus,&p);
+
+		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF4,0x2A,key_id);
+		  apdu.cla=0x84;
+		  apdu.data=sbuff;
+		  apdu.lc=apdu.datalen=p-sbuff;
+
+		  r=entersafe_transmit_apdu(card,&apdu,key_maintain,sizeof(key_maintain),1,1);
+		  LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		  LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write pukey failed");
+	 }
+
+	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+}
+
+static int entersafe_write_rsa_key_factor(sc_card_t *card,
+										  u8 key_id,u8 usage,
+										  u8 factor,
+										  sc_pkcs15_bignum_t data)
+{
+	int r;
+	sc_apdu_t apdu;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	{/* MSE */
+		 u8 sbuff[4];
+		 sbuff[0]=0x84;
+		 sbuff[1]=0x02;
+		 sbuff[2]=key_id;
+		 sbuff[3]=usage;
+
+		 sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x22,0x01,0xB8);
+		 apdu.data=sbuff;
+		 apdu.lc=apdu.datalen=4;
+		 
+		 r=entersafe_transmit_apdu(card,&apdu,0,0,0,0);
+		 LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		 LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write prkey factor failed(MSE)");
+	}
+
+	{/* Write 'x'; */
+		u8 sbuff[SC_MAX_APDU_BUFFER_SIZE];
+
+		 sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x46,factor,0x00);
+
+		 memcpy(sbuff,data.data,data.len);
+		 entersafe_reverse_buffer(sbuff,data.len);
+/*
+ *  PK01C and PK13C smart card only support 1024 or 2048bit key .
+ *  Size of exponent1 exponent2 coefficient of RSA private key keep the same as size of prime1
+ *  So check factor is padded with zero or not
+ */
+		 switch(factor){
+			 case 0x3:
+			 case 0x4:
+			 case 0x5:
+				 {
+					 if( data.len > 32 && data.len < 64 )
+					 {
+						 for(r = data.len ; r < 64 ; r ++)
+							 sbuff[r] = 0;
+						 data.len = 64;
+					 }
+					 else if( data.len > 64 && data.len < 128 )
+					 {
+						 for(r = data.len ; r < 128 ; r ++)
+							 sbuff[r] = 0;
+						 data.len = 128;
+					 }
+				 }
+				 break;
+			 default:
+				 break;
+		 }
+
+		 apdu.data=sbuff;
+		 apdu.lc=apdu.datalen=data.len;
+
+		 r = entersafe_transmit_apdu(card,&apdu,0,0,0,0);
+		 LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		 LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write prkey factor failed");
+	}
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+}
+
+static int entersafe_write_large_rsa_key(sc_card_t *card,u8 key_id,struct sc_pkcs15_prkey_rsa *rsa)
+{
+	 int r;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	 {/* write prkey */
+		  r = entersafe_write_rsa_key_factor(card,key_id,0x22,0x01,rsa->p);
+		  LOG_TEST_RET(card->ctx, r, "write p failed");
+		  r = entersafe_write_rsa_key_factor(card,key_id,0x22,0x02,rsa->q);
+		  LOG_TEST_RET(card->ctx, r, "write q failed");
+		  r = entersafe_write_rsa_key_factor(card,key_id,0x22,0x03,rsa->dmp1);
+		  LOG_TEST_RET(card->ctx, r, "write dmp1 failed");
+		  r = entersafe_write_rsa_key_factor(card,key_id,0x22,0x04,rsa->dmq1);
+		  LOG_TEST_RET(card->ctx, r, "write dmq1 failed");
+		  r = entersafe_write_rsa_key_factor(card,key_id,0x22,0x05,rsa->iqmp);
+		  LOG_TEST_RET(card->ctx, r, "write iqmp failed");
+	 }
+
+	 {/* write pukey */
+		  u8 sbuff[SC_MAX_APDU_BUFFER_SIZE];
+		  sc_apdu_t apdu;
+
+		  /* first 64(0x40) bytes of N */
+		  sbuff[0]=0x83;
+		  sbuff[1]=0x02;
+		  sbuff[2]=key_id;
+		  sbuff[3]=0x2A;
+		  sbuff[4]=0x89;
+		  sbuff[5]=0x40;
+		  memcpy(sbuff+6,rsa->modulus.data,0x40);
+
+		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x22,0x01,0xB8);
+		  apdu.data=sbuff;
+		  apdu.lc=apdu.datalen=0x46;
+
+		  r=entersafe_transmit_apdu(card,&apdu,0,0,0,0);
+		  LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		  LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write pukey N(1) failed");
+
+		  /* left 192(0xC0) bytes of N */
+		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0x46,0x0B,0x00);
+		  apdu.data=rsa->modulus.data+0x40;
+		  apdu.lc=apdu.datalen=0xC0;
+
+		  r=entersafe_transmit_apdu(card,&apdu,0,0,0,0);
+		  LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		  LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write pukey N(2) failed");
+
+		  /* E */
+		  r = entersafe_write_rsa_key_factor(card,key_id,0x2A,0x0D,rsa->exponent);
+		  LOG_TEST_RET(card->ctx, r, "write exponent failed");
+	 }
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+}
+
+static int entersafe_write_symmetric_key(sc_card_t *card,
+										 u8 key_id,u8 usage,
+										 u8 EC,u8 ver,
+										 u8 *data,size_t len)
+{
+	 sc_apdu_t apdu;
+	 u8 sbuff[SC_MAX_APDU_BUFFER_SIZE]={0};
+	 int r;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	 if(len>240)
+		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_INCORRECT_PARAMETERS);
+
+	 sbuff[0]=EC;
+	 sbuff[1]=ver;
+	 memcpy(&sbuff[2],data,len);
+
+	 sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF4,usage,key_id);
+	 apdu.cla=0x84;
+	 apdu.data=sbuff;
+	 apdu.lc=apdu.datalen=len+2;
+
+	 r=entersafe_transmit_apdu(card,&apdu,key_maintain,sizeof(key_maintain),1,1);
+	 LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+	 LOG_TEST_RET(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2),"Write prkey failed");
+	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);
+}
+
+static int entersafe_write_key(sc_card_t *card, sc_entersafe_wkey_data *data)
+{
+	 struct sc_pkcs15_prkey_rsa* rsa=data->key_data.rsa;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	 switch(data->usage)
+	 {
+	 case 0x22:
+		  if(rsa->modulus.len < 256)
+			   return entersafe_write_small_rsa_key(card,data->key_id,rsa);
+		  else
+			   return entersafe_write_large_rsa_key(card,data->key_id,rsa);
+		  break;
+	 case 0x2A:
+		  SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_ERROR_NOT_SUPPORTED);
+		  break;
+	 default:
+		  return entersafe_write_symmetric_key(card,data->key_id,data->usage,
+											   data->key_data.symmetric.EC,
+											   data->key_data.symmetric.ver,
+											   data->key_data.symmetric.key_val,
+											   data->key_data.symmetric.key_len);
+		  break;
+	 }
+	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+}
+
+static int entersafe_gen_key(sc_card_t *card, sc_entersafe_gen_key_data *data)
+{
+		int	r;
+		//size_t len = data->key_length >> 3;
+		sc_apdu_t apdu;
+		u8 rbuf[300];
+		u8 sbuf[8];
+		u8 pubkey_part1_hardcoded[LENGTH_PART1_HARDCODED];
+		u8 pubkey_part1_final[FINAL_PART1];
+		u8 pubkey_part2_hardcoded[LENGTH_PART2_HARDCODED];
+		u8 pubkey_part2_final[FINAL_PART2];
+		u8 privkey_buf[LENGTH_PRIVKEY_HARDCODED];
+		//u8 *p;
+
+		SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+		sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x20,  0x00, 0x81);
+
+		apdu.le     = 0;
+		sbuf[0] 	= 0x31;
+		sbuf[1] 	= 0x31;
+		sbuf[2] 	= 0x32;
+		sbuf[3] 	= 0x32;
+		sbuf[4] 	= 0x33;
+		sbuf[5] 	= 0x33;
+		sbuf[6] 	= 0x34;
+		sbuf[7] 	= 0x34;
+		apdu.data    = sbuf;
+		apdu.lc      = 0x08;
+		apdu.datalen = sizeof(sbuf);
+		apdu.resp    = rbuf;
+		apdu.resplen = 0;
+		r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+
+		/* generate key pair*/
+		sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0x46,  0x00, 0x10);
+
+		apdu.le      = 256;
+		apdu.data    = 0;
+		apdu.lc      = 0;
+		apdu.datalen = 0;
+		apdu.resp    = rbuf;
+		apdu.resplen = sizeof(rbuf);
+
+
+		r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+		LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		LOG_TEST_RET(card->ctx, sc_check_sw(card,apdu.sw1,apdu.sw2),"EnterSafe generate key pair failed");
+
+		/* write public key in 4101 */
+		//Create data to be placed in public key file
+
+		pubkey_part1_hardcoded[0]=0x30;
+		pubkey_part1_hardcoded[1]=0x82;
+		pubkey_part1_hardcoded[2]=0x01;
+		pubkey_part1_hardcoded[3]=0x73;
+		pubkey_part1_hardcoded[4]=0x30;
+		pubkey_part1_hardcoded[5]=0x30;
+		pubkey_part1_hardcoded[6]=0x0C;
+		pubkey_part1_hardcoded[7]=0x00;
+		pubkey_part1_hardcoded[8]=0x03;
+		pubkey_part1_hardcoded[9]=0x02;
+		pubkey_part1_hardcoded[10]=0x06;
+		pubkey_part1_hardcoded[11]=0x40;
+		pubkey_part1_hardcoded[12]=0x30;
+		pubkey_part1_hardcoded[13]=0x28;
+		pubkey_part1_hardcoded[14]=0x30;
+		pubkey_part1_hardcoded[15]=0x06;
+		pubkey_part1_hardcoded[16]=0x03;
+		pubkey_part1_hardcoded[17]=0x02;
+		pubkey_part1_hardcoded[18]=0x07;
+		pubkey_part1_hardcoded[19]=0x80;
+		pubkey_part1_hardcoded[20]=0x05;
+		pubkey_part1_hardcoded[21]=0x00;
+		pubkey_part1_hardcoded[22]=0x30;
+		pubkey_part1_hardcoded[23]=0x0E;
+		pubkey_part1_hardcoded[24]=0x03;
+		pubkey_part1_hardcoded[25]=0x02;
+		pubkey_part1_hardcoded[26]=0x06;
+		pubkey_part1_hardcoded[27]=0x40;
+		pubkey_part1_hardcoded[28]=0x04;
+		pubkey_part1_hardcoded[29]=0x08;
+		pubkey_part1_hardcoded[30]=0x43;
+		pubkey_part1_hardcoded[31]=0x61;
+		pubkey_part1_hardcoded[32]=0x72;
+		pubkey_part1_hardcoded[33]=0x64;
+		pubkey_part1_hardcoded[34]=0x20;
+		pubkey_part1_hardcoded[35]=0x50;
+		pubkey_part1_hardcoded[36]=0x49;
+		pubkey_part1_hardcoded[37]=0x4E;
+		pubkey_part1_hardcoded[38]=0x30;
+		pubkey_part1_hardcoded[39]=0x0E;
+		pubkey_part1_hardcoded[40]=0x03;
+		pubkey_part1_hardcoded[41]=0x02;
+		pubkey_part1_hardcoded[42]=0x04;
+		pubkey_part1_hardcoded[43]=0x10;
+		pubkey_part1_hardcoded[44]=0x04;
+		pubkey_part1_hardcoded[45]=0x08;
+		pubkey_part1_hardcoded[46]=0x43;
+		pubkey_part1_hardcoded[47]=0x61;
+		pubkey_part1_hardcoded[48]=0x72;
+		pubkey_part1_hardcoded[49]=0x64;
+		pubkey_part1_hardcoded[50]=0x20;
+		pubkey_part1_hardcoded[51]=0x50;
+		pubkey_part1_hardcoded[52]=0x49;
+		pubkey_part1_hardcoded[53]=0x4E;
+		pubkey_part1_hardcoded[54]=0x30;
+		pubkey_part1_hardcoded[55]=0x22;
+		pubkey_part1_hardcoded[56]=0x04;
+		pubkey_part1_hardcoded[57]=0x14;
+		pubkey_part1_hardcoded[58]=0x13;
+		pubkey_part1_hardcoded[59]=0xFA;
+		pubkey_part1_hardcoded[60]=0x26;
+		pubkey_part1_hardcoded[61]=0x66;
+		pubkey_part1_hardcoded[62]=0x4C;
+		pubkey_part1_hardcoded[63]=0xEE;
+		pubkey_part1_hardcoded[64]=0xEC;
+		pubkey_part1_hardcoded[65]=0x00;
+		pubkey_part1_hardcoded[66]=0xD6;
+		pubkey_part1_hardcoded[67]=0x00;
+		pubkey_part1_hardcoded[68]=0xCC;
+		pubkey_part1_hardcoded[69]=0x01;
+		pubkey_part1_hardcoded[70]=0xFD;
+		pubkey_part1_hardcoded[71]=0xA6;
+		pubkey_part1_hardcoded[72]=0x57;
+		pubkey_part1_hardcoded[73]=0x4D;
+		pubkey_part1_hardcoded[74]=0x9B;
+		pubkey_part1_hardcoded[75]=0xFB;
+		pubkey_part1_hardcoded[76]=0x11;
+		pubkey_part1_hardcoded[77]=0xE1;
+		pubkey_part1_hardcoded[78]=0x03;
+		pubkey_part1_hardcoded[79]=0x02;
+		pubkey_part1_hardcoded[80]=0x00;
+		pubkey_part1_hardcoded[81]=0x8B;
+		pubkey_part1_hardcoded[82]=0x03;
+		pubkey_part1_hardcoded[83]=0x02;
+		pubkey_part1_hardcoded[84]=0x03;
+		pubkey_part1_hardcoded[85]=0x48;
+		pubkey_part1_hardcoded[86]=0x02;
+		pubkey_part1_hardcoded[87]=0x02;
+		pubkey_part1_hardcoded[88]=0x00;
+		pubkey_part1_hardcoded[89]=0x90;
+		pubkey_part1_hardcoded[90]=0xA1;
+		pubkey_part1_hardcoded[91]=0x82;
+		pubkey_part1_hardcoded[92]=0x01;
+		pubkey_part1_hardcoded[93]=0x19;
+		pubkey_part1_hardcoded[94]=0x30;
+		pubkey_part1_hardcoded[95]=0x82;
+		pubkey_part1_hardcoded[96]=0x01;
+		pubkey_part1_hardcoded[97]=0x15;
+		pubkey_part1_hardcoded[98]=0xA0;
+		pubkey_part1_hardcoded[99]=0x82;
+		pubkey_part1_hardcoded[100]=0x01;
+		pubkey_part1_hardcoded[101]=0x0D;
+		pubkey_part1_hardcoded[102]=0x30;
+		pubkey_part1_hardcoded[103]=0x82;
+		pubkey_part1_hardcoded[104]=0x01;
+		pubkey_part1_hardcoded[105]=0x09;
+		pubkey_part1_hardcoded[106]=0x02;
+		pubkey_part1_hardcoded[107]=0x82;
+		pubkey_part1_hardcoded[108]=0x01;
+		pubkey_part1_hardcoded[109]=0x00;
+
+		//020301000102020800FF
+		pubkey_part2_hardcoded[0]=0x02;
+		pubkey_part2_hardcoded[1]=0x03;
+		pubkey_part2_hardcoded[2]=0x01;
+		pubkey_part2_hardcoded[3]=0x00;
+		pubkey_part2_hardcoded[4]=0x01;
+		pubkey_part2_hardcoded[5]=0x02;
+		pubkey_part2_hardcoded[6]=0x02;
+		pubkey_part2_hardcoded[7]=0x08;
+		pubkey_part2_hardcoded[8]=0x00;
+		pubkey_part2_hardcoded[9]=0xFF;
+
+		memcpy(pubkey_part1_final,pubkey_part1_hardcoded,LENGTH_PART1_HARDCODED);
+		memcpy(pubkey_part1_final+LENGTH_PART1_HARDCODED,rbuf,LENGTH_PART1_FROM_PUBKEY);
+		sc_apdu_log(card->ctx, pubkey_part1_final, sizeof(pubkey_part1_final), 0);
+
+		memcpy(pubkey_part2_final,(rbuf+LENGTH_PART1_FROM_PUBKEY),LENGTH_PART2_FROM_PUBKEY);
+		memcpy(pubkey_part2_final+LENGTH_PART2_FROM_PUBKEY,pubkey_part2_hardcoded,10);
+		sc_apdu_log(card->ctx, pubkey_part2_final, sizeof(pubkey_part2_final), 0);
+
+		//Select Public Key File
+		sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4,  0x00, 0x00);
+
+		apdu.le      = 0;
+		sbuf[0] 	= 0x41;
+		sbuf[1] 	= 0x01;
+		apdu.data    = sbuf;
+		apdu.lc      = 2;
+		apdu.datalen = 2;
+		apdu.resp    = rbuf;
+		apdu.resplen = sizeof(rbuf);
+
+		r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+		LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		LOG_TEST_RET(card->ctx, sc_check_sw(card,apdu.sw1,apdu.sw2),"FAILED TO SELECT public KEY FILE");
+
+		//ADDING 255 BYTES
+
+		sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xD6,  0x00, 0x00);
+		apdu.le     = 0;
+		apdu.data    = pubkey_part1_final;
+		apdu.lc      = 0xE6;
+		apdu.datalen = sizeof(pubkey_part1_final);
+		apdu.resp    = rbuf;
+		apdu.resplen = 0;
+		r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+
+		//ADDING LAST BYTE
+
+		sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xD6,  0x00, 0xE6);
+		apdu.le     = 0;
+		apdu.data    = pubkey_part2_final;
+		apdu.lc      = 0x92;
+		apdu.datalen = sizeof(pubkey_part2_final);
+		apdu.resp    = rbuf;
+		apdu.resplen = 0;
+		r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+
+		/* write private key in 4100 */
+		//Select Private Key file
+		sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4,  0x00, 0x00);
+
+		apdu.le      = 0;
+		sbuf[0] 	= 0x41;
+		sbuf[1] 	= 0x00;
+		apdu.data    = sbuf;
+		apdu.lc      = 2;
+		apdu.datalen = 2;
+		apdu.resp    = rbuf;
+		apdu.resplen = sizeof(rbuf);
+
+
+		r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+		LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		LOG_TEST_RET(card->ctx, sc_check_sw(card,apdu.sw1,apdu.sw2),"FAILED TO SELECT PRIVATE KEY FILE");
+
+		//ASSOCIATE PRIVATE KEY FILE WITH PRIVATE KEY DATA @ KEY ID 10
+		/*sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xD6,  0x00, 0x69);
+
+		apdu.le      	= 0;
+		sbuf[0] 		= 0x10; //key id
+		apdu.data    	= sbuf;
+		apdu.lc      	= 1;
+		apdu.datalen 	= 1;
+		apdu.resp    	= rbuf;
+		apdu.resplen 	= sizeof(rbuf);
+
+		r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+		LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		LOG_TEST_RET(card->ctx, sc_check_sw(card,apdu.sw1,apdu.sw2),"FAILED TO PLACE PRIVATE KEY INSIDE CONTAINER");
+		*/
+		//00D6000077
+		//307430420C00030206C00408436172642050494E3030300E030205200408436172642050494E300E030206400408436172642050494E300E030204100408436172642050494E3022041413FA26664CEEEC00D600CC01FDA6574D9BFB11E103020274030203B802020010A10A30083002040002020800FF
+
+		privkey_buf[0]=0x30;
+		privkey_buf[1]=0x74;
+		privkey_buf[2]=0x30;
+		privkey_buf[3]=0x42;
+		privkey_buf[4]=0x0C;
+		privkey_buf[5]=0x00;
+		privkey_buf[6]=0x03;
+		privkey_buf[7]=0x02;
+		privkey_buf[8]=0x06;
+		privkey_buf[9]=0xC0;
+		privkey_buf[10]=0x04;
+		privkey_buf[11]=0x08;
+		privkey_buf[12]=0x43;
+		privkey_buf[13]=0x61;
+		privkey_buf[14]=0x72;
+		privkey_buf[15]=0x64;
+		privkey_buf[16]=0x20;
+		privkey_buf[17]=0x50;
+		privkey_buf[18]=0x49;
+		privkey_buf[19]=0x4E;
+		privkey_buf[20]=0x30;
+		privkey_buf[21]=0x30;
+		privkey_buf[22]=0x30;
+		privkey_buf[23]=0x0E;
+		privkey_buf[24]=0x03;
+		privkey_buf[25]=0x02;
+		privkey_buf[26]=0x05;
+		privkey_buf[27]=0x20;
+		privkey_buf[28]=0x04;
+		privkey_buf[29]=0x08;
+		privkey_buf[30]=0x43;
+		privkey_buf[31]=0x61;
+		privkey_buf[32]=0x72;
+		privkey_buf[33]=0x64;
+		privkey_buf[34]=0x20;
+		privkey_buf[35]=0x50;
+		privkey_buf[36]=0x49;
+		privkey_buf[37]=0x4E;
+		privkey_buf[38]=0x30;
+		privkey_buf[38]=0x0E;
+		privkey_buf[40]=0x03;
+		privkey_buf[41]=0x02;
+		privkey_buf[42]=0x06;
+		privkey_buf[43]=0x40;
+		privkey_buf[44]=0x04;
+		privkey_buf[45]=0x08;
+		privkey_buf[46]=0x43;
+		privkey_buf[47]=0x61;
+		privkey_buf[48]=0x72;
+		privkey_buf[49]=0x64;
+		privkey_buf[50]=0x20;
+		privkey_buf[51]=0x50;
+		privkey_buf[52]=0x49;
+		privkey_buf[53]=0x4E;
+		privkey_buf[54]=0x30;
+		privkey_buf[55]=0x0E;
+		privkey_buf[56]=0x03;
+		privkey_buf[57]=0x02;
+		privkey_buf[58]=0x04;
+		privkey_buf[59]=0x10;
+		privkey_buf[60]=0x04;
+		privkey_buf[61]=0x08;
+		privkey_buf[62]=0x43;
+		privkey_buf[63]=0x61;
+		privkey_buf[64]=0x72;
+		privkey_buf[65]=0x64;
+		privkey_buf[66]=0x20;
+		privkey_buf[67]=0x50;
+		privkey_buf[68]=0x49;
+		privkey_buf[69]=0x4E;
+		privkey_buf[70]=0x30;
+		privkey_buf[71]=0x22;
+		privkey_buf[72]=0x04;
+		privkey_buf[73]=0x14;
+		privkey_buf[74]=0x13;
+		privkey_buf[75]=0xFA;
+		privkey_buf[76]=0x26;
+		privkey_buf[77]=0x66;
+		privkey_buf[78]=0x4C;
+		privkey_buf[79]=0xEE;
+		privkey_buf[80]=0xEC;
+		privkey_buf[81]=0x00;
+		privkey_buf[82]=0xD6;
+		privkey_buf[83]=0x00;
+		privkey_buf[84]=0xCC;
+		privkey_buf[85]=0x01;
+		privkey_buf[86]=0xFD;
+		privkey_buf[87]=0xA6;
+		privkey_buf[88]=0x57;
+		privkey_buf[89]=0x4D;
+		privkey_buf[90]=0x9B;
+		privkey_buf[91]=0xFB;
+		privkey_buf[92]=0x11;
+		privkey_buf[93]=0xE1;
+		privkey_buf[94]=0x03;
+		privkey_buf[95]=0x02;
+		privkey_buf[96]=0x02;
+		privkey_buf[97]=0x74;
+		privkey_buf[98]=0x03;
+		privkey_buf[99]=0x02;
+		privkey_buf[100]=0x03;
+		privkey_buf[101]=0xB8;
+		privkey_buf[102]=0x02;
+		privkey_buf[103]=0x02;
+		privkey_buf[104]=0x00;
+		privkey_buf[105]=0x10;
+		privkey_buf[106]=0xA1;
+		privkey_buf[107]=0x0A;
+		privkey_buf[108]=0x30;
+		privkey_buf[109]=0x08;
+		privkey_buf[110]=0x30;
+		privkey_buf[111]=0x02;
+		privkey_buf[112]=0x04;
+		privkey_buf[113]=0x00;
+		privkey_buf[114]=0x02;
+		privkey_buf[115]=0x02;
+		privkey_buf[116]=0x08;
+		privkey_buf[117]=0x00;
+		privkey_buf[118]=0xFF;
+
+		sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xD6,  0x00, 0x00);
+
+		apdu.le      	= 0;
+		apdu.data    	= privkey_buf;
+		apdu.lc      	= 0x77;
+		apdu.datalen 	= sizeof(privkey_buf);
+		apdu.resp    	= rbuf;
+		apdu.resplen 	= sizeof(rbuf);
+
+		r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+		LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+		LOG_TEST_RET(card->ctx, sc_check_sw(card,apdu.sw1,apdu.sw2),"FAILED TO PLACE PRIVATE KEY INSIDE CONTAINER");
+
+
+
+		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+}
+
+static int entersafe_get_serialnr(sc_card_t *card, sc_serial_number_t *serial)
+{
+	int	r;
+	sc_apdu_t apdu;
+	u8 rbuf[SC_MAX_APDU_BUFFER_SIZE];
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+	assert(serial);
+
+	sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT,0xEA,0x00,0x00);
+	apdu.cla=0x80;
+	apdu.resp=rbuf;
+	apdu.resplen=sizeof(rbuf);
+	apdu.le=0x08;
+
+	r=entersafe_transmit_apdu(card, &apdu,0,0,0,0);
+	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
+	LOG_TEST_RET(card->ctx, sc_check_sw(card,apdu.sw1,apdu.sw2),"EnterSafe get SN failed");
+
+	card->serialnr.len=serial->len=8;
+	memcpy(card->serialnr.value,rbuf,8);
+	memcpy(serial->value,rbuf,8);
+
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+}
+
+static int entersafe_preinstall_rsa_2048(sc_card_t *card,u8 key_id)
+{
+	u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
+	sc_apdu_t apdu;
+	int ret=0;
+	static u8 const rsa_key_e[] =
+	{
+		'E', 0x04, 0x01, 0x00, 0x01, 0x00
+	};
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	/*  create rsa item in IKF */
+	sbuf[0] = 0x04; /* key len extern */
+	sbuf[1] = 0x0a; /* key len */
+	sbuf[2] = 0x22;	/* USAGE */
+	sbuf[3] = 0x34;	/* user ac */
+	sbuf[4] = 0x04;	/* change ac */
+	sbuf[5] = 0x34;	/* UPDATE AC */
+	sbuf[6] = 0x40;	/* ALGO */
+	sbuf[7] = 0x00;	/* EC */
+	sbuf[8] = 0x00;	/* VER */
+	memcpy(&sbuf[9], rsa_key_e, sizeof(rsa_key_e));
+	sbuf[9 + sizeof(rsa_key_e) + 0] = 'C'+'R'+'T';
+	sbuf[9 + sizeof(rsa_key_e) + 1] = 0x82;
+	sbuf[9 + sizeof(rsa_key_e) + 2] = 0x04;
+	sbuf[9 + sizeof(rsa_key_e) + 3] = 0x00;
+
+	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT,0xF0,0x00,key_id);
+	apdu.cla=0x84;
+	apdu.data=sbuf;
+	apdu.lc=apdu.datalen=9 + sizeof(rsa_key_e) + 4;
+
+	ret = entersafe_transmit_apdu(card,&apdu,init_key,sizeof(init_key),0,1);
+	LOG_TEST_RET(card->ctx, ret, "Preinstall rsa failed");
+
+	/*  create rsa item in PKF */
+	sbuf[0] = 0x01;	/* key len extern */
+	sbuf[1] = 0x0A;	/* key len */
+	sbuf[2] = 0x2A;	/* USAGE */
+	sbuf[3] = ENTERSAFE_AC_ALWAYS;	/* user ac */
+	sbuf[4] = 0x04;	/* change ac */
+	sbuf[5] = ENTERSAFE_AC_ALWAYS;	/* UPDATE AC */
+	sbuf[6] = 0x40;	/* ALGO */
+	sbuf[7] = 0x00;	/* EC */
+	sbuf[8] = 0x00;	/* VER */
+	memcpy(&sbuf[9], rsa_key_e, sizeof(rsa_key_e));		
+	sbuf[9 + sizeof(rsa_key_e) + 0] = 'N';
+	sbuf[9 + sizeof(rsa_key_e) + 1] = 0x82;
+	sbuf[9 + sizeof(rsa_key_e) + 2] = 0x01;
+	sbuf[9 + sizeof(rsa_key_e) + 3] = 0x00;
+
+	sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF0,0x00,key_id);
+	apdu.cla=0x84;
+	apdu.data=sbuf;
+	apdu.lc=apdu.datalen=9 + sizeof(rsa_key_e) + 4;
+
+	ret=entersafe_transmit_apdu(card,&apdu,init_key,sizeof(init_key),0,1);
+	LOG_TEST_RET(card->ctx, ret, "Preinstall rsa failed");
+
+	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+}
+
+static int entersafe_preinstall_keys(sc_card_t *card,int (*install_rsa)(sc_card_t *,u8))
+{
+	 int r;
+	 u8 sbuf[SC_MAX_APDU_BUFFER_SIZE];
+	 sc_apdu_t apdu;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	 {/* RSA */
+		  u8 rsa_index;
+		  for(rsa_index=ENTERSAFE_MIN_KEY_ID;
+			  rsa_index<=ENTERSAFE_MAX_KEY_ID;
+			  ++rsa_index)
+		  {
+			   r=install_rsa(card,rsa_index);
+			   LOG_TEST_RET(card->ctx, r, "Preinstall rsa key failed");
+		  }
+	 }
+
+	 {/* key maintain */
+		  /* create key maintain*/
+		  sbuf[0] = 0;	/* key len extern */
+		  sbuf[1] = sizeof(key_maintain);	/* key len */
+		  sbuf[2] = 0x03;	/* USAGE */
+		  sbuf[3] = ENTERSAFE_AC_ALWAYS;	/* use AC	*/
+		  sbuf[4] = ENTERSAFE_AC_ALWAYS;	/* CHANGE AC */
+		  sbuf[5] = ENTERSAFE_AC_NEVER;	/* UPDATE AC */
+		  sbuf[6] = 0x01;	/* ALGO */
+		  sbuf[7] = 0x00;	/* EC */
+		  sbuf[8] = 0x00;	/* VER */
+		  memcpy(&sbuf[9], key_maintain, sizeof(key_maintain));
+
+		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF0,0x00,0x00);
+		  apdu.cla=0x84;
+		  apdu.data=sbuf;
+		  apdu.lc=apdu.datalen=0x19;
+
+		  r = entersafe_transmit_apdu(card,&apdu,init_key,sizeof(init_key),0,1);
+		  LOG_TEST_RET(card->ctx, r, "Preinstall key maintain failed");
+	 }
+
+	 {/* user PIN */
+		  memset(sbuf,0,sizeof(sbuf));
+		  sbuf[0] = 0;	/* key len extern */
+		  sbuf[1] = 16;	/* key len */
+		  sbuf[2] = 0x0B;	/* USAGE */
+		  sbuf[3] = ENTERSAFE_AC_ALWAYS;	/* use AC */
+		  sbuf[4] = 0X04;	/* CHANGE AC */
+		  sbuf[5] = 0x38;	/* UPDATE AC */
+		  sbuf[6] = 0x01;	/* ALGO */
+		  sbuf[7] = 0xFF;	/* EC */
+		  sbuf[8] = 0x00;	/* VER */
+
+		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF0,0x00,ENTERSAFE_USER_PIN_ID);
+		  apdu.cla=0x84;
+		  apdu.data=sbuf;
+		  apdu.lc=apdu.datalen=0x19;
+
+		  r = entersafe_transmit_apdu(card,&apdu,init_key,sizeof(init_key),0,1);
+		  LOG_TEST_RET(card->ctx, r, "Preinstall user PIN failed");
+	 }
+
+	 {/* user PUK */
+		  memset(sbuf,0,sizeof(sbuf));
+		  sbuf[0] = 0;	/* key len extern */
+		  sbuf[1] = 16;	/* key len */
+		  sbuf[2] = 0x0B;	/* USAGE */
+		  sbuf[3] = ENTERSAFE_AC_ALWAYS;	/* use AC */
+		  sbuf[4] = 0X08;	/* CHANGE AC */
+		  sbuf[5] = 0xC0;	/* UPDATE AC */
+		  sbuf[6] = 0x01;	/* ALGO */
+		  sbuf[7] = 0xFF;	/* EC */
+		  sbuf[8] = 0x00;	/* VER */
+
+		  sc_format_apdu(card,&apdu,SC_APDU_CASE_3_SHORT,0xF0,0x00,ENTERSAFE_USER_PIN_ID+1);
+		  apdu.cla=0x84;
+		  apdu.data=sbuf;
+		  apdu.lc=apdu.datalen=0x19;
+
+		  r = entersafe_transmit_apdu(card,&apdu,init_key,sizeof(init_key),0,1);
+		  LOG_TEST_RET(card->ctx, r, "Preinstall user PUK failed");
+	 }
+
+
+	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,SC_SUCCESS);
+}
+
+static int entersafe_card_ctl_2048(sc_card_t *card, unsigned long cmd, void *ptr)
+{
+	sc_entersafe_create_data *tmp = (sc_entersafe_create_data *)ptr;
+
+	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
+
+	switch (cmd)
+	{
+	case SC_CARDCTL_ENTERSAFE_CREATE_FILE:
+		if (tmp->type == SC_ENTERSAFE_MF_DATA)
+			return entersafe_create_mf(card, tmp);
+		else if (tmp->type == SC_ENTERSAFE_DF_DATA)
+			return entersafe_create_df(card, tmp);
+		else if (tmp->type == SC_ENTERSAFE_EF_DATA)
+			return entersafe_create_ef(card, tmp);
+		else
+			return SC_ERROR_INTERNAL;
+	case SC_CARDCTL_ENTERSAFE_WRITE_KEY:
+		return entersafe_write_key(card, (sc_entersafe_wkey_data *)ptr);
+	case SC_CARDCTL_ENTERSAFE_GENERATE_KEY:
+		return entersafe_gen_key(card, (sc_entersafe_gen_key_data *)ptr);
+	case SC_CARDCTL_ERASE_CARD:
+		return entersafe_erase_card(card);
+	case SC_CARDCTL_GET_SERIALNR:
+		return entersafe_get_serialnr(card, (sc_serial_number_t *)ptr);
+	case SC_CARDCTL_ENTERSAFE_PREINSTALL_KEYS:
+		 return entersafe_preinstall_keys(card,entersafe_preinstall_rsa_2048);
+	default:
+		return SC_ERROR_NOT_SUPPORTED;
+	}
+}
+
+static struct sc_card_driver * sc_get_driver(void)
+{
+	struct sc_card_driver *iso_drv = sc_get_iso7816_driver();
+
+	if (iso_ops == NULL)
+		iso_ops = iso_drv->ops;
+  
+	entersafe_ops = *iso_drv->ops;
+	entersafe_ops.match_card = entersafe_match_card;
+	entersafe_ops.init   = entersafe_init;
+	entersafe_ops.read_binary = entersafe_read_binary;
+	entersafe_ops.write_binary = NULL;
+	entersafe_ops.update_binary = entersafe_update_binary;
+	entersafe_ops.select_file = entersafe_select_file;
+	entersafe_ops.restore_security_env = entersafe_restore_security_env;
+	entersafe_ops.set_security_env  = entersafe_set_security_env;
+	entersafe_ops.decipher = entersafe_decipher;
+	entersafe_ops.compute_signature = entersafe_compute_signature;
+	entersafe_ops.create_file = entersafe_create_file;
+	entersafe_ops.delete_file = NULL;
+	entersafe_ops.pin_cmd = entersafe_pin_cmd;
+	entersafe_ops.card_ctl    = entersafe_card_ctl_2048;
+	entersafe_ops.process_fci = entersafe_process_fci;
+	return &entersafe_drv;
+}
+
+struct sc_card_driver * sc_get_entersafe_driver(void)
+{
+	return sc_get_driver();
+}
+#endif
diff --git a/src/libopensc/ctx.c b/src/libopensc/ctx.c
index 8afd4633..ded3637a 100644
--- a/src/libopensc/ctx.c
+++ b/src/libopensc/ctx.c
@@ -105,7 +105,7 @@ static const struct _sc_driver_entry internal_card_drivers[] = {
 	/* The card handled by skeid shares the ATR with other cards running CardOS 5.4.
 	 * In order to prevent the cardos driver from matching skeid cards, skeid driver
 	 * precedes cardos and matches no other CardOS 5.4 card. */
-	{ "skeid",	(void *(*)(void)) sc_get_skeid_driver },
+	/*{ "skeid",	(void *(*)(void)) sc_get_skeid_driver },
 	{ "cardos",	(void *(*)(void)) sc_get_cardos_driver },
 	{ "cyberflex",	(void *(*)(void)) sc_get_cyberflex_driver },
 	{ "gemsafeV1",	(void *(*)(void)) sc_get_gemsafeV1_driver },
@@ -116,7 +116,7 @@ static const struct _sc_driver_entry internal_card_drivers[] = {
 	{ "authentic",	(void *(*)(void)) sc_get_authentic_driver },
 	{ "iasecc",	(void *(*)(void)) sc_get_iasecc_driver },
 #endif
-	{ "belpic",	(void *(*)(void)) sc_get_belpic_driver },
+	{ "belpic",	(void *(*)(void)) sc_get_belpic_driver },*/
 #ifdef ENABLE_OPENSSL
 	{ "entersafe",(void *(*)(void)) sc_get_entersafe_driver },
 #ifdef ENABLE_SM
diff --git a/src/libopensc/iso7816.c b/src/libopensc/iso7816.c
index 1e3bd3ba..d111f450 100644
--- a/src/libopensc/iso7816.c
+++ b/src/libopensc/iso7816.c
@@ -709,6 +709,22 @@ iso7816_select_file(struct sc_card *card, const struct sc_path *in_path, struct
 	apdu.lc = pathlen;
 	apdu.data = path;
 	apdu.datalen = pathlen;
+	//if (apdu.data[0]==0x2A && apdu.data[1]==0xDF)
+
+	if ((pathlen >= 2) && (pathlen <= 4) && memcmp(path, "\x2A\xDF", 2) == 0) {
+		apdu.p1 = 1;
+		sc_debug_hex(ctx, SC_LOG_DEBUG_NORMAL, "NEEL APDU - DATA FINAL", apdu.data, apdu.datalen);
+	}
+
+	/*
+	if (strstr((const char *)path, "2ADF") != NULL) {
+		sc_debug_hex(ctx, SC_LOG_DEBUG_NORMAL, "NEEL APDU - DATA 0", apdu.data, apdu.datalen);
+	}
+	else
+	{
+		sc_debug_hex(ctx, SC_LOG_DEBUG_NORMAL, "NEEL APDU - DATA NOT FOUND", apdu.data, apdu.datalen);
+	}
+	*/
 
 	if (file_out != NULL) {
 		apdu.p2 = 0;		/* first record, return FCI */
diff --git a/src/libopensc/pkcs15-sec.c b/src/libopensc/pkcs15-sec.c
index 7c3a3943..7c058376 100644
--- a/src/libopensc/pkcs15-sec.c
+++ b/src/libopensc/pkcs15-sec.c
@@ -73,7 +73,6 @@ static int get_file_path(const struct sc_pkcs15_object* obj, sc_path_t* path)
 	return SC_SUCCESS;
 }
 
-
 static int select_key_file(struct sc_pkcs15_card *p15card,
 		const struct sc_pkcs15_object *key,
 		sc_security_env_t *senv)
@@ -81,7 +80,26 @@ static int select_key_file(struct sc_pkcs15_card *p15card,
 	sc_context_t *ctx = p15card->card->ctx;
 	sc_path_t orig_path;
 	sc_path_t path, file_id;
+	sc_apdu_t apdu;
+	u8 sbuf[4];
+
 	int r;
+	//send 002281B60491020A10
+	/* MSE */
+	sc_format_apdu(p15card->card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x81, 0xB6);
+	apdu.lc=0x04;
+	sbuf[0]=0x91;
+	sbuf[1]=0x02;
+	sbuf[2]=0x0a;
+	sbuf[3]=0x11;
+	apdu.data = sbuf;
+	apdu.datalen=4;
+	apdu.lc=4;
+	apdu.le=0;
+
+	r = sc_transmit_apdu(p15card->card,&apdu);
+	LOG_TEST_RET(ctx, r, "APDU transmit failed");
+	LOG_TEST_RET(ctx, sc_check_sw(p15card->card,apdu.sw1,apdu.sw2),"EnterSafe set MSE failed");
 
 	LOG_FUNC_CALLED(ctx);
 
@@ -136,11 +154,18 @@ static int use_key(struct sc_pkcs15_card *p15card,
 	sc_path_t path;
 	LOG_TEST_RET(p15card->card->ctx, get_file_path(obj, &path), "Failed to get key file path.");
 
+	char pbuf[SC_MAX_PATH_STRING_SIZE];// added by neel
+
 	r = sc_lock(p15card->card);
 	LOG_TEST_RET(p15card->card->ctx, r, "sc_lock() failed");
 
+	sc_path_print(pbuf, sizeof(pbuf), &path);
+	sc_log(p15card->card->ctx, "path - Neel=%s", pbuf);
+
+
 	do {
 		if (path.len != 0 || path.aid.len != 0) {
+			sc_log(p15card->card->ctx, "path - length - Neel=%s", pbuf);
 			r = select_key_file(p15card, obj, senv);
 			if (r < 0) {
 				sc_log(p15card->card->ctx,
diff --git a/src/libopensc/reader-pcsc.c b/src/libopensc/reader-pcsc.c
index d2dac438..dfad3175 100644
--- a/src/libopensc/reader-pcsc.c
+++ b/src/libopensc/reader-pcsc.c
@@ -325,6 +325,9 @@ static int pcsc_transmit(sc_reader_t *reader, sc_apdu_t *apdu)
 		sc_log(reader->ctx, "reader '%s'", reader->name);
 	sc_apdu_log(reader->ctx, sbuf, ssize, 1);
 
+	sc_debug_hex(reader->ctx, SC_LOG_DEBUG_NORMAL, "NEEL APDU - SBUF", sbuf, ssize);
+
+
 	r = pcsc_internal_transmit(reader, sbuf, ssize,
 				rbuf, &rsize, apdu->control);
 	if (r < 0) {
diff --git a/src/pkcs15init/pkcs15-lib.c b/src/pkcs15init/pkcs15-lib.c
index 9148b83b..42180877 100644
--- a/src/pkcs15init/pkcs15-lib.c
+++ b/src/pkcs15init/pkcs15-lib.c
@@ -68,13 +68,13 @@
 #include "pkcs15-init.h"
 #include "pkcs11/pkcs11.h"
 
-#define OPENSC_INFO_FILEPATH		"3F0050154946"
-#define OPENSC_INFO_FILEID		0x4946
+#define OPENSC_INFO_FILEPATH		"3F002ADF5032"
+#define OPENSC_INFO_FILEID		0x5032
 #define OPENSC_INFO_TAG_PROFILE		0x01
 #define OPENSC_INFO_TAG_OPTION		0x02
 
 /* Default ID for new key/pin */
-#define DEFAULT_ID			0x45
+#define DEFAULT_ID			0x81
 #define DEFAULT_PIN_FLAGS		(SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE)
 #define DEFAULT_PRKEY_FLAGS		(SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE)
 #define DEFAULT_PUBKEY_FLAGS		(SC_PKCS15_CO_FLAG_MODIFIABLE)
@@ -4016,6 +4016,8 @@ sc_pkcs15init_authenticate(struct sc_profile *profile, struct sc_pkcs15_card *p1
 		LOG_FUNC_RETURN(ctx, r);
 	}
 
+	//p15card->card->caps |=  SC_CARD_CAP_USE_FCI_AC; // added by neel
+
 	if (p15card->card->caps & SC_CARD_CAP_USE_FCI_AC) {
 		r = sc_select_file(p15card->card, &file->path, &file_tmp);
 		LOG_TEST_RET(ctx, r, "Authentication failed: cannot select file.");
diff --git a/src/pkcs15init/pkcs15.profile b/src/pkcs15init/pkcs15.profile
index b1994380..b1c73b1d 100644
--- a/src/pkcs15init/pkcs15.profile
+++ b/src/pkcs15init/pkcs15.profile
@@ -1,189 +1,189 @@
-#
-# PKCS15 profile, generic information.
-# This profile is loaded before any card specific profile.
-#
-
-cardinfo {
-    label		= "OpenSC Card";
-    manufacturer	= "OpenSC Project";
-    min-pin-length	= 4;
-    # max length should be overridden in the per-card profile
-    max-pin-length	= 8;
-}
-
-#
-# The following controls some aspects of the PKCS15 we put onto
-# the card.
-#
-pkcs15 {
-    # Put certificates into the CDF itself?
-    direct-certificates	= no;
-    # Put the DF length into the ODF file?
-    encode-df-length	= no;
-    # Have a lastUpdate field in the EF(TokenInfo)?
-    do-last-update	= yes;
-    # Method to calculate ID of the crypto objects
-    #     native: 'E' + number_of_present_objects_of_the_same_type
-    #     mozilla: SHA1(modulus) for RSA
-    #     rfc2459: SHA1(SequenceASN1 of public key components as ASN1 integers)
-    # default value: 'native'
-    pkcs15-id-style	= mozilla;
-}
-
-# Default settings.
-# This option block will always be processed.
-option default {
-    macros {
-        protected	= *=$SOPIN, READ=NONE;
-        unprotected	= *=NONE;
-	so-pin-flags	= local, initialized, needs-padding, soPin;
-	so-min-pin-length = 6;
-	so-pin-attempts	= 2;
-	so-auth-id	= FF;
-	so-puk-attempts	= 4;
-	so-min-puk-length = 6;
-	unusedspace-size = 128;
-	odf-size	= 256;
-	aodf-size	= 256;
-	cdf-size	= 512;
-	prkdf-size	= 256;
-	pukdf-size	= 256;
-	dodf-size	= 256;
-    }
-}
-
-# This option sets up the card so that a single
-# user PIN protects all files
-option onepin {
-    macros {
-        protected	= *=$PIN, READ=NONE;
-        unprotected	= *=NONE;
-	so-pin-flags	= local, initialized, needs-padding;
-	so-min-pin-length = 4;
-	so-pin-attempts	= 3;
-	so-auth-id	= 1;
-	so-puk-attempts	= 7;
-	so-min-puk-length = 4;
-    }
-}
-
-# This option is for cards with very little memory.
-# It sets the size of various PKCS15 directory files
-# to 128 or 256, respectively.
-option small {
-    macros {
-	odf-size	= 128;
-	aodf-size	= 128;
-	cdf-size	= 256;
-	prkdf-size	= 128;
-	pukdf-size	= 128;
-	dodf-size	= 128;
-    }
-}
-
-# This option tells pkcs15-init to use the direct option
-# when storing certificates on the card (i.e. put the
-# certificates into the CDF itself, rather than a
-# separate file)
-option direct-cert {
-    pkcs15 {
-        direct-certificates	= yes;
-	encode-df-length	= yes;
-    }
-    macros {
-	cdf-size	= 3192;
-    }
-}
-
-# Define reasonable limits for PINs and PUK
-# Note that we do not set a file path or reference
-# for the user pin; that is done dynamically.
-PIN user-pin {
-    attempts	= 3;
-    flags	= local, initialized, needs-padding;
-}
-PIN user-puk {
-    attempts	= 7;
-}
-PIN so-pin {
-    auth-id	= $so-auth-id;
-    attempts	= $so-pin-attempts;
-    min-length	= $so-min-pin-length;
-    flags	= $so-pin-flags;
-}
-PIN so-puk {
-    attempts	= $so-puk-attempts;
-    min-length	= $so-min-puk-length;
-}
-
-filesystem {
-    DF MF {
-        path	= 3F00;
-        type	= DF;
-
-	# This is the DIR file
-	EF DIR {
-	    type	= EF;
-	    file-id	= 2F00;
-	    size	= 128;
-	    acl		= *=NONE;
-	}
-
-	# Here comes the application DF
-	DF PKCS15-AppDF {
-	    type	= DF;
-	    file-id	= 5015;
-	    aid		= A0:00:00:00:63:50:4B:43:53:2D:31:35;
-	    acl		= *=NONE;
-	    size	= 5000;
-
-	    EF PKCS15-ODF {
-	        file-id		= 5031;
-		size		= $odf-size;
-		ACL		= $unprotected;
-	    }
-
-	    EF PKCS15-TokenInfo {
-		file-id		= 5032;
-		ACL		= $unprotected;
-	    }
-
-	    EF PKCS15-UnusedSpace {
-		file-id		= 5033;
-		size		= $unusedspace-size;
-		ACL		= $unprotected;
-	    }
-
-	    EF PKCS15-AODF {
-	        file-id		= 4401;
-		size		= $aodf-size;
-		ACL		= $protected;
-	    }
-
-	    EF PKCS15-PrKDF {
-	        file-id		= 4402;
-		size		= $prkdf-size;
-		acl		= $protected;
-	    }
-
-	    EF PKCS15-PuKDF {
-	        file-id		= 4403;
-		size		= $pukdf-size;
-		acl		= $protected;
-	    }
-
-	    EF PKCS15-CDF {
-	        file-id		= 4404;
-		size		= $cdf-size;
-		acl		= $protected;
-	    }
-
-	    EF PKCS15-DODF {
-	        file-id		= 4405;
-		size		= $dodf-size;
-		ACL		= $protected;
-	    }
-
-	}
-    }
-}
+#
+# PKCS15 profile, generic information.
+# This profile is loaded before any card specific profile.
+#
+
+cardinfo {
+    label		= "OpenSC Card";
+    manufacturer	= "OpenSC Project";
+    min-pin-length	= 4;
+    # max length should be overridden in the per-card profile
+    max-pin-length	= 8;
+}
+
+#
+# The following controls some aspects of the PKCS15 we put onto
+# the card.
+#
+pkcs15 {
+    # Put certificates into the CDF itself?
+    direct-certificates	= no;
+    # Put the DF length into the ODF file?
+    encode-df-length	= no;
+    # Have a lastUpdate field in the EF(TokenInfo)?
+    do-last-update	= yes;
+    # Method to calculate ID of the crypto objects
+    #     native: 'E' + number_of_present_objects_of_the_same_type
+    #     mozilla: SHA1(modulus) for RSA
+    #     rfc2459: SHA1(SequenceASN1 of public key components as ASN1 integers)
+    # default value: 'native'
+    pkcs15-id-style	= mozilla;
+}
+
+# Default settings.
+# This option block will always be processed.
+option default {
+    macros {
+        protected	= *=$SOPIN, READ=NONE;
+        unprotected	= *=NONE;
+	so-pin-flags	= local, initialized, needs-padding, soPin;
+	so-min-pin-length = 6;
+	so-pin-attempts	= 2;
+	so-auth-id	= FF;
+	so-puk-attempts	= 4;
+	so-min-puk-length = 6;
+	unusedspace-size = 128;
+	odf-size	= 256;
+	aodf-size	= 256;
+	cdf-size	= 512;
+	prkdf-size	= 256;
+	pukdf-size	= 256;
+	dodf-size	= 256;
+    }
+}
+
+# This option sets up the card so that a single
+# user PIN protects all files
+option onepin {
+    macros {
+        protected	= *=$PIN, READ=NONE;
+        unprotected	= *=NONE;
+	so-pin-flags	= local, initialized, needs-padding;
+	so-min-pin-length = 4;
+	so-pin-attempts	= 3;
+	so-auth-id	= 1;
+	so-puk-attempts	= 7;
+	so-min-puk-length = 4;
+    }
+}
+
+# This option is for cards with very little memory.
+# It sets the size of various PKCS15 directory files
+# to 128 or 256, respectively.
+option small {
+    macros {
+	odf-size	= 128;
+	aodf-size	= 128;
+	cdf-size	= 256;
+	prkdf-size	= 128;
+	pukdf-size	= 128;
+	dodf-size	= 128;
+    }
+}
+
+# This option tells pkcs15-init to use the direct option
+# when storing certificates on the card (i.e. put the
+# certificates into the CDF itself, rather than a
+# separate file)
+option direct-cert {
+    pkcs15 {
+        direct-certificates	= yes;
+	encode-df-length	= yes;
+    }
+    macros {
+	cdf-size	= 3192;
+    }
+}
+
+# Define reasonable limits for PINs and PUK
+# Note that we do not set a file path or reference
+# for the user pin; that is done dynamically.
+PIN user-pin {
+    attempts	= 3;
+    flags	= local, initialized, needs-padding;
+}
+PIN user-puk {
+    attempts	= 7;
+}
+PIN so-pin {
+    auth-id	= $so-auth-id;
+    attempts	= $so-pin-attempts;
+    min-length	= $so-min-pin-length;
+    flags	= $so-pin-flags;
+}
+PIN so-puk {
+    attempts	= $so-puk-attempts;
+    min-length	= $so-min-puk-length;
+}
+
+filesystem {
+    DF MF {
+        path	= 3F00;
+        type	= DF;
+
+	# This is the DIR file
+	EF DIR {
+	    type	= EF;
+	    file-id	= 2F00;
+	    size	= 128;
+	    acl		= *=NONE;
+	}
+
+	# Here comes the application DF
+	DF PKCS15-AppDF {
+	    type	= DF;
+	    file-id	= 2ADF;
+	    aid		= e8:28:00:bd:08:0f:a0:00:00:03:63:64:79:6e:69:64;
+	    acl		= *=NONE;
+	    size	= 5000;
+
+	    EF PKCS15-ODF {
+	        file-id		= 5031;
+		size		= $odf-size;
+		ACL		= $unprotected;
+	    }
+
+	    EF PKCS15-TokenInfo {
+		file-id		= 5032;
+		ACL		= $unprotected;
+	    }
+
+	    #EF PKCS15-UnusedSpace {
+		#file-id		= 5033;
+		#size		= $unusedspace-size;
+		#ACL		= $unprotected;
+	    #}
+
+	    EF PKCS15-AODF {
+	    file-id		= 4108;
+		size		= $aodf-size;
+		ACL			= $protected;   
+	    }
+
+	    EF PKCS15-PrKDF {
+	        file-id		= 4100;
+		size		= $prkdf-size;
+		acl		= $protected;
+	    }
+
+	    EF PKCS15-PuKDF {
+	        file-id		= 4101;
+		size		= $pukdf-size;
+		acl		= $protected;
+	    }
+
+	    EF PKCS15-CDF {
+	        file-id		= 4104;
+		size		= $cdf-size;
+		acl		= $protected;
+	    }
+
+	    EF PKCS15-DODF {
+	        file-id		= 4107;
+		size		= $dodf-size;
+		ACL		= $protected;
+	    }
+
+	}
+    }
+}
diff --git a/src/pkcs15init/profile.c b/src/pkcs15init/profile.c
index ba2b22ee..681798a7 100644
--- a/src/pkcs15init/profile.c
+++ b/src/pkcs15init/profile.c
@@ -1,2662 +1,2662 @@
-/*
- * Initialize Cards according to PKCS#15
- *
- * Copyright (C) 2002 Olaf Kirch <okir@suse.de>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- * Random notes
- *  -	the "key" command should go away, it's obsolete
- */
-
-#include "config.h"
-
-#include <stdio.h>
-#include <ctype.h>
-#include <stdarg.h>
-#include <string.h>
-#include <limits.h>
-#ifdef HAVE_STRINGS_H
-#include <strings.h>
-#endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <assert.h>
-#include <stdlib.h>
-
-#ifdef _WIN32
-#include <windows.h>
-#include <winreg.h>
-#endif
-
-#include "common/compat_strlcpy.h"
-#include "scconf/scconf.h"
-#include "libopensc/log.h"
-#include "libopensc/pkcs15.h"
-#include "pkcs15-init.h"
-#include "profile.h"
-
-#define DEF_PRKEY_RSA_ACCESS	0x1D
-#define DEF_PUBKEY_ACCESS	0x12
-
-#define TEMPLATE_FILEID_MIN_DIFF	0x20
-
-#define WORD_SIZE	64
-
-/*
-#define DEBUG_PROFILE
-*/
-
-/*
- * Parser state
- */
-struct state {
-	struct state *		frame;
-	const char *		filename;
-	struct sc_profile *	profile;
-	struct file_info *	file;
-	struct pin_info *	pin;
-	struct auth_info *	key;
-};
-
-
-struct command {
-	const char *		name;
-	int			min_args, max_args;
-	int			(*func)(struct state *, int, char **);
-};
-
-struct block {
-	const char *		name;
-	int			(*handler)(struct state *,
-					struct block *,
-					const char *,
-					scconf_block *);
-	struct command *	cmd_info;
-	struct block *		blk_info;
-};
-
-struct map {
-	const char *		name;
-	unsigned int		val;
-};
-
-static struct map		aclNames[] = {
-	{ "NONE",	SC_AC_NONE	},
-	{ "NEVER",	SC_AC_NEVER	},
-	{ "CHV",	SC_AC_CHV	},
-	{ "TERM",	SC_AC_TERM	},
-	{ "PRO",	SC_AC_PRO	},
-	{ "AUT",	SC_AC_AUT	},
-	{ "KEY",	SC_AC_AUT	},
-	{ "SEN",	SC_AC_SEN	},
-	{ "IDA",	SC_AC_IDA	},
-	{ "SCB",	SC_AC_SCB	},
-	{ NULL, 0 }
-};
-static struct map		fileOpNames[] = {
-	{ "SELECT",	SC_AC_OP_SELECT	},
-	{ "LOCK",	SC_AC_OP_LOCK	},
-	{ "DELETE",	SC_AC_OP_DELETE	},
-	{ "DELETE-SELF",SC_AC_OP_DELETE_SELF },
-	{ "CREATE",	SC_AC_OP_CREATE	},
-	{ "CREATE-EF",	SC_AC_OP_CREATE_EF	},
-	{ "CREATE-DF",	SC_AC_OP_CREATE_DF	},
-	{ "REHABILITATE",SC_AC_OP_REHABILITATE	},
-	{ "INVALIDATE",	SC_AC_OP_INVALIDATE	},
-	{ "FILES",	SC_AC_OP_LIST_FILES	},
-	{ "READ",	SC_AC_OP_READ	},
-	{ "UPDATE",	SC_AC_OP_UPDATE	},
-	{ "WRITE",	SC_AC_OP_WRITE	},
-	{ "ERASE",	SC_AC_OP_ERASE	},
-	{ "CRYPTO",     SC_AC_OP_CRYPTO },
-        { "PIN-DEFINE", SC_AC_OP_PIN_DEFINE },
-        { "PIN-CHANGE", SC_AC_OP_PIN_CHANGE },
-        { "PIN-RESET",  SC_AC_OP_PIN_RESET },
-        { "PIN-USE",	SC_AC_OP_PIN_USE },
-	{ "GENERATE",	SC_AC_OP_GENERATE },
-	{ "PSO-COMPUTE-SIGNATURE",	SC_AC_OP_PSO_COMPUTE_SIGNATURE },
-	{ "INTERNAL-AUTHENTICATE",	SC_AC_OP_INTERNAL_AUTHENTICATE },
-	{ "PSO-DECRYPT",		SC_AC_OP_PSO_DECRYPT },
-	{ "RESIZE",	SC_AC_OP_RESIZE },
-	{ "ADMIN",	SC_AC_OP_ADMIN	},
-	{ "ACTIVATE",	SC_AC_OP_ACTIVATE },
-	{ "DEACTIVATE",	SC_AC_OP_DEACTIVATE },
-	{ NULL, 0 }
-};
-static struct map		fileTypeNames[] = {
-	{ "EF",		SC_FILE_TYPE_WORKING_EF		},
-	{ "INTERNAL-EF",SC_FILE_TYPE_INTERNAL_EF	},
-	{ "DF",		SC_FILE_TYPE_DF			},
-	{ "BSO",	SC_FILE_TYPE_BSO		},
-	{ NULL, 0 }
-};
-static struct map		fileStructureNames[] = {
-	{ "TRANSPARENT",	SC_FILE_EF_TRANSPARENT	},
-	{ "LINEAR-FIXED",	SC_FILE_EF_LINEAR_FIXED	},
-	{ "LINEAR-FIXED-TLV",	SC_FILE_EF_LINEAR_FIXED_TLV	},
-	{ "LINEAR-VARIABLE",	SC_FILE_EF_LINEAR_VARIABLE	},
-	{ "LINEAR-VARIABLE-TLV",SC_FILE_EF_LINEAR_VARIABLE_TLV	},
-	{ "CYCLIC",		SC_FILE_EF_CYCLIC	},
-	{ "CYCLIC-TLV",		SC_FILE_EF_CYCLIC_TLV	},
-	{ NULL, 0 }
-};
-static struct map		pkcs15DfNames[] = {
-	{ "PRKDF",		SC_PKCS15_PRKDF		},
-	{ "PUKDF",		SC_PKCS15_PUKDF		},
-	{ "PUKDF-TRUSTED",	SC_PKCS15_PUKDF_TRUSTED	},
-	{ "SKDF",		SC_PKCS15_SKDF		},
-	{ "CDF",		SC_PKCS15_CDF		},
-	{ "CDF-TRUSTED",	SC_PKCS15_CDF_TRUSTED	},
-	{ "CDF-USEFUL",		SC_PKCS15_CDF_USEFUL	},
-	{ "DODF",		SC_PKCS15_DODF		},
-	{ "AODF",		SC_PKCS15_AODF		},
-	{ NULL, 0 }
-};
-static struct map		pinTypeNames[] = {
-	{ "BCD",		SC_PKCS15_PIN_TYPE_BCD	},
-	{ "ascii-numeric",	SC_PKCS15_PIN_TYPE_ASCII_NUMERIC	},
-	{ "utf8",		SC_PKCS15_PIN_TYPE_UTF8	},
-	{ "half-nibble-bcd",	SC_PKCS15_PIN_TYPE_HALFNIBBLE_BCD	},
-	{ "iso9564-1",		SC_PKCS15_PIN_TYPE_ISO9564_1	},
-	{ NULL, 0 }
-};
-static struct map		pinIdNames[] = {
-	{ "pin",		SC_PKCS15INIT_USER_PIN	},
-	{ "puk",		SC_PKCS15INIT_USER_PUK	},
-	{ "user-pin",		SC_PKCS15INIT_USER_PIN	},
-	{ "user-puk",		SC_PKCS15INIT_USER_PUK	},
-	{ "sopin",		SC_PKCS15INIT_SO_PIN	},
-	{ "sopuk",		SC_PKCS15INIT_SO_PUK	},
-	{ "so-pin",		SC_PKCS15INIT_SO_PIN	},
-	{ "so-puk",		SC_PKCS15INIT_SO_PUK	},
-	{ NULL, 0 }
-};
-static struct map		pinFlagNames[] = {
-	{ "case-sensitive",		SC_PKCS15_PIN_FLAG_CASE_SENSITIVE		},
-	{ "local",			SC_PKCS15_PIN_FLAG_LOCAL			},
-	{ "change-disabled",		SC_PKCS15_PIN_FLAG_CHANGE_DISABLED		},
-	{ "unblock-disabled",		SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED		},
-	{ "initialized",		SC_PKCS15_PIN_FLAG_INITIALIZED			},
-	{ "needs-padding",		SC_PKCS15_PIN_FLAG_NEEDS_PADDING		},
-	{ "unblockingPin",		SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN		},
-	{ "soPin",			SC_PKCS15_PIN_FLAG_SO_PIN			},
-	{ "disable-allowed",		SC_PKCS15_PIN_FLAG_DISABLE_ALLOW		},
-	{ "integrity-protected",	SC_PKCS15_PIN_FLAG_INTEGRITY_PROTECTED		},
-	{ "confidentiality-protected",	SC_PKCS15_PIN_FLAG_CONFIDENTIALITY_PROTECTED	},
-	{ "exchangeRefData",		SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA		},
-	{ NULL, 0 }
-};
-static struct map		idStyleNames[] = {
-	{ "native",		SC_PKCS15INIT_ID_STYLE_NATIVE },
-	{ "mozilla",		SC_PKCS15INIT_ID_STYLE_MOZILLA },
-	{ "rfc2459",		SC_PKCS15INIT_ID_STYLE_RFC2459 },
-	{ NULL, 0 }
-};
-static struct map              mdStyleNames[] = {
-	{ "none",               SC_PKCS15INIT_MD_STYLE_NONE },
-	{ "gemalto",            SC_PKCS15INIT_MD_STYLE_GEMALTO },
-	{ NULL, 0 }
-};
-static struct {
-	const char *		name;
-	struct map *		addr;
-} mapNames[] = {
-	{ "file ACL",		aclNames	},
-	{ "file operation",	fileOpNames	},
-	{ "file type",		fileTypeNames	},
-	{ "file structure",	fileStructureNames},
-	{ "PKCS#15 file name",	pkcs15DfNames	},
-	{ "pin encoding",	pinTypeNames	},
-	{ "pin name",		pinIdNames	},
-	{ "pin flag",		pinFlagNames	},
-	{ NULL, NULL }
-};
-
-static int		process_conf(struct sc_profile *, scconf_context *);
-static int		process_block(struct state *, struct block *,
-				const char *, scconf_block *);
-static void		init_state(struct state *, struct state *);
-static int		get_authid(struct state *, const char *,
-				unsigned int *, unsigned int *);
-static int		get_uint(struct state *, const char *, unsigned int *);
-static int		get_bool(struct state *, const char *, unsigned int *);
-static int		get_uint_eval(struct state *, int, char **,
-				unsigned int *);
-static int		map_str2int(struct state *, const char *,
-				unsigned int *, struct map *);
-static int		setstr(char **strp, const char *value);
-static void		parse_error(struct state *, const char *, ...);
-
-static struct file_info *	sc_profile_instantiate_file(sc_profile_t *,
-				struct file_info *, struct file_info *,
-				unsigned int);
-static struct file_info *	sc_profile_find_file(struct sc_profile *,
-				const sc_path_t *, const char *);
-static struct file_info *	sc_profile_find_file_by_path(
-				struct sc_profile *,
-				const sc_path_t *);
-
-static struct pin_info *	new_pin(struct sc_profile *, int);
-static struct file_info *	new_file(struct state *, const char *,
-				unsigned int);
-static struct file_info *	add_file(sc_profile_t *, const char *,
-				sc_file_t *, struct file_info *);
-static void		free_file_list(struct file_info **);
-static void		append_file(sc_profile_t *, struct file_info *);
-static struct auth_info *	new_key(struct sc_profile *,
-				unsigned int, unsigned int);
-static void		set_pin_defaults(struct sc_profile *,
-				struct pin_info *);
-static int		new_macro(sc_profile_t *, const char *, scconf_list *);
-static sc_macro_t *	find_macro(sc_profile_t *, const char *);
-
-static sc_file_t *
-init_file(unsigned int type)
-{
-	struct sc_file	*file;
-	unsigned int	op;
-
-	file = sc_file_new();
-	for (op = 0; op < SC_MAX_AC_OPS; op++) {
-		sc_file_add_acl_entry(file, op, SC_AC_NONE, 0);
-	}
-	file->type = type;
-	file->status = SC_FILE_STATUS_ACTIVATED;
-	if (file->type != SC_FILE_TYPE_DF && file->type != SC_FILE_TYPE_BSO)
-		file->ef_structure = SC_FILE_EF_TRANSPARENT;
-	return file;
-}
-
-/*
- * Initialize profile
- */
-struct sc_profile *
-sc_profile_new(void)
-{
-	struct sc_pkcs15_card *p15card;
-	struct sc_profile *pro;
-
-	pro = calloc(1, sizeof(*pro));
-	if (pro == NULL)
-		return NULL;
-	pro->p15_spec = p15card = sc_pkcs15_card_new();
-
-	pro->pkcs15.do_last_update = 1;
-
-	if (p15card) {
-		p15card->tokeninfo->label = strdup("OpenSC Card");
-		p15card->tokeninfo->manufacturer_id = strdup("OpenSC Project");
-		p15card->tokeninfo->serial_number = strdup("0000");
-		p15card->tokeninfo->flags = SC_PKCS15_TOKEN_EID_COMPLIANT;
-		p15card->tokeninfo->version = 0;
-
-		/* Set up EF(TokenInfo) and EF(ODF) */
-		p15card->file_tokeninfo = init_file(SC_FILE_TYPE_WORKING_EF);
-		p15card->file_odf = init_file(SC_FILE_TYPE_WORKING_EF);
-		p15card->file_unusedspace = init_file(SC_FILE_TYPE_WORKING_EF);
-	}
-
-	/* Assume card does RSA natively */
-	pro->rsa_access_flags = DEF_PRKEY_RSA_ACCESS;
-	pro->pin_encoding = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
-	pro->pin_minlen = 4;
-	pro->pin_maxlen = 8;
-	pro->id_style = SC_PKCS15INIT_ID_STYLE_NATIVE;
-
-	return pro;
-}
-
-int
-sc_profile_load(struct sc_profile *profile, const char *filename)
-{
-	struct sc_context *ctx = profile->card->ctx;
-	scconf_context	*conf;
-	const char *profile_dir = NULL;
-	char path[PATH_MAX];
-	int res = 0, i;
-#ifdef _WIN32
-	char temp_path[PATH_MAX];
-	size_t temp_len;
-#endif
-
-	LOG_FUNC_CALLED(ctx);
-	for (i = 0; ctx->conf_blocks[i]; i++) {
-		profile_dir = scconf_get_str(ctx->conf_blocks[i], "profile_dir", NULL);
-		if (profile_dir)
-			break;
-	}
-
-	if (!profile_dir) {
-#ifdef _WIN32
-		temp_len = PATH_MAX - 1;
-		res = sc_ctx_win32_get_config_value(NULL, "ProfileDir", "Software\\OpenSC Project\\OpenSC",
-				temp_path, &temp_len);
-		if (res)
-			LOG_FUNC_RETURN(ctx, res);
-		temp_path[temp_len] = '\0';
-		profile_dir = temp_path;
-#else
-		profile_dir = SC_PKCS15_PROFILE_DIRECTORY;
-#endif
-	}
-	sc_log(ctx, "Using profile directory '%s'.", profile_dir);
-
-#ifdef _WIN32
-	snprintf(path, sizeof(path), "%s\\%s.%s", profile_dir, filename, SC_PKCS15_PROFILE_SUFFIX);
-#else /* _WIN32 */
-	snprintf(path, sizeof(path), "%s/%s.%s", profile_dir, filename, SC_PKCS15_PROFILE_SUFFIX);
-#endif /* _WIN32 */
-
-	sc_log(ctx, "Trying profile file %s", path);
-
-	conf = scconf_new(path);
-	res = scconf_parse(conf);
-
-	sc_log(ctx, "profile %s loaded ok", path);
-
-	if (res < 0) {
-		scconf_free(conf);
-		LOG_FUNC_RETURN(ctx, SC_ERROR_FILE_NOT_FOUND);
-	}
-
-	if (res == 0) {
-		scconf_free(conf);
-		LOG_FUNC_RETURN(ctx, SC_ERROR_SYNTAX_ERROR);
-	}
-
-	res = process_conf(profile, conf);
-	scconf_free(conf);
-	LOG_FUNC_RETURN(ctx, res);
-}
-
-
-int
-sc_profile_finish(struct sc_profile *profile, const struct sc_app_info *app_info)
-{
-	struct sc_context *ctx = profile->card->ctx;
-	struct file_info *fi;
-	struct pin_info	*pi;
-	char		reason[64];
-
-	LOG_FUNC_CALLED(ctx);
-	profile->mf_info = sc_profile_find_file(profile, NULL, "MF");
-	if (!profile->mf_info)
-		LOG_TEST_RET(ctx, SC_ERROR_INCONSISTENT_PROFILE, "Profile doesn't define a MF");
-
-	if (app_info && app_info->aid.len)   {
-		struct sc_path path;
-
-		sc_log(ctx, "finish profile with '%s' application profile", app_info->label);
-		memset(&path, 0, sizeof(struct sc_path));
-		path.type = SC_PATH_TYPE_DF_NAME;
-		path.aid = app_info->aid;
-
-		sc_log(ctx, "Look for file by path '%s'", sc_print_path(&path));
-		profile->df_info = sc_profile_find_file_by_path(profile, &path);
-		sc_log(ctx, "returned DF info %p", profile->df_info);
-		if (profile->df_info && profile->df_info->profile_extension)   {
-			sc_log(ctx, "application profile extension '%s'", profile->df_info->profile_extension);
-			if (sc_profile_load(profile, profile->df_info->profile_extension))
-				LOG_TEST_RET(ctx, SC_ERROR_INCONSISTENT_PROFILE, "Cannot load application profile extension");
-		}
-	}
-
-	profile->df_info = sc_profile_find_file(profile, NULL, "PKCS15-AppDF");
-	if (!profile->df_info)
-		LOG_TEST_RET(ctx, SC_ERROR_INCONSISTENT_PROFILE, "Profile doesn't define a PKCS15-AppDF");
-
-	profile->p15_spec->file_app = profile->df_info->file;
-	profile->df_info->dont_free = 1;
-
-	for (pi = profile->pin_list; pi; pi = pi->next) {
-		const char	*name;
-
-		set_pin_defaults(profile, pi);
-		if (!(name = pi->file_name))
-			continue;
-		if (!(fi = sc_profile_find_file(profile, NULL, name))) {
-			snprintf(reason, sizeof(reason), "unknown PIN file \"%s\"\n", name);
-			goto whine;
-		}
-
-		pi->file = fi;
-	}
-	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
-
-whine:
-	sc_log(ctx, "%s", reason);
-	LOG_FUNC_RETURN(ctx, SC_ERROR_INCONSISTENT_PROFILE);
-}
-
-void
-sc_profile_free(struct sc_profile *profile)
-{
-	struct auth_info *ai;
-	struct pin_info *pi;
-	sc_macro_t	*mi;
-	sc_template_t	*ti;
-
-	if (profile->name)
-		free(profile->name);
-	if (profile->driver)
-		free(profile->driver);
-
-	free_file_list(&profile->ef_list);
-
-	while ((ai = profile->auth_list) != NULL) {
-		profile->auth_list = ai->next;
-		free(ai);
-	}
-
-	while ((ti = profile->template_list) != NULL) {
-		profile->template_list = ti->next;
-		if (ti->data)
-			sc_profile_free(ti->data);
-		if (ti->name)
-			free(ti->name);
-		free(ti);
-	}
-
-	while ((mi = profile->macro_list) != NULL) {
-		profile->macro_list = mi->next;
-		if (mi->name)
-			free(mi->name);
-		free(mi);
-	}
-
-	while ((pi = profile->pin_list) != NULL) {
-		profile->pin_list = pi->next;
-		if (pi->file_name)
-			free(pi->file_name);
-		free(pi);
-	}
-
-	for (int i = 0; profile->options[i]; i++) {
-		free(profile->options[i]);
-	}
-
-	if (profile->p15_spec)
-		sc_pkcs15_card_free(profile->p15_spec);
-	free(profile);
-}
-
-void
-sc_profile_get_pin_info(struct sc_profile *profile,
-		int id, struct sc_pkcs15_auth_info *info)
-{
-	struct pin_info	*pi;
-
-	pi = new_pin(profile, id);
-	if (pi == NULL)
-		return;
-
-	pi->pin.max_tries = pi->pin.tries_left;
-	*info = pi->pin;
-}
-
-int
-sc_profile_get_pin_retries(sc_profile_t *profile, int id)
-{
-	struct pin_info	*pi;
-
-	pi = new_pin(profile, id);
-	if (pi == NULL)
-		return SC_ERROR_OUT_OF_MEMORY;
-	return pi->pin.tries_left;
-}
-
-int
-sc_profile_get_pin_id(struct sc_profile *profile,
-		unsigned int reference, int *id)
-{
-	struct pin_info	*pi;
-
-	for (pi = profile->pin_list; pi; pi = pi->next) {
-		if (pi->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
-			continue;
-		if (pi->pin.attrs.pin.reference == (int)reference) {
-			*id = pi->id;
-			return 0;
-		}
-
-	}
-	return SC_ERROR_OBJECT_NOT_FOUND;
-}
-
-int
-sc_profile_get_file_in(sc_profile_t *profile,
-		const sc_path_t *path, const char *name, sc_file_t **ret)
-{
-	struct file_info *fi;
-
-	if ((fi = sc_profile_find_file(profile, path, name)) == NULL)
-		return SC_ERROR_FILE_NOT_FOUND;
-	sc_file_dup(ret, fi->file);
-	if (*ret == NULL)
-		return SC_ERROR_OUT_OF_MEMORY;
-	return 0;
-}
-
-int
-sc_profile_get_file(struct sc_profile *profile,
-		const char *name, sc_file_t **ret)
-{
-	struct file_info *fi;
-
-	if ((fi = sc_profile_find_file(profile, NULL, name)) == NULL)
-		return SC_ERROR_FILE_NOT_FOUND;
-	sc_file_dup(ret, fi->file);
-	if (*ret == NULL)
-		return SC_ERROR_OUT_OF_MEMORY;
-	return 0;
-}
-
-int
-sc_profile_get_file_instance(struct sc_profile *profile, const char *name,
-		int index, sc_file_t **ret)
-{
-	struct sc_context *ctx = profile->card->ctx;
-	struct file_info *fi;
-	struct sc_file *file;
-	int r;
-
-	LOG_FUNC_CALLED(ctx);
-	sc_log(ctx, "try to get '%s' file instance", name);
-
-	if ((fi = sc_profile_find_file(profile, NULL, name)) == NULL)
-		LOG_FUNC_RETURN(ctx, SC_ERROR_FILE_NOT_FOUND);
-	sc_file_dup(&file, fi->file);
-	sc_log(ctx, "ident '%s'; parent '%s'", fi->ident, fi->parent ? fi->parent->ident : "(null)");
-	if (file == NULL)
-		LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);
-	sc_log(ctx, "file (type:%X, path:'%s')", file->type, sc_print_path(&file->path));
-
-	file->id += index;
-        if(file->type == SC_FILE_TYPE_BSO) {
-		r = sc_profile_add_file(profile, name, file);
-		if (r < 0)
-			sc_file_free(file);
-		LOG_TEST_RET(ctx, r, "Profile error: cannot add BSO file");
-	}
-	else if (file->path.len)   {
-		file->path.value[file->path.len - 2] = (file->id >> 8) & 0xFF;
-		file->path.value[file->path.len - 1] = file->id & 0xFF;
-
-		r = sc_profile_add_file(profile, name, file);
-		if (r < 0)
-			sc_file_free(file);
-		LOG_TEST_RET(ctx, r, "Profile error: cannot add file");
-	}
-
-	if (ret)
-		*ret = file;
-	else
-		sc_file_free(file);
-
-	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
-}
-
-int
-sc_profile_get_path(struct sc_profile *profile,
-		const char *name, sc_path_t *ret)
-{
-	struct file_info *fi;
-
-	if ((fi = sc_profile_find_file(profile, NULL, name)) == NULL)
-		return SC_ERROR_FILE_NOT_FOUND;
-	*ret = fi->file->path;
-	return 0;
-}
-
-int
-sc_profile_get_file_by_path(struct sc_profile *profile,
-		const sc_path_t *path, sc_file_t **ret)
-{
-	struct sc_context *ctx = profile->card->ctx;
-	struct file_info *fi;
-
-	LOG_FUNC_CALLED(ctx);
-	if ((fi = sc_profile_find_file_by_path(profile, path)) == NULL)
-		LOG_FUNC_RETURN(ctx, SC_ERROR_FILE_NOT_FOUND);
-	sc_file_dup(ret, fi->file);
-	LOG_FUNC_RETURN(ctx, *ret ? SC_SUCCESS : SC_ERROR_OUT_OF_MEMORY);
-}
-
-int
-sc_profile_add_file(sc_profile_t *profile, const char *name, sc_file_t *file)
-{
-	struct sc_context *ctx = profile->card->ctx;
-	sc_path_t	path = file->path;
-	struct file_info	*parent;
-
-	LOG_FUNC_CALLED(ctx);
-	if (!path.len)   {
-		parent = profile->df_info;
-	} else {
-		path.len -= 2;
-		parent = sc_profile_find_file_by_path(profile, &path);
-	}
-	if (!parent)
-		LOG_FUNC_RETURN(ctx, SC_ERROR_FILE_NOT_FOUND);
-	sc_log(ctx, "Parent path:%s", sc_print_path(&parent->file->path));
-
-	sc_file_dup(&file, file);
-	if (file == NULL)
-		LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);
-
-	add_file(profile, name, file, parent);
-	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
-}
-
-/*
- * Instantiate template
- */
-int
-sc_profile_instantiate_template(sc_profile_t *profile,
-		const char *template_name, const sc_path_t *base_path,
-		const char *file_name, const sc_pkcs15_id_t *id,
-		sc_file_t **ret)
-{
-	struct sc_context *ctx = profile->card->ctx;
-	struct sc_profile	*tmpl;
-	struct sc_template	*info;
-	unsigned int	idx;
-	struct file_info *fi, *base_file, *match = NULL;
-
-#ifdef DEBUG_PROFILE
-	printf("Instantiate %s in template %s\n", file_name, template_name);
-	sc_profile_find_file_by_path(profile, base_path);
-#endif
-	for (info = profile->template_list; info; info = info->next)
-		if (!strcmp(info->name, template_name))
-			break;
-	if (info == NULL)   {
-		sc_log(ctx, "Template %s not found", template_name);
-		return SC_ERROR_TEMPLATE_NOT_FOUND;
-	}
-
-	tmpl = info->data;
-	idx = id->value[id->len-1];
-	for (fi = profile->ef_list; fi; fi = fi->next) {
-		if (fi->base_template == tmpl
-		 && fi->inst_index == idx
-		 && sc_compare_path(&fi->inst_path, base_path)
-		 && !strcmp(fi->ident, file_name)) {
-			sc_file_dup(ret, fi->file);
-			if (*ret == NULL)
-				return SC_ERROR_OUT_OF_MEMORY;
-			return 0;
-		}
-	}
-
-	sc_log(ctx, "Instantiating template %s at %s", template_name, sc_print_path(base_path));
-
-	base_file = sc_profile_find_file_by_path(profile, base_path);
-	if (base_file == NULL) {
-		sc_log(ctx, "Directory %s not defined in profile", sc_print_path(base_path));
-		return SC_ERROR_OBJECT_NOT_FOUND;
-	}
-
-	/* This loop relies on the fact that new files are always
-	 * appended to the list, after the parent files they refer to
-	 */
-	assert(base_file->instance);
-	for (fi = tmpl->ef_list; fi; fi = fi->next) {
-		struct file_info	*parent, *instance;
-		unsigned int	skew = 0;
-
-		fi->instance = NULL;
-		if ((parent = fi->parent) == NULL) {
-			parent = base_file;
-			skew = idx;
-		}
-		parent = parent->instance;
-
-		instance = sc_profile_instantiate_file(profile, fi, parent, skew);
-		if (instance == NULL)
-			return SC_ERROR_OUT_OF_MEMORY;
-		instance->base_template = tmpl;
-		instance->inst_index = idx;
-		instance->inst_path = *base_path;
-
-		if (!strcmp(instance->ident, file_name))
-			match = instance;
-	}
-
-	if (match == NULL) {
-		sc_log(ctx, "No file named \"%s\" in template \"%s\"",
-				file_name, template_name);
-		return SC_ERROR_OBJECT_NOT_FOUND;
-	}
-	sc_file_dup(ret, match->file);
-	if (*ret == NULL)
-		return SC_ERROR_OUT_OF_MEMORY;
-#ifdef DEBUG_PROFILE
-	printf("Template instantiated\n");
-#endif
-	return 0;
-}
-
-static struct file_info *
-sc_profile_instantiate_file(sc_profile_t *profile, struct file_info *ft,
-		struct file_info *parent, unsigned int skew)
-{
-	struct sc_context *ctx = profile->card->ctx;
-	struct file_info *fi;
-
-	fi = calloc(1, sizeof(*fi));
-	if (fi == NULL)
-		return NULL;
-	fi->instance = fi;
-	fi->parent = parent;
-	fi->ident = strdup(ft->ident);
-	if (fi->ident == NULL) {
-		free(fi);
-		return NULL;
-	}
-	sc_file_dup(&fi->file, ft->file);
-	if (fi->file == NULL) {
-		free(fi->ident);
-		free(fi);
-		return NULL;
-	}
-	fi->file->path = parent->file->path;
-	fi->file->id += skew;
-
-	if (fi->file->type == SC_FILE_TYPE_INTERNAL_EF
-			|| fi->file->type == SC_FILE_TYPE_WORKING_EF
-			|| (fi->file->type == SC_FILE_TYPE_DF && fi->file->id))
-		sc_append_file_id(&fi->file->path, fi->file->id);
-
-	append_file(profile, fi);
-
-	ft->instance = fi;
-
-	sc_log(ctx, "Instantiated %s at %s", ft->ident, sc_print_path(&fi->file->path));
-	sc_log(ctx, "  parent=%s@%s", parent->ident, sc_print_path(&parent->file->path));
-
-	return fi;
-}
-
-int
-sc_profile_get_pin_id_by_reference(struct sc_profile *profile,
-		unsigned auth_method, int reference,
-		struct sc_pkcs15_auth_info *auth_info)
-{
-	struct pin_info *pinfo;
-
-	for (pinfo = profile->pin_list; pinfo; pinfo = pinfo->next)  {
-		if (auth_method == SC_AC_SYMBOLIC)   {
-			if (pinfo->id != reference)
-				continue;
-		}
-		else   {
-			if (pinfo->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
-				continue;
-			if (pinfo->pin.auth_method != auth_method)
-				continue;
-			if (pinfo->pin.attrs.pin.reference != reference)
-				continue;
-		}
-
-		if (auth_info)
-			*auth_info = pinfo->pin;
-		return pinfo->id;
-	}
-
-	return -1;
-}
-
-/*
- * Configuration file parser
- */
-static void
-init_state(struct state *cur_state, struct state *new_state)
-{
-	memset(new_state, 0, sizeof(*new_state));
-	new_state->filename = cur_state->filename;
-	new_state->profile = cur_state->profile;
-	new_state->frame = cur_state;
-}
-
-static int
-do_card_driver(struct state *cur, int argc, char **argv)
-{
-	free(cur->profile->driver);
-	cur->profile->driver = strdup(argv[0]);
-	return 0;
-}
-
-static int
-do_maxpinlength(struct state *cur, int argc, char **argv)
-{
-	return get_uint(cur, argv[0], &cur->profile->pin_maxlen);
-}
-
-static int
-do_minpinlength(struct state *cur, int argc, char **argv)
-{
-	return get_uint(cur, argv[0], &cur->profile->pin_minlen);
-}
-
-static int
-do_default_pin_type(struct state *cur, int argc, char **argv)
-{
-	return map_str2int(cur, argv[0],
-		       	&cur->profile->pin_encoding, pinTypeNames);
-}
-
-static int
-do_pin_pad_char(struct state *cur, int argc, char **argv)
-{
-	return get_uint(cur, argv[0], &cur->profile->pin_pad_char);
-}
-
-static int
-do_pin_domains(struct state *cur, int argc, char **argv)
-{
-	return get_bool(cur, argv[0], &cur->profile->pin_domains);
-}
-
-static int
-do_card_label(struct state *cur, int argc, char **argv)
-{
-	struct sc_pkcs15_card	*p15card = cur->profile->p15_spec;
-
-	return setstr(&p15card->tokeninfo->label, argv[0]);
-}
-
-static int
-do_card_manufacturer(struct state *cur, int argc, char **argv)
-{
-	struct sc_pkcs15_card	*p15card = cur->profile->p15_spec;
-
-	return setstr(&p15card->tokeninfo->manufacturer_id, argv[0]);
-}
-
-/*
- * Command related to the pkcs15 we generate
- */
-static int
-do_direct_certificates(struct state *cur, int argc, char **argv)
-{
-	return get_bool(cur, argv[0], &cur->profile->pkcs15.direct_certificates);
-}
-
-static int
-do_encode_df_length(struct state *cur, int argc, char **argv)
-{
-	return get_bool(cur, argv[0], &cur->profile->pkcs15.encode_df_length);
-}
-
-static int
-do_encode_update_field(struct state *cur, int argc, char **argv)
-{
-	return get_bool(cur, argv[0], &cur->profile->pkcs15.do_last_update);
-}
-
-static int
-do_pkcs15_id_style(struct state *cur, int argc, char **argv)
-{
-	return map_str2int(cur, argv[0], &cur->profile->id_style, idStyleNames);
-}
-
-static int
-do_minidriver_support_style(struct state *cur, int argc, char **argv)
-{
-	return map_str2int(cur, argv[0], &cur->profile->md_style, mdStyleNames);
-}
-
-/*
- * Process an option block
- */
-static int
-process_option(struct state *cur, struct block *info,
-		const char *name, scconf_block *blk)
-{
-	sc_profile_t	*profile = cur->profile;
-	int		match = 0, i;
-
-	for (i = 0; profile->options[i]; i++)
-		match |= !strcmp(profile->options[i], name);
-	if (!match && strcmp("default", name))
-		return 0;
-	return process_block(cur, info, name, blk);
-}
-
-/*
- * Process a key block
- */
-static int
-process_key(struct state *cur, struct block *info,
-		const char *name, scconf_block *blk)
-{
-	unsigned int	type, id;
-	struct state	state;
-
-	if (get_authid(cur, name, &type, &id))
-		return 1;
-
-	init_state(cur, &state);
-	state.key = new_key(cur->profile, type, id);
-	return process_block(&state, info, name, blk);
-}
-
-static struct auth_info *
-new_key(struct sc_profile *profile, unsigned int type, unsigned int ref)
-{
-	struct auth_info *ai, **aip;
-
-	for (aip = &profile->auth_list; (ai = *aip); aip = &ai->next) {
-		if (ai->type == type && ai->ref == ref)
-			return ai;
-	}
-
-	ai = calloc(1, sizeof(*ai));
-	if (ai == NULL)
-		return NULL;
-	ai->type = type;
-	ai->ref = ref;
-	*aip = ai;
-	return ai;
-}
-
-static int
-do_key_value(struct state *cur, int argc, char **argv)
-{
-	struct auth_info *ai = cur->key;
-	const char	*key = argv[0];
-	size_t		key_len;
-	unsigned char	keybuf[32];
-
-	if (key[0] == '=') {
-		++key;
-		key_len = strlen(key);
-		memcpy(keybuf, key, key_len);
-	} else {
-		key_len = sizeof(keybuf);
-		if (sc_hex_to_bin(key, keybuf, &key_len)) {
-			parse_error(cur, "Error parsing PIN/key \"%s\"\n", key);
-			return 1;
-		}
-	}
-
-	memcpy(ai->key, keybuf, key_len);
-	ai->key_len = key_len;
-	return 0;
-}
-
-/*
- * This function is called when the parser finds a block with an unknown
- * name in the filesystem block. This will create a new filesystem
- * object as the child of the current object.
- */
-static int
-process_df(struct state *cur, struct block *info,
-		const char *name, scconf_block *blk)
-{
-	struct state	state;
-
-	init_state(cur, &state);
-	if (name == NULL) {
-		parse_error(cur, "No name given for DF object.");
-		return 1;
-	}
-	if (!(state.file = new_file(cur, name, SC_FILE_TYPE_DF)))
-		return 1;
-	return process_block(&state, info, name, blk);
-}
-
-static int
-process_ef(struct state *cur, struct block *info,
-		const char *name, scconf_block *blk)
-{
-	struct state	state;
-
-	init_state(cur, &state);
-	if (name == NULL) {
-		parse_error(cur, "No name given for EF object.");
-		return 1;
-	}
-	if (!(state.file = new_file(cur, name, SC_FILE_TYPE_WORKING_EF)))
-		return 1;
-	return process_block(&state, info, name, blk);
-}
-
-
-static int
-process_bso(struct state *cur, struct block *info,
-		const char *name, scconf_block *blk)
-{
-	struct state	state;
-
-	init_state(cur, &state);
-	if (name == NULL) {
-		parse_error(cur, "No name given for BSO object.");
-		return 1;
-	}
-	if (!(state.file = new_file(cur, name, SC_FILE_TYPE_BSO)))
-		return 1;
-	return process_block(&state, info, name, blk);
-}
-
-/*
- * In the template the difference between any two file-ids
- * should be greater then TEMPLATE_FILEID_MIN_DIFF.
- */
-static int
-template_sanity_check(struct state *cur, struct sc_profile *templ)
-{
-	struct file_info *fi, *ffi;
-
-	for (fi = templ->ef_list; fi; fi = fi->next) {
-		struct sc_path fi_path =  fi->file->path;
-		int fi_id;
-
-		if (fi->file->type == SC_FILE_TYPE_BSO)
-			continue;
-
-		if (fi_path.len < 2) {
-			parse_error(cur, "Template insane: file-path length should not be less than 2 bytes");
-			return 1;
-		}
-
-		fi_id = fi_path.value[fi_path.len - 2] * 0x100
-				+ fi_path.value[fi_path.len - 1];
-
-		for (ffi = templ->ef_list; ffi; ffi = ffi->next) {
-			struct sc_path ffi_path =  ffi->file->path;
-			int dlt, ffi_id;
-
-			if (ffi->file->type == SC_FILE_TYPE_BSO)
-				continue;
-
-			if (ffi_path.len < 2) {
-				parse_error(cur, "Template insane: file-path length should not be less than 2 bytes");
-				return 1;
-			}
-
-			ffi_id = ffi_path.value[ffi_path.len - 2] * 0x100
-					+ ffi_path.value[ffi_path.len - 1];
-
-			dlt = fi_id > ffi_id ? fi_id - ffi_id : ffi_id - fi_id;
-			if (strcmp(ffi->ident, fi->ident))   {
-				if (dlt >= TEMPLATE_FILEID_MIN_DIFF)
-					continue;
-
-				parse_error(cur, "Template insane: file-ids should be substantially different");
-				return 1;
-			}
-		}
-	}
-
-	return SC_SUCCESS;
-}
-
-
-static int
-process_tmpl(struct state *cur, struct block *info,
-		const char *name, scconf_block *blk)
-{
-	struct state	state;
-	sc_template_t	*tinfo;
-	sc_profile_t	*templ;
-	int r;
-
-#ifdef DEBUG_PROFILE
-	printf("Process template:%s; block:%s\n", name, info->name);
-#endif
-	if (name == NULL) {
-		parse_error(cur, "No name given for template.");
-		return 1;
-	}
-
-	templ = calloc(1, sizeof(*templ));
-	if (templ == NULL) {
-		parse_error(cur, "memory allocation failed");
-		return 1;
-	}
-
-	tinfo = calloc(1, sizeof(*tinfo));
-	if (tinfo == NULL) {
-		parse_error(cur, "memory allocation failed");
-		free(templ);
-		return 1;
-	}
-	tinfo->name = strdup(name);
-	tinfo->data = templ;
-
-	tinfo->next = cur->profile->template_list;
-	cur->profile->template_list = tinfo;
-
-	init_state(cur, &state);
-	state.profile = tinfo->data;
-	state.file = NULL;
-
-	r = process_block(&state, info, name, blk);
-	if (!r)
-		r = template_sanity_check(cur, templ);
-
-#ifdef DEBUG_PROFILE
-	printf("Template %s processed; returns %i\n", name, r);
-#endif
-	return r;
-}
-
-/*
- * Append new file at the end of the ef_list.
- * This is crucial; the profile instantiation code relies on it
- */
-static void append_file(sc_profile_t *profile, struct file_info *nfile)
-{
-	struct file_info	**list, *fi;
-
-	list = &profile->ef_list;
-	while ((fi = *list) != NULL)
-		list = &fi->next;
-	*list = nfile;
-}
-
-/*
- * Add a new file to the profile.
- * This function is called by sc_profile_add_file.
- */
-static struct file_info *
-add_file(sc_profile_t *profile, const char *name,
-		sc_file_t *file, struct file_info *parent)
-{
-	struct file_info	*info;
-
-	info = calloc(1, sizeof(*info));
-	if (info == NULL)
-		return NULL;
-	info->instance = info;
-	info->ident = strdup(name);
-
-	info->parent = parent;
-	info->file = file;
-
-	append_file(profile, info);
-	return info;
-}
-
-/*
- * Free file_info list
- */
-static void
-free_file_list(struct file_info **list)
-{
-	struct file_info	*fi;
-
-	while ((fi = *list) != NULL) {
-		*list = fi->next;
-
-		if (fi->dont_free == 0)
-			sc_file_free(fi->file);
-		free(fi->profile_extension);
-		free(fi->ident);
-		free(fi);
-	}
-}
-
-/*
- * Create a new file info object.
- * This function is called by the profile parser.
- */
-static struct file_info *
-new_file(struct state *cur, const char *name, unsigned int type)
-{
-	sc_profile_t	*profile = cur->profile;
-	struct file_info	*info;
-	sc_file_t	*file;
-	unsigned int	df_type = 0, dont_free = 0;
-	int	free_file = 0;
-
-	if ((info = sc_profile_find_file(profile, NULL, name)) != NULL)
-		return info;
-
-	/* Special cases for those EFs handled separately
-	 * by the PKCS15 logic */
-	if (strncasecmp(name, "PKCS15-", 7)) {
-		file = init_file(type);
-		free_file = 1;
-	} else if (!strcasecmp(name+7, "TokenInfo")) {
-		if (!profile->p15_spec) {
-			parse_error(cur, "no pkcs15 spec in profile");
-			return NULL;
-		}
-		file = profile->p15_spec->file_tokeninfo;
-		dont_free = 1;
-	} else if (!strcasecmp(name+7, "ODF")) {
-		if (!profile->p15_spec) {
-			parse_error(cur, "no pkcs15 spec in profile");
-			return NULL;
-		}
-		file = profile->p15_spec->file_odf;
-		dont_free = 1;
-	} else if (!strcasecmp(name+7, "UnusedSpace")) {
-		if (!profile->p15_spec) {
-			parse_error(cur, "no pkcs15 spec in profile");
-			return NULL;
-		}
-		file = profile->p15_spec->file_unusedspace;
-		dont_free = 1;
-	} else if (!strcasecmp(name+7, "AppDF")) {
-		file = init_file(SC_FILE_TYPE_DF);
-		free_file = 1;
-	} else {
-		if (map_str2int(cur, name+7, &df_type, pkcs15DfNames)
-				|| df_type >= SC_PKCS15_DF_TYPE_COUNT)
-			return NULL;
-
-		file = init_file(SC_FILE_TYPE_WORKING_EF);
-		profile->df[df_type] = file;
-		free_file = 1;
-	}
-	assert(file);
-	if (file->type != type) {
-		parse_error(cur, "inconsistent file type (should be %s)",
-			file->type == SC_FILE_TYPE_DF
-				? "DF" : file->type == SC_FILE_TYPE_BSO
-					? "BS0" : "EF");
-		if (free_file)
-			sc_file_free(file);
-		return NULL;
-	}
-
-	info = add_file(profile, name, file, cur->file);
-	if (info == NULL) {
-		parse_error(cur, "memory allocation failed");
-		return NULL;
-	}
-	info->dont_free = dont_free;
-	return info;
-}
-
-static int
-do_file_type(struct state *cur, int argc, char **argv)
-{
-	unsigned int	type;
-
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-
-	if (map_str2int(cur, argv[0], &type, fileTypeNames))
-		return 1;
-	cur->file->file->type = type;
-	return 0;
-}
-
-static int
-do_file_path(struct state *cur, int argc, char **argv)
-{
-	struct sc_file	*file = NULL;
-	struct sc_path	*path = NULL;
-
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-	file = cur->file->file;
-	path = &file->path;
-
-	/* sc_format_path doesn't return an error indication
-	 * when it's unable to parse the path */
-	sc_format_path(argv[0], path);
-	if (!path->len || (path->len & 1)) {
-		parse_error(cur, "Invalid path length\n");
-		return 1;
-	}
-	file->id = (path->value[path->len-2] << 8) | path->value[path->len-1];
-	return 0;
-}
-
-static int
-do_fileid(struct state *cur, int argc, char **argv)
-{
-	struct file_info *fi;
-	struct sc_file	*df, *file = NULL;
-	struct sc_path	temp, *path = NULL;
-
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-	file = cur->file->file;
-	path = &file->path;
-
-	/* sc_format_path doesn't return an error indication
-	 * when it's unable to parse the path */
-	sc_format_path(argv[0], &temp);
-	if (temp.len != 2) {
-		parse_error(cur, "Invalid file ID length\n");
-		return 1;
-	}
-
-	/* Get the DF, if any */
-	if ((fi = cur->file->parent) && (df = fi->file)) {
-		if (!df->path.len && !df->path.aid.len) {
-			parse_error(cur, "No path/fileid set for parent DF\n");
-			return 1;
-		}
-		if (df->path.len + 2 > sizeof(df->path.value)) {
-			parse_error(cur, "File path too long\n");
-			return 1;
-		}
-		*path = df->path;
-	}
-	if (path->len + 2 > sizeof(path->value)) {
-		parse_error(cur, "File path too long\n");
-		return 1;
-	}
-	memcpy(path->value + path->len, temp.value, 2);
-	path->len += 2;
-
-	file->id = (temp.value[0] << 8) | temp.value[1];
-	return 0;
-}
-
-static int
-do_structure(struct state *cur, int argc, char **argv)
-{
-	unsigned int	ef_structure;
-
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-
-	if (map_str2int(cur, argv[0], &ef_structure, fileStructureNames))
-		return 1;
-	cur->file->file->ef_structure = ef_structure;
-	return 0;
-}
-
-static int
-do_size(struct state *cur, int argc, char **argv)
-{
-	unsigned int	size;
-
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-
-	if (get_uint_eval(cur, argc, argv, &size))
-		return 1;
-	cur->file->file->size = size;
-	return 0;
-}
-
-static int
-do_reclength(struct state *cur, int argc, char **argv)
-{
-	unsigned int	reclength;
-
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-
-	if (get_uint(cur, argv[0], &reclength))
-		return 1;
-	cur->file->file->record_length = reclength;
-	return 0;
-}
-
-static int
-do_content(struct state *cur, int argc, char **argv)
-{
-	struct sc_file *file = NULL;
-	size_t len = (strlen(argv[0]) + 1) / 2;
-	int rv = 0;
-
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-	file = cur->file->file;
-
-	free(file->encoded_content);
-
-	file->encoded_content = malloc(len);
-	if (!file->encoded_content)
-		return 1;
-	rv = sc_hex_to_bin(argv[0], file->encoded_content, &len);
-	file->encoded_content_len = len;
-	return rv;
-}
-
-static int
-do_prop_attr(struct state *cur, int argc, char **argv)
-{
-	struct sc_file *file = NULL;
-	size_t len = (strlen(argv[0]) + 1) / 2;
-	int rv = 0;
-
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-	file = cur->file->file;
-
-	free(file->prop_attr);
-	file->prop_attr = malloc(len);
-	if (!file->prop_attr)
-		return 1;
-	rv = sc_hex_to_bin(argv[0], file->prop_attr, &len);
-	file->prop_attr_len = len;
-	return rv;
-}
-
-static int
-do_aid(struct state *cur, int argc, char **argv)
-{
-	struct sc_file	*file = NULL;
-	const char	*name = argv[0];
-	unsigned int	len;
-	int		res = 0;
-
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-	file = cur->file->file;
-
-	if (*name == '=') {
-		len = strlen(++name);
-		if (len > sizeof(file->name)) {
-			parse_error(cur, "AID \"%s\" too long\n", name);
-			return 1;
-		}
-		memcpy(file->name, name, len);
-		file->namelen = len;
-	}
-	else {
-		file->namelen = sizeof(file->name);
-		res = sc_hex_to_bin(name, file->name, &file->namelen);
-	}
-	return res;
-}
-
-static int
-do_exclusive_aid(struct state *cur, int argc, char **argv)
-{
-	struct sc_file	*file = NULL;
-	const char	*name = argv[0];
-	unsigned int	len;
-	int		res = 0;
-
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-	file = cur->file->file;
-
-#ifdef DEBUG_PROFILE
-	printf("do_exclusive_aid(): exclusive-aid '%s'\n", name);
-	printf("do_exclusive_aid(): current file '%s' (path:%s)\n", cur->file->ident, sc_print_path(&file->path));
-#endif
-	sc_format_path(name, &file->path);
-	if (file->path.len > SC_MAX_AID_SIZE)   {
-		parse_error(cur, "Path length is too big\n");
-		return 1;
-	}
-
-	memcpy(file->path.aid.value, file->path.value, file->path.len);
-	file->path.aid.len = file->path.len;
-
-	file->path.len = 0;
-	file->path.type = SC_PATH_TYPE_DF_NAME;
-
-#ifdef DEBUG_PROFILE
-	printf("do_exclusive_aid(): '%s' exclusive-aid path %s\n", cur->file->ident, sc_print_path(&file->path));
-#endif
-	if (*name == '=') {
-		len = strlen(++name);
-		if (len > sizeof(file->name)) {
-			parse_error(cur, "AID \"%s\" too long\n", name);
-			return 1;
-		}
-		memcpy(file->name, name, len);
-		file->namelen = len;
-	}
-	else {
-		file->namelen = sizeof(file->name);
-		res = sc_hex_to_bin(name, file->name, &file->namelen);
-	}
-	return res;
-}
-
-static int
-do_profile_extension(struct state *cur, int argc, char **argv)
-{
-	if (!cur->file) {
-		parse_error(cur, "Invalid state\n");
-		return 1;
-	}
-	return setstr(&cur->file->profile_extension, argv[0]);
-}
-
-/*
- * Parse ACL list.
- * The way we do this is we first split things like CHV1
- * into a method (SC_AC_CHV) and a reference (1).
- * When we're finished parsing the profile, the fake references
- * are replaced by the real references given in KEY or PIN
- * commands
- */
-static int
-do_acl(struct state *cur, int argc, char **argv)
-{
-	struct sc_file	*file = NULL;
-	char		oper[64], *what = NULL;
-	memset(oper, 0, sizeof(oper));
-
-	if (!cur->file)
-		goto bad;
-	file = cur->file->file;
-
-	while (argc--) {
-		unsigned int	op, method, id;
-
-		if (strlen(*argv) >= sizeof(oper))
-			goto bad;
-		strlcpy(oper, *argv++, sizeof(oper));
-
-		if ((what = strchr(oper, '=')) == NULL)
-			goto bad;
-		*what++ = '\0';
-
-		if (*what == '$') {
-			method = SC_AC_SYMBOLIC;
-			if (map_str2int(cur, what+1, &id, pinIdNames))
-				return 1;
-		}
-		else if (get_authid(cur, what, &method, &id))
-			goto bad;
-
-
-		if (!strcmp(oper, "*")) {
-			for (op = 0; op < SC_MAX_AC_OPS; op++) {
-				sc_file_clear_acl_entries(file, op);
-				sc_file_add_acl_entry(file, op, method, id);
-			}
-		} else {
-			const sc_acl_entry_t *acl;
-
-			if (map_str2int(cur, oper, &op, fileOpNames))
-				goto bad;
-			if (!(acl = sc_file_get_acl_entry(file, op)))
-				goto bad;
-			if (acl->method == SC_AC_NEVER
-			 || acl->method == SC_AC_NONE
-			 || acl->method == SC_AC_UNKNOWN)
-				sc_file_clear_acl_entries(file, op);
-
-			sc_file_add_acl_entry(file, op, method, id);
-		}
-	}
-	return 0;
-
-bad:	parse_error(cur,
-		"Invalid ACL \"%s%s%s\"\n",
-		oper, what? "=" : "", what? what : "");
-	return 1;
-}
-
-static int
-process_pin(struct state *cur, struct block *info,
-		const char *name, scconf_block *blk)
-{
-	struct state	state;
-	unsigned int	id;
-
-	if (map_str2int(cur, name, &id, pinIdNames))
-		return 1;
-
-	init_state(cur, &state);
-	state.pin = new_pin(cur->profile, (int)id);
-
-	return process_block(&state, info, name, blk);
-}
-
-static struct pin_info *
-new_pin(struct sc_profile *profile, int id)
-{
-	struct pin_info	*pi, **tail;
-
-	for (tail = &profile->pin_list; (pi = *tail); tail = &pi->next) {
-		if (pi->id == id)
-			return pi;
-	}
-
-	/* Create pin info object. Most values are
-	 * set to their defaults in set_pin_defaults later
-	 * We can't do this here because these pin info objects
-	 * are usually created before we've read the card specific
-	 * profile
-	 */
-	pi = calloc(1, sizeof(*pi));
-	if (pi == NULL)
-		return NULL;
-	pi->id = id;
-	pi->pin.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
-	pi->pin.auth_method = SC_AC_CHV;
-	pi->pin.attrs.pin.type = (unsigned int)-1;
-	pi->pin.attrs.pin.flags = 0x32;
-	pi->pin.attrs.pin.max_length = 0;
-	pi->pin.attrs.pin.min_length = 0;
-	pi->pin.attrs.pin.stored_length = 0;
-	pi->pin.attrs.pin.pad_char = 0xA5;
-	pi->pin.attrs.pin.reference = -1;
-	pi->pin.tries_left = 3;
-
-	*tail = pi;
-	return pi;
-}
-
-static void set_pin_defaults(struct sc_profile *profile, struct pin_info *pi)
-{
-	struct sc_pkcs15_auth_info *info = &pi->pin;
-	struct sc_pkcs15_pin_attributes *pin_attrs = &info->attrs.pin;
-
-	info->auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
-
-	if (pin_attrs->type == (unsigned int) -1)
-		pin_attrs->type = profile->pin_encoding;
-	if (pin_attrs->max_length == 0)
-		pin_attrs->max_length = profile->pin_maxlen;
-	if (pin_attrs->min_length == 0)
-		pin_attrs->min_length = profile->pin_minlen;
-	if (pin_attrs->stored_length == 0) {
-		pin_attrs->stored_length = profile->pin_maxlen;
-		/* BCD encoded PIN takes half the space */
-		if (pin_attrs->type == SC_PKCS15_PIN_TYPE_BCD)
-			pin_attrs->stored_length = (pin_attrs->stored_length + 1) / 2;
-	}
-	if (pin_attrs->pad_char == 0xA5)
-		pin_attrs->pad_char = profile->pin_pad_char;
-}
-
-static int
-do_pin_file(struct state *cur, int argc, char **argv)
-{
-	free(cur->pin->file_name);
-	cur->pin->file_name = strdup(argv[0]);
-	return 0;
-}
-
-static int
-do_pin_offset(struct state *cur, int argc, char **argv)
-{
-	return get_uint(cur, argv[0], &cur->pin->file_offset);
-}
-
-static int
-do_pin_attempts(struct state *cur, int argc, char **argv)
-{
-	struct pin_info	*pi = cur->pin;
-	unsigned int	count;
-
-	if (get_uint(cur, argv[0], &count))
-		return 1;
-	pi->pin.tries_left = count;
-	return 0;
-}
-
-static int
-do_pin_maxunlocks(struct state *cur, int argc, char **argv)
-{
-	struct pin_info	*pi = cur->pin;
-	unsigned int	count;
-
-	if (get_uint(cur, argv[0], &count))
-		return 1;
-	pi->pin.max_unlocks = count;
-	return 0;
-}
-
-static int
-do_pin_type(struct state *cur, int argc, char **argv)
-{
-	unsigned int	type;
-
-	if (map_str2int(cur, argv[0], &type, pinTypeNames))
-		return 1;
-	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
-		return 1;
-	cur->pin->pin.attrs.pin.type = type;
-	return 0;
-}
-
-static int
-do_pin_reference(struct state *cur, int argc, char **argv)
-{
-	unsigned int	reference;
-
-	if (get_uint(cur, argv[0], &reference))
-		return 1;
-	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
-		return 1;
-	cur->pin->pin.attrs.pin.reference = reference;
-	return 0;
-}
-
-static int
-do_pin_authid(struct state *cur, int argc, char **argv)
-{
-	sc_pkcs15_format_id(argv[0], &cur->pin->pin.auth_id);
-	return 0;
-}
-
-static int
-do_pin_minlength(struct state *cur, int argc, char **argv)
-{
-	unsigned int	len;
-
-	if (get_uint(cur, argv[0], &len))
-		return 1;
-	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
-		return 1;
-	cur->pin->pin.attrs.pin.min_length = len;
-	return 0;
-}
-
-static int
-do_pin_maxlength(struct state *cur, int argc, char **argv)
-{
-	unsigned int	len;
-
-	if (get_uint(cur, argv[0], &len))
-		return 1;
-	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
-		return 1;
-	cur->pin->pin.attrs.pin.max_length = len;
-	return 0;
-}
-
-static int
-do_pin_storedlength(struct state *cur, int argc, char **argv)
-{
-	unsigned int	len;
-
-	if (get_uint(cur, argv[0], &len))
-		return 1;
-	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
-		return 1;
-	cur->pin->pin.attrs.pin.stored_length = len;
-	return 0;
-}
-
-static int
-do_pin_flags(struct state *cur, int argc, char **argv)
-{
-	unsigned int	flags;
-	int		i, r;
-
-	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
-		return -1;
-
-	cur->pin->pin.attrs.pin.flags = 0;
-	for (i = 0; i < argc; i++) {
-		if ((r = map_str2int(cur, argv[i], &flags, pinFlagNames)) < 0)
-			return r;
-		cur->pin->pin.attrs.pin.flags |= flags;
-	}
-
-	return 0;
-}
-
-static int
-process_macros(struct state *cur, struct block *info,
-		const char *dummy, scconf_block *blk)
-{
-	scconf_item	*item;
-	const char	*name;
-	int		 r;
-
-	for (item = blk->items; item; item = item->next) {
-		name = item->key;
-		if (item->type != SCCONF_ITEM_TYPE_VALUE || !name)
-			continue;
-#ifdef DEBUG_PROFILE
-		printf("Defining %s\n", name);
-#endif
-		r = new_macro(cur->profile, name, item->value.list);
-		if (r != SC_SUCCESS)
-			return r;
-	}
-
-	return SC_SUCCESS;
-}
-
-static int
-new_macro(sc_profile_t *profile, const char *name, scconf_list *value)
-{
-	sc_macro_t	*mac;
-
-	if (!profile || !name || !value)
-		return SC_ERROR_INVALID_ARGUMENTS;
-
-	if ((mac = find_macro(profile, name)) == NULL) {
-		mac = calloc(1, sizeof(*mac));
-		if (mac == NULL)
-			return SC_ERROR_OUT_OF_MEMORY;
-		mac->name = strdup(name);
-		mac->next = profile->macro_list;
-		profile->macro_list = mac;
-	}
-
-	mac->value = value;
-	return SC_SUCCESS;
-}
-
-static sc_macro_t *
-find_macro(sc_profile_t *profile, const char *name)
-{
-	sc_macro_t	*mac;
-
-	for (mac = profile->macro_list; mac; mac = mac->next) {
-		if (!strcmp(mac->name, name))
-			return mac;
-	}
-	return NULL;
-}
-
-/*
- * Key section
- */
-static struct command	key_commands[] = {
- { "value",		1,	1,	do_key_value	},
- { NULL, 0, 0, NULL }
-};
-
-/*
- * Cardinfo section
- */
-static struct command	ci_commands[] = {
- { "driver",		1,	1,	do_card_driver	},
- { "max-pin-length",	1,	1,	do_maxpinlength	},
- { "min-pin-length",	1,	1,	do_minpinlength	},
- { "pin-encoding",	1,	1,	do_default_pin_type },
- { "pin-pad-char",	1,	1,	do_pin_pad_char },
- { "pin-domains",	1,	1,	do_pin_domains	},
- { "label",		1,	1,	do_card_label	},
- { "manufacturer",	1,	1,	do_card_manufacturer},
-
- { NULL, 0, 0, NULL }
-};
-
-static struct block	ci_blocks[] = {
- { "key",		process_key,	key_commands,	NULL	},
-
- { NULL, NULL, NULL, NULL }
-};
-
-/*
- * Filesystem section
- */
-static struct command	fs_commands[] = {
- { "type",		1,	1,	do_file_type	},
- { "path",		1,	1,	do_file_path	},
- { "file-id",		1,	1,	do_fileid	},
- { "structure",		1,	1,	do_structure	},
- { "size",		1,	-1,	do_size		},
- { "record-length",	1,	1,	do_reclength	},
- { "AID",		1,	1,	do_aid		},
- { "ACL",		1,	-1,	do_acl		},
-/* AID dependent sub-profile */
- { "profile-extension",	1,	1,	do_profile_extension	},
-/* AID of the DFs without file-id */
- { "exclusive-aid",	1,	1,	do_exclusive_aid	},
- { "content",		1,	1,	do_content	},
- { "prop-attr",		1,	1,	do_prop_attr	},
-
- { NULL, 0, 0, NULL }
-};
-
-static struct block	fs_blocks[] = {
- { "DF",		process_df,	fs_commands,	fs_blocks },
- { "EF",		process_ef,	fs_commands,	fs_blocks },
- { "BSO",		process_bso,	fs_commands,	fs_blocks },
- { "template",		process_tmpl,	fs_commands,	fs_blocks },
-
- { NULL, NULL, NULL, NULL }
-};
-
-/*
- * Pin section
- */
-static struct command	pi_commands[] = {
- { "file",		1,	1,	do_pin_file		},
- { "offset",		1,	1,	do_pin_offset		},
- { "attempts",		1,	2,	do_pin_attempts		},
- { "encoding",		1,	1,	do_pin_type		},
- { "reference",		1,	1,	do_pin_reference	},
- { "auth-id",		1,	1,	do_pin_authid		},
- { "max-length",	1,	1,	do_pin_maxlength	},
- { "min-length",	1,	1,	do_pin_minlength	},
- { "stored-length",	1,	1,	do_pin_storedlength	},
- { "max-unlocks",	1,	1,	do_pin_maxunlocks	},
- { "flags",		1,	-1,	do_pin_flags		},
- { NULL, 0, 0, NULL }
-};
-
-/*
- * pkcs15 dialect section
- */
-static struct command	p15_commands[] = {
- { "direct-certificates",	1,	1,	do_direct_certificates },
- { "encode-df-length",		1,	1,	do_encode_df_length },
- { "do-last-update",		1,	1,	do_encode_update_field },
- { "pkcs15-id-style",		1,	1,	do_pkcs15_id_style },
- { "minidriver-support-style",	1,	1,	do_minidriver_support_style },
- { NULL, 0, 0, NULL }
-};
-
-static struct block	root_blocks[] = {
- { "filesystem",	process_block,	NULL,		fs_blocks },
- { "cardinfo",		process_block,	ci_commands,	ci_blocks },
- { "pin",		process_pin,	pi_commands,	NULL	},
- { "option",		process_option,	NULL,		root_blocks },
- { "macros",		process_macros,	NULL,		NULL	},
- { "pkcs15",		process_block,	p15_commands,	NULL	},
-
- { NULL, NULL, NULL, NULL }
-};
-
-static struct block	root_ops = {
-   "root",		process_block,	NULL,		root_blocks
-};
-
-static int
-is_macro_character(char c) {
-	if (isalnum(c) || c == '-' || c == '_')
-		return 1;
-	return 0;
-}
-
-static void
-get_inner_word(char *str, char word[WORD_SIZE]) {
-	char *inner = NULL;
-	size_t len = 0;
-
-	inner = str;
-	while (is_macro_character(*inner)) {
-		inner++;
-		len++;
-	}
-	len = len >= WORD_SIZE ? WORD_SIZE - 1 : len;
-	memcpy(word, str, len);
-	word[len] = '\0';
-}
-
-/*
- * Checks for a reference loop for macro named start_name in macro definitions.
- * Function returns 1 if a reference loop is detected, 0 otherwise.
- */
-static int
-check_macro_reference_loop(const char *start_name, sc_macro_t *macro, sc_profile_t *profile, int depth) {
-	char *macro_value = NULL;
-	char *name = NULL;
-	char word[WORD_SIZE];
-
-	if (!start_name || !macro || !profile || depth == 16)
-		return 1;
-
-	/* Find name in macro value */
-	macro_value = macro->value->data;
-	if (!(name = strchr(macro_value, '$')))
-		return 0;
-	/* Extract the macro name from the string */
-	get_inner_word(name + 1, word);
-	/* Find whether name corresponds to some other macro */
-	if (!(macro = find_macro(profile, word)))
-		return 0;
-	/* Check for loop */
-	if (!strcmp(macro->name, start_name))
-		return 1;
-	return check_macro_reference_loop(start_name, macro, profile, depth + 1);
-}
-
-static int
-build_argv(struct state *cur, const char *cmdname,
-		scconf_list *list, char **argv, unsigned int max)
-{
-	unsigned int	argc;
-	const char	*str;
-	sc_macro_t	*macro;
-	int		r;
-
-	for (argc = 0; list; list = list->next) {
-		if (argc >= max) {
-			parse_error(cur, "%s: too many arguments", cmdname);
-			return SC_ERROR_INVALID_ARGUMENTS;
-		}
-
-		str = list->data;
-		if (str[0] != '$') {
-			/* When str contains macro inside, macro reference loop needs to be checked */
-			char *macro_name = NULL;
-			if ((macro_name = strchr(str, '$'))) {
-				/* Macro does not to start at the first position */
-				char word[WORD_SIZE];
-				get_inner_word(macro_name + 1, word);
-				if ((macro = find_macro(cur->profile, word))
-				    && check_macro_reference_loop(macro->name, macro, cur->profile, 0)) {
-					return SC_ERROR_SYNTAX_ERROR;
-				}
-			}
-
-			argv[argc++] = list->data;
-			continue;
-		}
-
-		/* Expand macro reference */
-		if (!(macro = find_macro(cur->profile, str + 1))) {
-			parse_error(cur, "%s: unknown macro \"%s\"",
-					cmdname, str);
-			return SC_ERROR_SYNTAX_ERROR;
-		}
-
-		if (list == macro->value) {
-			return SC_ERROR_SYNTAX_ERROR;
-		}
-		if (check_macro_reference_loop(macro->name, macro, cur->profile, 0)) {
-			return SC_ERROR_SYNTAX_ERROR;
-		}
-#ifdef DEBUG_PROFILE
-		{
-			scconf_list *list;
-
-			printf("Expanding macro %s:", mac->name);
-			for (list = mac->value; list; list = list->next)
-				printf(" %s", list->data);
-			printf("\n");
-		}
-#endif
-		r = build_argv(cur, cmdname, macro->value,
-				argv + argc, max - argc);
-		if (r < 0)
-			return r;
-
-		argc += r;
-	}
-
-	return argc;
-}
-
-static int
-process_command(struct state *cur, struct command *cmd_info, scconf_list *list)
-{
-	const char	*cmd = cmd_info->name;
-	char		*argv[32];
-	int		argc, max = 32;
-
-	if (cmd_info->max_args >= 0 && max > cmd_info->max_args)
-		max = cmd_info->max_args;
-
-	if ((argc = build_argv(cur, cmd, list, argv, max)) < 0)
-		return argc;
-
-	if (argc < cmd_info->min_args) {
-		parse_error(cur, "%s: not enough arguments\n", cmd);
-		return 1;
-	}
-	return cmd_info->func(cur, argc, argv);
-}
-
-static struct block *
-find_block_handler(struct block *bp, const char *name)
-{
-	if (bp == NULL)
-		return NULL;
-	for (; bp->name; bp++) {
-		if (!strcasecmp(bp->name, name))
-			return bp;
-	}
-	return NULL;
-}
-
-static struct command *
-find_cmd_handler(struct command *cp, const char *name)
-{
-	if (cp == NULL)
-		return NULL;
-	for (; cp->name; cp++) {
-		if (!strcasecmp(cp->name, name))
-			return cp;
-	}
-	return NULL;
-}
-
-static int
-process_block(struct state *cur, struct block *info,
-		const char *name, scconf_block *blk)
-{
-	scconf_item	*item;
-	struct command	*cp;
-	struct block	*bp;
-	const char	*cmd, *ident;
-	int		res = 0;
-
-	for (item = blk->items; res == 0 && item; item = item->next) {
-		cmd = item->key;
-		if (item->type == SCCONF_ITEM_TYPE_COMMENT)
-			continue;
-		if (!cmd) {
-			parse_error(cur, "Command can not be processed.");
-			return SC_ERROR_SYNTAX_ERROR;
-		}
-		if (item->type == SCCONF_ITEM_TYPE_BLOCK) {
-			scconf_list *nlist;
-
-			ident = NULL;
-			if ((nlist = item->value.block->name) != NULL) {
-				if (nlist->next) {
-					parse_error(cur, "Too many name components in block name.");
-					return SC_ERROR_SYNTAX_ERROR;
-				}
-				ident = nlist->data;
-			}
-#ifdef DEBUG_PROFILE
-			printf("Processing %s %s\n", cmd, ident? ident : "");
-#endif
-			if ((bp = find_block_handler(info->blk_info, cmd))) {
-				res = bp->handler(cur, bp, ident, item->value.block);
-				continue;
-			}
-		}
-		else if (item->type == SCCONF_ITEM_TYPE_VALUE) {
-#ifdef DEBUG_PROFILE
-			printf("Processing %s\n", cmd);
-#endif
-			if ((cp = find_cmd_handler(info->cmd_info, cmd))) {
-				res = process_command(cur, cp, item->value.list);
-				continue;
-			}
-		}
-		parse_error(cur, "Command \"%s\" not understood in this context.", cmd);
-		return SC_ERROR_SYNTAX_ERROR;
-	}
-
-	if (res > 0)
-		res = SC_ERROR_SYNTAX_ERROR;
-	return res;
-}
-
-static int
-process_conf(struct sc_profile *profile, scconf_context *conf)
-{
-	struct state	state;
-
-	memset(&state, 0, sizeof(state));
-	state.filename = conf->filename;
-	state.profile = profile;
-	return process_block(&state, &root_ops, "root", conf->root);
-}
-
-static struct file_info *
-sc_profile_find_file(struct sc_profile *pro,
-		const sc_path_t *path, const char *name)
-{
-	struct file_info	*fi;
-	unsigned int		len;
-	const u8			*value;
-
-	value = path ? path->value : (const u8*) "";
-	len = path ? path->len : 0;
-	for (fi = pro->ef_list; fi; fi = fi->next) {
-		sc_path_t *fpath = &fi->file->path;
-
-		if (!strcasecmp(fi->ident, name) && fpath->len >= len && !memcmp(fpath->value, value, len))
-			return fi;
-	}
-	return NULL;
-}
-
-
-static struct file_info *
-sc_profile_find_file_by_path(struct sc_profile *pro, const sc_path_t *path)
-{
-	struct file_info *fi, *out = NULL;
-	struct sc_path *fp_path, *fpp_path;
-
-#ifdef DEBUG_PROFILE
-	struct sc_context *ctx = pro->card->ctx;
-
-	sc_log(ctx, "profile's EF list:");
-	for (fi = pro->ef_list; fi; fi = fi->next)   {
-		sc_log(ctx, "'%s' (path:%s)",  fi->ident, sc_print_path(&fi->file->path));
-		sc_log(ctx, "fi parent %p", fi->parent);
-		if (fi->parent && fi->parent->file)
-			sc_log(ctx, "fi parent path %s", sc_print_path(&fi->parent->file->path));
-	}
-	sc_log(ctx, "find profile file by path:%s", sc_print_path(path));
-#endif
-
-	if (!path || (!path->len && !path->aid.len))
-		return NULL;
-
-	for (fi = pro->ef_list; fi; fi = fi->next) {
-		fp_path = &fi->file->path;
-		fpp_path = fi->parent ? &fi->parent->file->path : NULL;
-
-		if (fp_path->len != path->len)
-			continue;
-		if (fp_path->len && memcmp(fp_path->value, path->value, path->len))
-			continue;
-
-		if (path->aid.len && fp_path->aid.len)   {
-			if (memcmp(fp_path->aid.value, path->aid.value, path->aid.len))
-				continue;
-		}
-		else if (path->aid.len && !fp_path->aid.len && fpp_path)   {
-			if (fpp_path->type == SC_PATH_TYPE_DF_NAME && fpp_path->len)   {
-				if (fpp_path->len != path->aid.len)
-					continue;
-				if (memcmp(fpp_path->value, path->aid.value, path->aid.len))
-					continue;
-			}
-			else if (fpp_path->aid.len)   {
-				if (fpp_path->aid.len != path->aid.len)
-					continue;
-				if (memcmp(fpp_path->aid.value, path->aid.value, path->aid.len))
-					continue;
-			}
-		}
-
-		out = fi;
-	}
-
-#ifdef DEBUG_PROFILE
-	sc_log(ctx, "returns (%s)", out ? out->ident: "<null>");
-#endif
-	return out;
-}
-
-int
-sc_profile_get_parent(struct sc_profile *profile,
-		const char *name, sc_file_t **ret)
-{
-	struct file_info *fi = NULL;
-
-	if ((fi = sc_profile_find_file(profile, NULL, name)) == NULL)
-		return SC_ERROR_FILE_NOT_FOUND;
-
-	if (!fi->parent)
-		return SC_ERROR_FILE_NOT_FOUND;
-
-	sc_file_dup(ret, fi->parent->file);
-	if (*ret == NULL)
-		return SC_ERROR_OUT_OF_MEMORY;
-	return 0;
-}
-
-/*
- * Split up KEY0 or CHV1 into SC_AC_XXX and a number
- */
-static int
-get_authid(struct state *cur, const char *value,
-		unsigned int *type, unsigned int *num)
-{
-	char	temp[16];
-	size_t	n;
-
-	if (isdigit((unsigned char) *value)) {
-		*num = 0;
-		return get_uint(cur, value, type);
-	}
-
-	if (strlen(value) >= sizeof(temp))
-		return 1;
-
-	n = strcspn(value, "0123456789x");
-	strlcpy(temp, value, (sizeof(temp) > n) ? n + 1 : sizeof(temp));
-
-	if (map_str2int(cur, temp, type, aclNames))
-		return 1;
-	if (value[n])
-		return get_uint(cur, value + n, num);
-	*num = 0;
-	return 0;
-}
-
-static int
-get_uint(struct state *cur, const char *value, unsigned int *vp)
-{
-	char	*ep;
-
-	if (strstr(value, "0x") == value)
-		*vp = strtoul(value + 2, &ep, 16);
-	else if (strstr(value, "x") == value)
-		*vp = strtoul(value + 1, &ep, 16);
-	else
-		*vp = strtoul(value, &ep, 0);
-	if (*ep != '\0') {
-		parse_error(cur, "invalid integer argument \"%s\"\n", value);
-		return 1;
-	}
-	return 0;
-}
-
-static int
-get_bool(struct state *cur, const char *value, unsigned int *vp)
-{
-	if (!strcasecmp(value, "on")
-	 || !strcasecmp(value, "yes")
-	 || !strcasecmp(value, "true")) {
-		*vp = 1;
-	} else
-	if (!strcasecmp(value, "off")
-	 || !strcasecmp(value, "no")
-	 || !strcasecmp(value, "false")) {
-		*vp = 0;
-	} else {
-		parse_error(cur, "invalid boolean argument \"%s\"\n", value);
-		return 1;
-	}
-	return 0;
-}
-
-static int
-map_str2int(struct state *cur, const char *value,
-		unsigned int *vp, struct map *map)
-{
-	unsigned int	n;
-	const char	*what;
-
-	if (isdigit((unsigned char) *value))
-		return get_uint(cur, value, vp);
-	for (n = 0; map[n].name; n++) {
-		if (!strcasecmp(value, map[n].name)) {
-			*vp = map[n].val;
-			return 0;
-		}
-	}
-
-	/* Try to print a meaningful error message */
-	what = "argument";
-	for (n = 0; mapNames[n].name; n++) {
-		if (mapNames[n].addr == map) {
-			what = mapNames[n].name;
-			break;
-		}
-	}
-
-	parse_error(cur, "invalid %s \"%s\"\n", what, value);
-	return SC_ERROR_SYNTAX_ERROR;
-}
-
-static int
-setstr(char **strp, const char *value)
-{
-	if (*strp)
-		free(*strp);
-	*strp = strdup(value);
-	return 0;
-}
-
-/*
- * Evaluate numeric expressions
- */
-#include <setjmp.h>
-
-struct num_exp_ctx {
-	struct state *	state;
-	jmp_buf		error;
-
-	int		j;
-	char		word[WORD_SIZE];
-
-	char *		unget;
-	char *		str;
-	int		argc;
-	char **		argv;
-};
-
-static void	expr_eval(struct num_exp_ctx *, unsigned int *, unsigned int, int);
-
-static void
-expr_fail(struct num_exp_ctx *ctx)
-{
-	longjmp(ctx->error, 1);
-}
-
-static void
-expr_put(struct num_exp_ctx *ctx, int c)
-{
-	if (ctx->j >= (int)sizeof(ctx->word))
-		expr_fail(ctx);
-	ctx->word[ctx->j++] = (char)c;
-}
-
-static char *
-__expr_get(struct num_exp_ctx *ctx, int eof_okay)
-{
-	char	*s;
-
-	if ((s = ctx->unget) != NULL) {
-		ctx->unget = NULL;
-		return s;
-	}
-
-	ctx->j = 0;
-	s = ctx->str;
-	do {
-		if (s == NULL || *s == '\0') {
-			if (ctx->argc == 0) {
-				if (eof_okay)
-					return NULL;
-				expr_fail(ctx);
-			}
-			ctx->str = s = *(ctx->argv++);
-			ctx->argc--;
-		}
-
-		while (isspace((unsigned char)*s))
-			s++;
-	} while (*s == '\0');
-
-	if (isdigit((unsigned char)*s)) {
-		while (isdigit((unsigned char)*s))
-			expr_put(ctx, *s++);
-	}
-	else if (*s == '$') {
-		expr_put(ctx, *s++);
-		while (is_macro_character(*s))
-			expr_put(ctx, *s++);
-	}
-	else if (strchr("*/+-()|&", *s)) {
-		expr_put(ctx, *s++);
-	}
-	else {
-		expr_fail(ctx);
-	}
-	ctx->str = s;
-
-	expr_put(ctx, '\0');
-	return ctx->word;
-}
-
-static char *
-expr_get(struct num_exp_ctx *ctx)
-{
-	return __expr_get(ctx, 0);
-}
-
-static void
-expr_unget(struct num_exp_ctx *ctx, char *s)
-{
-	if (ctx->unget)
-		expr_fail(ctx);
-	ctx->unget = s;
-}
-
-static void
-expr_expect(struct num_exp_ctx *ctx, int c)
-{
-	char	*tok;
-
-	tok = expr_get(ctx);
-	if (tok[0] != (char)c || tok[1])
-		expr_fail(ctx);
-}
-
-#define MAX_BRACKETS 32
-static void
-expr_term(struct num_exp_ctx *ctx, unsigned int *vp, int opening_brackets)
-{
-	char	*tok;
-
-	tok = expr_get(ctx);
-	if (*tok == '(') {
-		if (opening_brackets + 1 > MAX_BRACKETS) {
-			parse_error(ctx->state, "Too many \"%s\" in expression", tok);
-			expr_fail(ctx);
-		}
-		expr_eval(ctx, vp, 1, opening_brackets + 1);
-		expr_expect(ctx, ')');
-	}
-	else if (isdigit((unsigned char)*tok)) {
-		char	*ep;
-
-		*vp = strtoul(tok, &ep, 0);
-		if (*ep)
-			expr_fail(ctx);
-	}
-	else if (*tok == '$') {
-		sc_macro_t	*mac;
-		char		*argv[32];
-		int		argc;
-
-		if (!(mac = find_macro(ctx->state->profile, tok + 1)))
-			expr_fail(ctx);
-		argc = build_argv(ctx->state, "<expr>", mac->value, argv, 32);
-		if (argc < 0 || get_uint_eval(ctx->state, argc, argv, vp) < 0)
-			expr_fail(ctx);
-	}
-	else {
-		parse_error(ctx->state, "Unexpected token \"%s\" in expression", tok);
-		expr_fail(ctx);
-	}
-}
-
-static void
-expr_eval(struct num_exp_ctx *ctx, unsigned int *vp, unsigned int pri, int opening_brackets)
-{
-	unsigned int	left, right, new_pri;
-	char		*tok, op;
-
-	expr_term(ctx, &left, opening_brackets);
-
-	while (1) {
-		tok = __expr_get(ctx, 1);
-		if (tok == NULL)
-			break;
-
-		op = tok[0];
-
-		new_pri = 0;
-		switch (op) {
-		case '*':
-		case '/':
-			new_pri++;
-			/* fall through */
-		case '+':
-		case '-':
-			new_pri++;
-			/* fall through */
-		case '&':
-			new_pri++;
-			/* fall through */
-		case '|':
-			new_pri++;
-			/* fall through */
-		case ')':
-			break;
-		default:
-			expr_fail(ctx);
-		}
-
-		if (new_pri < pri) {
-			expr_unget(ctx, tok);
-			break;
-		}
-		pri = new_pri;
-
-		expr_eval(ctx, &right, new_pri + 1, opening_brackets);
-		switch (op) {
-		case '*': left *= right; break;
-		case '/':
-			if (right == 0)
-				expr_fail(ctx);
-			left /= right; break;
-		case '+': left += right; break;
-		case '-': left -= right; break;
-		case '&': left &= right; break;
-		case '|': left |= right; break;
-		default: expr_fail(ctx);
-		}
-	}
-
-	*vp = left;
-}
-
-static int
-get_uint_eval(struct state *cur, int argc, char **argv, unsigned int *vp)
-{
-	struct num_exp_ctx	ctx;
-
-	memset(&ctx, 0, sizeof(ctx));
-	ctx.state = cur;
-	ctx.argc  = argc;
-	ctx.argv  = argv;
-
-	if (setjmp(ctx.error)) {
-		parse_error(cur, "invalid numeric expression\n");
-		return SC_ERROR_SYNTAX_ERROR;
-	}
-
-	expr_eval(&ctx, vp, 0, 0);
-	if (ctx.str[0] || ctx.argc)
-		expr_fail(&ctx);
-
-	return 0;
-}
-
-static void
-parse_error(struct state *cur, const char *fmt, ...)
-{
-	char	buffer[1024], *sp;
-	va_list	ap;
-
-	va_start(ap, fmt);
-	vsnprintf(buffer, sizeof(buffer), fmt, ap);
-	va_end(ap);
-
-	if ((sp = strchr(buffer, '\n')) != NULL)
-		*sp = '\0';
-
-	if (cur->profile->card && cur->profile->card->ctx)
-		sc_log(cur->profile->card->ctx, "%s: %s", cur->filename, buffer);
-	else
-		fprintf(stdout, "%s: %s\n", cur->filename, buffer);
-}
+/*
+ * Initialize Cards according to PKCS#15
+ *
+ * Copyright (C) 2002 Olaf Kirch <okir@suse.de>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * Random notes
+ *  -	the "key" command should go away, it's obsolete
+ */
+
+#include "config.h"
+
+#include <stdio.h>
+#include <ctype.h>
+#include <stdarg.h>
+#include <string.h>
+#include <limits.h>
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <assert.h>
+#include <stdlib.h>
+
+#ifdef _WIN32
+#include <windows.h>
+#include <winreg.h>
+#endif
+
+#include "common/compat_strlcpy.h"
+#include "scconf/scconf.h"
+#include "libopensc/log.h"
+#include "libopensc/pkcs15.h"
+#include "pkcs15-init.h"
+#include "profile.h"
+
+#define DEF_PRKEY_RSA_ACCESS	0x1D
+#define DEF_PUBKEY_ACCESS	0x12
+
+#define TEMPLATE_FILEID_MIN_DIFF	0x20
+
+#define WORD_SIZE	64
+
+/*
+#define DEBUG_PROFILE
+*/
+
+/*
+ * Parser state
+ */
+struct state {
+	struct state *		frame;
+	const char *		filename;
+	struct sc_profile *	profile;
+	struct file_info *	file;
+	struct pin_info *	pin;
+	struct auth_info *	key;
+};
+
+
+struct command {
+	const char *		name;
+	int			min_args, max_args;
+	int			(*func)(struct state *, int, char **);
+};
+
+struct block {
+	const char *		name;
+	int			(*handler)(struct state *,
+					struct block *,
+					const char *,
+					scconf_block *);
+	struct command *	cmd_info;
+	struct block *		blk_info;
+};
+
+struct map {
+	const char *		name;
+	unsigned int		val;
+};
+
+static struct map		aclNames[] = {
+	{ "NONE",	SC_AC_NONE	},
+	{ "NEVER",	SC_AC_NEVER	},
+	{ "CHV",	SC_AC_CHV	},
+	{ "TERM",	SC_AC_TERM	},
+	{ "PRO",	SC_AC_PRO	},
+	{ "AUT",	SC_AC_AUT	},
+	{ "KEY",	SC_AC_AUT	},
+	{ "SEN",	SC_AC_SEN	},
+	{ "IDA",	SC_AC_IDA	},
+	{ "SCB",	SC_AC_SCB	},
+	{ NULL, 0 }
+};
+static struct map		fileOpNames[] = {
+	{ "SELECT",	SC_AC_OP_SELECT	},
+	{ "LOCK",	SC_AC_OP_LOCK	},
+	{ "DELETE",	SC_AC_OP_DELETE	},
+	{ "DELETE-SELF",SC_AC_OP_DELETE_SELF },
+	{ "CREATE",	SC_AC_OP_CREATE	},
+	{ "CREATE-EF",	SC_AC_OP_CREATE_EF	},
+	{ "CREATE-DF",	SC_AC_OP_CREATE_DF	},
+	{ "REHABILITATE",SC_AC_OP_REHABILITATE	},
+	{ "INVALIDATE",	SC_AC_OP_INVALIDATE	},
+	{ "FILES",	SC_AC_OP_LIST_FILES	},
+	{ "READ",	SC_AC_OP_READ	},
+	{ "UPDATE",	SC_AC_OP_UPDATE	},
+	{ "WRITE",	SC_AC_OP_WRITE	},
+	{ "ERASE",	SC_AC_OP_ERASE	},
+	{ "CRYPTO",     SC_AC_OP_CRYPTO },
+        { "PIN-DEFINE", SC_AC_OP_PIN_DEFINE },
+        { "PIN-CHANGE", SC_AC_OP_PIN_CHANGE },
+        { "PIN-RESET",  SC_AC_OP_PIN_RESET },
+        { "PIN-USE",	SC_AC_OP_PIN_USE },
+	{ "GENERATE",	SC_AC_OP_GENERATE },
+	{ "PSO-COMPUTE-SIGNATURE",	SC_AC_OP_PSO_COMPUTE_SIGNATURE },
+	{ "INTERNAL-AUTHENTICATE",	SC_AC_OP_INTERNAL_AUTHENTICATE },
+	{ "PSO-DECRYPT",		SC_AC_OP_PSO_DECRYPT },
+	{ "RESIZE",	SC_AC_OP_RESIZE },
+	{ "ADMIN",	SC_AC_OP_ADMIN	},
+	{ "ACTIVATE",	SC_AC_OP_ACTIVATE },
+	{ "DEACTIVATE",	SC_AC_OP_DEACTIVATE },
+	{ NULL, 0 }
+};
+static struct map		fileTypeNames[] = {
+	{ "EF",		SC_FILE_TYPE_WORKING_EF		},
+	{ "INTERNAL-EF",SC_FILE_TYPE_INTERNAL_EF	},
+	{ "DF",		SC_FILE_TYPE_DF			},
+	{ "BSO",	SC_FILE_TYPE_BSO		},
+	{ NULL, 0 }
+};
+static struct map		fileStructureNames[] = {
+	{ "TRANSPARENT",	SC_FILE_EF_TRANSPARENT	},
+	{ "LINEAR-FIXED",	SC_FILE_EF_LINEAR_FIXED	},
+	{ "LINEAR-FIXED-TLV",	SC_FILE_EF_LINEAR_FIXED_TLV	},
+	{ "LINEAR-VARIABLE",	SC_FILE_EF_LINEAR_VARIABLE	},
+	{ "LINEAR-VARIABLE-TLV",SC_FILE_EF_LINEAR_VARIABLE_TLV	},
+	{ "CYCLIC",		SC_FILE_EF_CYCLIC	},
+	{ "CYCLIC-TLV",		SC_FILE_EF_CYCLIC_TLV	},
+	{ NULL, 0 }
+};
+static struct map		pkcs15DfNames[] = {
+	{ "PRKDF",		SC_PKCS15_PRKDF		},
+	{ "PUKDF",		SC_PKCS15_PUKDF		},
+	{ "PUKDF-TRUSTED",	SC_PKCS15_PUKDF_TRUSTED	},
+	{ "SKDF",		SC_PKCS15_SKDF		},
+	{ "CDF",		SC_PKCS15_CDF		},
+	{ "CDF-TRUSTED",	SC_PKCS15_CDF_TRUSTED	},
+	{ "CDF-USEFUL",		SC_PKCS15_CDF_USEFUL	},
+	{ "DODF",		SC_PKCS15_DODF		},
+	{ "AODF",		SC_PKCS15_AODF		},
+	{ NULL, 0 }
+};
+static struct map		pinTypeNames[] = {
+	{ "BCD",		SC_PKCS15_PIN_TYPE_BCD	},
+	{ "ascii-numeric",	SC_PKCS15_PIN_TYPE_ASCII_NUMERIC	},
+	{ "utf8",		SC_PKCS15_PIN_TYPE_UTF8	},
+	{ "half-nibble-bcd",	SC_PKCS15_PIN_TYPE_HALFNIBBLE_BCD	},
+	{ "iso9564-1",		SC_PKCS15_PIN_TYPE_ISO9564_1	},
+	{ NULL, 0 }
+};
+static struct map		pinIdNames[] = {
+	{ "pin",		SC_PKCS15INIT_USER_PIN	},
+	{ "puk",		SC_PKCS15INIT_USER_PUK	},
+	{ "user-pin",		SC_PKCS15INIT_USER_PIN	},
+	{ "user-puk",		SC_PKCS15INIT_USER_PUK	},
+	{ "sopin",		SC_PKCS15INIT_SO_PIN	},
+	{ "sopuk",		SC_PKCS15INIT_SO_PUK	},
+	{ "so-pin",		SC_PKCS15INIT_SO_PIN	},
+	{ "so-puk",		SC_PKCS15INIT_SO_PUK	},
+	{ NULL, 0 }
+};
+static struct map		pinFlagNames[] = {
+	{ "case-sensitive",		SC_PKCS15_PIN_FLAG_CASE_SENSITIVE		},
+	{ "local",			SC_PKCS15_PIN_FLAG_LOCAL			},
+	{ "change-disabled",		SC_PKCS15_PIN_FLAG_CHANGE_DISABLED		},
+	{ "unblock-disabled",		SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED		},
+	{ "initialized",		SC_PKCS15_PIN_FLAG_INITIALIZED			},
+	{ "needs-padding",		SC_PKCS15_PIN_FLAG_NEEDS_PADDING		},
+	{ "unblockingPin",		SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN		},
+	{ "soPin",			SC_PKCS15_PIN_FLAG_SO_PIN			},
+	{ "disable-allowed",		SC_PKCS15_PIN_FLAG_DISABLE_ALLOW		},
+	{ "integrity-protected",	SC_PKCS15_PIN_FLAG_INTEGRITY_PROTECTED		},
+	{ "confidentiality-protected",	SC_PKCS15_PIN_FLAG_CONFIDENTIALITY_PROTECTED	},
+	{ "exchangeRefData",		SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA		},
+	{ NULL, 0 }
+};
+static struct map		idStyleNames[] = {
+	{ "native",		SC_PKCS15INIT_ID_STYLE_NATIVE },
+	{ "mozilla",		SC_PKCS15INIT_ID_STYLE_MOZILLA },
+	{ "rfc2459",		SC_PKCS15INIT_ID_STYLE_RFC2459 },
+	{ NULL, 0 }
+};
+static struct map              mdStyleNames[] = {
+	{ "none",               SC_PKCS15INIT_MD_STYLE_NONE },
+	{ "gemalto",            SC_PKCS15INIT_MD_STYLE_GEMALTO },
+	{ NULL, 0 }
+};
+static struct {
+	const char *		name;
+	struct map *		addr;
+} mapNames[] = {
+	{ "file ACL",		aclNames	},
+	{ "file operation",	fileOpNames	},
+	{ "file type",		fileTypeNames	},
+	{ "file structure",	fileStructureNames},
+	{ "PKCS#15 file name",	pkcs15DfNames	},
+	{ "pin encoding",	pinTypeNames	},
+	{ "pin name",		pinIdNames	},
+	{ "pin flag",		pinFlagNames	},
+	{ NULL, NULL }
+};
+
+static int		process_conf(struct sc_profile *, scconf_context *);
+static int		process_block(struct state *, struct block *,
+				const char *, scconf_block *);
+static void		init_state(struct state *, struct state *);
+static int		get_authid(struct state *, const char *,
+				unsigned int *, unsigned int *);
+static int		get_uint(struct state *, const char *, unsigned int *);
+static int		get_bool(struct state *, const char *, unsigned int *);
+static int		get_uint_eval(struct state *, int, char **,
+				unsigned int *);
+static int		map_str2int(struct state *, const char *,
+				unsigned int *, struct map *);
+static int		setstr(char **strp, const char *value);
+static void		parse_error(struct state *, const char *, ...);
+
+static struct file_info *	sc_profile_instantiate_file(sc_profile_t *,
+				struct file_info *, struct file_info *,
+				unsigned int);
+static struct file_info *	sc_profile_find_file(struct sc_profile *,
+				const sc_path_t *, const char *);
+static struct file_info *	sc_profile_find_file_by_path(
+				struct sc_profile *,
+				const sc_path_t *);
+
+static struct pin_info *	new_pin(struct sc_profile *, int);
+static struct file_info *	new_file(struct state *, const char *,
+				unsigned int);
+static struct file_info *	add_file(sc_profile_t *, const char *,
+				sc_file_t *, struct file_info *);
+static void		free_file_list(struct file_info **);
+static void		append_file(sc_profile_t *, struct file_info *);
+static struct auth_info *	new_key(struct sc_profile *,
+				unsigned int, unsigned int);
+static void		set_pin_defaults(struct sc_profile *,
+				struct pin_info *);
+static int		new_macro(sc_profile_t *, const char *, scconf_list *);
+static sc_macro_t *	find_macro(sc_profile_t *, const char *);
+
+static sc_file_t *
+init_file(unsigned int type)
+{
+	struct sc_file	*file;
+	unsigned int	op;
+
+	file = sc_file_new();
+	for (op = 0; op < SC_MAX_AC_OPS; op++) {
+		sc_file_add_acl_entry(file, op, SC_AC_NONE, 0);
+	}
+	file->type = type;
+	file->status = SC_FILE_STATUS_ACTIVATED;
+	if (file->type != SC_FILE_TYPE_DF && file->type != SC_FILE_TYPE_BSO)
+		file->ef_structure = SC_FILE_EF_TRANSPARENT;
+	return file;
+}
+
+/*
+ * Initialize profile
+ */
+struct sc_profile *
+sc_profile_new(void)
+{
+	struct sc_pkcs15_card *p15card;
+	struct sc_profile *pro;
+
+	pro = calloc(1, sizeof(*pro));
+	if (pro == NULL)
+		return NULL;
+	pro->p15_spec = p15card = sc_pkcs15_card_new();
+
+	pro->pkcs15.do_last_update = 1;
+
+	if (p15card) {
+		p15card->tokeninfo->label = strdup("OpenSC Card");
+		p15card->tokeninfo->manufacturer_id = strdup("OpenSC Project");
+		p15card->tokeninfo->serial_number = strdup("0000");
+		p15card->tokeninfo->flags = SC_PKCS15_TOKEN_EID_COMPLIANT;
+		p15card->tokeninfo->version = 0;
+
+		/* Set up EF(TokenInfo) and EF(ODF) */
+		p15card->file_tokeninfo = init_file(SC_FILE_TYPE_WORKING_EF);
+		p15card->file_odf = init_file(SC_FILE_TYPE_WORKING_EF);
+		p15card->file_unusedspace = init_file(SC_FILE_TYPE_WORKING_EF);
+	}
+
+	/* Assume card does RSA natively */
+	pro->rsa_access_flags = DEF_PRKEY_RSA_ACCESS;
+	pro->pin_encoding = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
+	pro->pin_minlen = 4;
+	pro->pin_maxlen = 8;
+	pro->id_style = SC_PKCS15INIT_ID_STYLE_NATIVE;
+
+	return pro;
+}
+
+int
+sc_profile_load(struct sc_profile *profile, const char *filename)
+{
+	struct sc_context *ctx = profile->card->ctx;
+	scconf_context	*conf;
+	const char *profile_dir = NULL;
+	char path[PATH_MAX];
+	int res = 0, i;
+#ifdef _WIN32
+	char temp_path[PATH_MAX];
+	size_t temp_len;
+#endif
+
+	LOG_FUNC_CALLED(ctx);
+	for (i = 0; ctx->conf_blocks[i]; i++) {
+		profile_dir = scconf_get_str(ctx->conf_blocks[i], "profile_dir", NULL);
+		if (profile_dir)
+			break;
+	}
+
+	if (!profile_dir) {
+#ifdef _WIN32
+		temp_len = PATH_MAX - 1;
+		res = sc_ctx_win32_get_config_value(NULL, "ProfileDir", "Software\\OpenSC Project\\OpenSC",
+				temp_path, &temp_len);
+		if (res)
+			LOG_FUNC_RETURN(ctx, res);
+		temp_path[temp_len] = '\0';
+		profile_dir = temp_path;
+#else
+		profile_dir = SC_PKCS15_PROFILE_DIRECTORY;
+#endif
+	}
+	sc_log(ctx, "Using profile directory '%s'.", profile_dir);
+
+#ifdef _WIN32
+	snprintf(path, sizeof(path), "%s\\%s.%s", profile_dir, filename, SC_PKCS15_PROFILE_SUFFIX);
+#else /* _WIN32 */
+	snprintf(path, sizeof(path), "%s/%s.%s", profile_dir, filename, SC_PKCS15_PROFILE_SUFFIX);
+#endif /* _WIN32 */
+
+	sc_log(ctx, "Trying profile file %s", path);
+
+	conf = scconf_new(path);
+	res = scconf_parse(conf);
+
+	sc_log(ctx, "profile %s loaded ok", path);
+
+	if (res < 0) {
+		scconf_free(conf);
+		LOG_FUNC_RETURN(ctx, SC_ERROR_FILE_NOT_FOUND);
+	}
+
+	if (res == 0) {
+		scconf_free(conf);
+		LOG_FUNC_RETURN(ctx, SC_ERROR_SYNTAX_ERROR);
+	}
+
+	res = process_conf(profile, conf);
+	scconf_free(conf);
+	LOG_FUNC_RETURN(ctx, res);
+}
+
+
+int
+sc_profile_finish(struct sc_profile *profile, const struct sc_app_info *app_info)
+{
+	struct sc_context *ctx = profile->card->ctx;
+	struct file_info *fi;
+	struct pin_info	*pi;
+	char		reason[64];
+
+	LOG_FUNC_CALLED(ctx);
+	profile->mf_info = sc_profile_find_file(profile, NULL, "MF");
+	if (!profile->mf_info)
+		LOG_TEST_RET(ctx, SC_ERROR_INCONSISTENT_PROFILE, "Profile doesn't define a MF");
+
+	if (app_info && app_info->aid.len)   {
+		struct sc_path path;
+
+		sc_log(ctx, "finish profile with '%s' application profile", app_info->label);
+		memset(&path, 0, sizeof(struct sc_path));
+		path.type = SC_PATH_TYPE_DF_NAME;
+		path.aid = app_info->aid;
+
+		sc_log(ctx, "Look for file by path '%s'", sc_print_path(&path));
+		profile->df_info = sc_profile_find_file_by_path(profile, &path);
+		sc_log(ctx, "returned DF info %p", profile->df_info);
+		if (profile->df_info && profile->df_info->profile_extension)   {
+			sc_log(ctx, "application profile extension '%s'", profile->df_info->profile_extension);
+			if (sc_profile_load(profile, profile->df_info->profile_extension))
+				LOG_TEST_RET(ctx, SC_ERROR_INCONSISTENT_PROFILE, "Cannot load application profile extension");
+		}
+	}
+
+	profile->df_info = sc_profile_find_file(profile, NULL, "PKCS15-AppDF");
+	if (!profile->df_info)
+		LOG_TEST_RET(ctx, SC_ERROR_INCONSISTENT_PROFILE, "Profile doesn't define a PKCS15-AppDF");
+
+	profile->p15_spec->file_app = profile->df_info->file;
+	profile->df_info->dont_free = 1;
+
+	for (pi = profile->pin_list; pi; pi = pi->next) {
+		const char	*name;
+
+		set_pin_defaults(profile, pi);
+		if (!(name = pi->file_name))
+			continue;
+		if (!(fi = sc_profile_find_file(profile, NULL, name))) {
+			snprintf(reason, sizeof(reason), "unknown PIN file \"%s\"\n", name);
+			goto whine;
+		}
+
+		pi->file = fi;
+	}
+	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
+
+whine:
+	sc_log(ctx, "%s", reason);
+	LOG_FUNC_RETURN(ctx, SC_ERROR_INCONSISTENT_PROFILE);
+}
+
+void
+sc_profile_free(struct sc_profile *profile)
+{
+	struct auth_info *ai;
+	struct pin_info *pi;
+	sc_macro_t	*mi;
+	sc_template_t	*ti;
+
+	if (profile->name)
+		free(profile->name);
+	if (profile->driver)
+		free(profile->driver);
+
+	free_file_list(&profile->ef_list);
+
+	while ((ai = profile->auth_list) != NULL) {
+		profile->auth_list = ai->next;
+		free(ai);
+	}
+
+	while ((ti = profile->template_list) != NULL) {
+		profile->template_list = ti->next;
+		if (ti->data)
+			sc_profile_free(ti->data);
+		if (ti->name)
+			free(ti->name);
+		free(ti);
+	}
+
+	while ((mi = profile->macro_list) != NULL) {
+		profile->macro_list = mi->next;
+		if (mi->name)
+			free(mi->name);
+		free(mi);
+	}
+
+	while ((pi = profile->pin_list) != NULL) {
+		profile->pin_list = pi->next;
+		if (pi->file_name)
+			free(pi->file_name);
+		free(pi);
+	}
+
+	for (int i = 0; profile->options[i]; i++) {
+		free(profile->options[i]);
+	}
+
+	if (profile->p15_spec)
+		sc_pkcs15_card_free(profile->p15_spec);
+	free(profile);
+}
+
+void
+sc_profile_get_pin_info(struct sc_profile *profile,
+		int id, struct sc_pkcs15_auth_info *info)
+{
+	struct pin_info	*pi;
+
+	pi = new_pin(profile, id);
+	if (pi == NULL)
+		return;
+
+	pi->pin.max_tries = pi->pin.tries_left;
+	*info = pi->pin;
+}
+
+int
+sc_profile_get_pin_retries(sc_profile_t *profile, int id)
+{
+	struct pin_info	*pi;
+
+	pi = new_pin(profile, id);
+	if (pi == NULL)
+		return SC_ERROR_OUT_OF_MEMORY;
+	return pi->pin.tries_left;
+}
+
+int
+sc_profile_get_pin_id(struct sc_profile *profile,
+		unsigned int reference, int *id)
+{
+	struct pin_info	*pi;
+
+	for (pi = profile->pin_list; pi; pi = pi->next) {
+		if (pi->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
+			continue;
+		if (pi->pin.attrs.pin.reference == (int)reference) {
+			*id = pi->id;
+			return 0;
+		}
+
+	}
+	return SC_ERROR_OBJECT_NOT_FOUND;
+}
+
+int
+sc_profile_get_file_in(sc_profile_t *profile,
+		const sc_path_t *path, const char *name, sc_file_t **ret)
+{
+	struct file_info *fi;
+
+	if ((fi = sc_profile_find_file(profile, path, name)) == NULL)
+		return SC_ERROR_FILE_NOT_FOUND;
+	sc_file_dup(ret, fi->file);
+	if (*ret == NULL)
+		return SC_ERROR_OUT_OF_MEMORY;
+	return 0;
+}
+
+int
+sc_profile_get_file(struct sc_profile *profile,
+		const char *name, sc_file_t **ret)
+{
+	struct file_info *fi;
+
+	if ((fi = sc_profile_find_file(profile, NULL, name)) == NULL)
+		return SC_ERROR_FILE_NOT_FOUND;
+	sc_file_dup(ret, fi->file);
+	if (*ret == NULL)
+		return SC_ERROR_OUT_OF_MEMORY;
+	return 0;
+}
+
+int
+sc_profile_get_file_instance(struct sc_profile *profile, const char *name,
+		int index, sc_file_t **ret)
+{
+	struct sc_context *ctx = profile->card->ctx;
+	struct file_info *fi;
+	struct sc_file *file;
+	int r;
+
+	LOG_FUNC_CALLED(ctx);
+	sc_log(ctx, "try to get '%s' file instance", name);
+
+	if ((fi = sc_profile_find_file(profile, NULL, name)) == NULL)
+		LOG_FUNC_RETURN(ctx, SC_ERROR_FILE_NOT_FOUND);
+	sc_file_dup(&file, fi->file);
+	sc_log(ctx, "ident '%s'; parent '%s'", fi->ident, fi->parent ? fi->parent->ident : "(null)");
+	if (file == NULL)
+		LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);
+	sc_log(ctx, "file (type:%X, path:'%s')", file->type, sc_print_path(&file->path));
+
+	file->id += index;
+        if(file->type == SC_FILE_TYPE_BSO) {
+		r = sc_profile_add_file(profile, name, file);
+		if (r < 0)
+			sc_file_free(file);
+		LOG_TEST_RET(ctx, r, "Profile error: cannot add BSO file");
+	}
+	else if (file->path.len)   {
+		file->path.value[file->path.len - 2] = (file->id >> 8) & 0xFF;
+		file->path.value[file->path.len - 1] = file->id & 0xFF;
+
+		r = sc_profile_add_file(profile, name, file);
+		if (r < 0)
+			sc_file_free(file);
+		LOG_TEST_RET(ctx, r, "Profile error: cannot add file");
+	}
+
+	if (ret)
+		*ret = file;
+	else
+		sc_file_free(file);
+
+	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
+}
+
+int
+sc_profile_get_path(struct sc_profile *profile,
+		const char *name, sc_path_t *ret)
+{
+	struct file_info *fi;
+
+	if ((fi = sc_profile_find_file(profile, NULL, name)) == NULL)
+		return SC_ERROR_FILE_NOT_FOUND;
+	*ret = fi->file->path;
+	return 0;
+}
+
+int
+sc_profile_get_file_by_path(struct sc_profile *profile,
+		const sc_path_t *path, sc_file_t **ret)
+{
+	struct sc_context *ctx = profile->card->ctx;
+	struct file_info *fi;
+
+	LOG_FUNC_CALLED(ctx);
+	if ((fi = sc_profile_find_file_by_path(profile, path)) == NULL)
+		LOG_FUNC_RETURN(ctx, SC_ERROR_FILE_NOT_FOUND);
+	sc_file_dup(ret, fi->file);
+	LOG_FUNC_RETURN(ctx, *ret ? SC_SUCCESS : SC_ERROR_OUT_OF_MEMORY);
+}
+
+int
+sc_profile_add_file(sc_profile_t *profile, const char *name, sc_file_t *file)
+{
+	struct sc_context *ctx = profile->card->ctx;
+	sc_path_t	path = file->path;
+	struct file_info	*parent;
+
+	LOG_FUNC_CALLED(ctx);
+	if (!path.len)   {
+		parent = profile->df_info;
+	} else {
+		path.len -= 2;
+		parent = sc_profile_find_file_by_path(profile, &path);
+	}
+	if (!parent)
+		LOG_FUNC_RETURN(ctx, SC_ERROR_FILE_NOT_FOUND);
+	sc_log(ctx, "Parent path:%s", sc_print_path(&parent->file->path));
+
+	sc_file_dup(&file, file);
+	if (file == NULL)
+		LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);
+
+	add_file(profile, name, file, parent);
+	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
+}
+
+/*
+ * Instantiate template
+ */
+int
+sc_profile_instantiate_template(sc_profile_t *profile,
+		const char *template_name, const sc_path_t *base_path,
+		const char *file_name, const sc_pkcs15_id_t *id,
+		sc_file_t **ret)
+{
+	struct sc_context *ctx = profile->card->ctx;
+	struct sc_profile	*tmpl;
+	struct sc_template	*info;
+	unsigned int	idx;
+	struct file_info *fi, *base_file, *match = NULL;
+
+#ifdef DEBUG_PROFILE
+	printf("Instantiate %s in template %s\n", file_name, template_name);
+	sc_profile_find_file_by_path(profile, base_path);
+#endif
+	for (info = profile->template_list; info; info = info->next)
+		if (!strcmp(info->name, template_name))
+			break;
+	if (info == NULL)   {
+		sc_log(ctx, "Template %s not found", template_name);
+		return SC_ERROR_TEMPLATE_NOT_FOUND;
+	}
+
+	tmpl = info->data;
+	idx = id->value[id->len-1];
+	for (fi = profile->ef_list; fi; fi = fi->next) {
+		if (fi->base_template == tmpl
+		 && fi->inst_index == idx
+		 && sc_compare_path(&fi->inst_path, base_path)
+		 && !strcmp(fi->ident, file_name)) {
+			sc_file_dup(ret, fi->file);
+			if (*ret == NULL)
+				return SC_ERROR_OUT_OF_MEMORY;
+			return 0;
+		}
+	}
+
+	sc_log(ctx, "Instantiating template %s at %s", template_name, sc_print_path(base_path));
+
+	base_file = sc_profile_find_file_by_path(profile, base_path);
+	if (base_file == NULL) {
+		sc_log(ctx, "Directory %s not defined in profile", sc_print_path(base_path));
+		return SC_ERROR_OBJECT_NOT_FOUND;
+	}
+
+	/* This loop relies on the fact that new files are always
+	 * appended to the list, after the parent files they refer to
+	 */
+	assert(base_file->instance);
+	for (fi = tmpl->ef_list; fi; fi = fi->next) {
+		struct file_info	*parent, *instance;
+		unsigned int	skew = 0;
+
+		fi->instance = NULL;
+		if ((parent = fi->parent) == NULL) {
+			parent = base_file;
+			skew = idx;
+		}
+		parent = parent->instance;
+
+		instance = sc_profile_instantiate_file(profile, fi, parent, skew);
+		if (instance == NULL)
+			return SC_ERROR_OUT_OF_MEMORY;
+		instance->base_template = tmpl;
+		instance->inst_index = idx;
+		instance->inst_path = *base_path;
+
+		if (!strcmp(instance->ident, file_name))
+			match = instance;
+	}
+
+	if (match == NULL) {
+		sc_log(ctx, "No file named \"%s\" in template \"%s\"",
+				file_name, template_name);
+		return SC_ERROR_OBJECT_NOT_FOUND;
+	}
+	sc_file_dup(ret, match->file);
+	if (*ret == NULL)
+		return SC_ERROR_OUT_OF_MEMORY;
+#ifdef DEBUG_PROFILE
+	printf("Template instantiated\n");
+#endif
+	return 0;
+}
+
+static struct file_info *
+sc_profile_instantiate_file(sc_profile_t *profile, struct file_info *ft,
+		struct file_info *parent, unsigned int skew)
+{
+	struct sc_context *ctx = profile->card->ctx;
+	struct file_info *fi;
+
+	fi = calloc(1, sizeof(*fi));
+	if (fi == NULL)
+		return NULL;
+	fi->instance = fi;
+	fi->parent = parent;
+	fi->ident = strdup(ft->ident);
+	if (fi->ident == NULL) {
+		free(fi);
+		return NULL;
+	}
+	sc_file_dup(&fi->file, ft->file);
+	if (fi->file == NULL) {
+		free(fi->ident);
+		free(fi);
+		return NULL;
+	}
+	fi->file->path = parent->file->path;
+	fi->file->id += skew;
+
+	if (fi->file->type == SC_FILE_TYPE_INTERNAL_EF
+			|| fi->file->type == SC_FILE_TYPE_WORKING_EF
+			|| (fi->file->type == SC_FILE_TYPE_DF && fi->file->id))
+		sc_append_file_id(&fi->file->path, fi->file->id);
+
+	append_file(profile, fi);
+
+	ft->instance = fi;
+
+	sc_log(ctx, "Instantiated %s at %s", ft->ident, sc_print_path(&fi->file->path));
+	sc_log(ctx, "  parent=%s@%s", parent->ident, sc_print_path(&parent->file->path));
+
+	return fi;
+}
+
+int
+sc_profile_get_pin_id_by_reference(struct sc_profile *profile,
+		unsigned auth_method, int reference,
+		struct sc_pkcs15_auth_info *auth_info)
+{
+	struct pin_info *pinfo;
+
+	for (pinfo = profile->pin_list; pinfo; pinfo = pinfo->next)  {
+		if (auth_method == SC_AC_SYMBOLIC)   {
+			if (pinfo->id != reference)
+				continue;
+		}
+		else   {
+			if (pinfo->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
+				continue;
+			if (pinfo->pin.auth_method != auth_method)
+				continue;
+			if (pinfo->pin.attrs.pin.reference != reference)
+				continue;
+		}
+
+		if (auth_info)
+			*auth_info = pinfo->pin;
+		return pinfo->id;
+	}
+
+	return -1;
+}
+
+/*
+ * Configuration file parser
+ */
+static void
+init_state(struct state *cur_state, struct state *new_state)
+{
+	memset(new_state, 0, sizeof(*new_state));
+	new_state->filename = cur_state->filename;
+	new_state->profile = cur_state->profile;
+	new_state->frame = cur_state;
+}
+
+static int
+do_card_driver(struct state *cur, int argc, char **argv)
+{
+	free(cur->profile->driver);
+	cur->profile->driver = strdup(argv[0]);
+	return 0;
+}
+
+static int
+do_maxpinlength(struct state *cur, int argc, char **argv)
+{
+	return get_uint(cur, argv[0], &cur->profile->pin_maxlen);
+}
+
+static int
+do_minpinlength(struct state *cur, int argc, char **argv)
+{
+	return get_uint(cur, argv[0], &cur->profile->pin_minlen);
+}
+
+static int
+do_default_pin_type(struct state *cur, int argc, char **argv)
+{
+	return map_str2int(cur, argv[0],
+		       	&cur->profile->pin_encoding, pinTypeNames);
+}
+
+static int
+do_pin_pad_char(struct state *cur, int argc, char **argv)
+{
+	return get_uint(cur, argv[0], &cur->profile->pin_pad_char);
+}
+
+static int
+do_pin_domains(struct state *cur, int argc, char **argv)
+{
+	return get_bool(cur, argv[0], &cur->profile->pin_domains);
+}
+
+static int
+do_card_label(struct state *cur, int argc, char **argv)
+{
+	struct sc_pkcs15_card	*p15card = cur->profile->p15_spec;
+
+	return setstr(&p15card->tokeninfo->label, argv[0]);
+}
+
+static int
+do_card_manufacturer(struct state *cur, int argc, char **argv)
+{
+	struct sc_pkcs15_card	*p15card = cur->profile->p15_spec;
+
+	return setstr(&p15card->tokeninfo->manufacturer_id, argv[0]);
+}
+
+/*
+ * Command related to the pkcs15 we generate
+ */
+static int
+do_direct_certificates(struct state *cur, int argc, char **argv)
+{
+	return get_bool(cur, argv[0], &cur->profile->pkcs15.direct_certificates);
+}
+
+static int
+do_encode_df_length(struct state *cur, int argc, char **argv)
+{
+	return get_bool(cur, argv[0], &cur->profile->pkcs15.encode_df_length);
+}
+
+static int
+do_encode_update_field(struct state *cur, int argc, char **argv)
+{
+	return get_bool(cur, argv[0], &cur->profile->pkcs15.do_last_update);
+}
+
+static int
+do_pkcs15_id_style(struct state *cur, int argc, char **argv)
+{
+	return map_str2int(cur, argv[0], &cur->profile->id_style, idStyleNames);
+}
+
+static int
+do_minidriver_support_style(struct state *cur, int argc, char **argv)
+{
+	return map_str2int(cur, argv[0], &cur->profile->md_style, mdStyleNames);
+}
+
+/*
+ * Process an option block
+ */
+static int
+process_option(struct state *cur, struct block *info,
+		const char *name, scconf_block *blk)
+{
+	sc_profile_t	*profile = cur->profile;
+	int		match = 0, i;
+
+	for (i = 0; profile->options[i]; i++)
+		match |= !strcmp(profile->options[i], name);
+	if (!match && strcmp("default", name))
+		return 0;
+	return process_block(cur, info, name, blk);
+}
+
+/*
+ * Process a key block
+ */
+static int
+process_key(struct state *cur, struct block *info,
+		const char *name, scconf_block *blk)
+{
+	unsigned int	type, id;
+	struct state	state;
+
+	if (get_authid(cur, name, &type, &id))
+		return 1;
+
+	init_state(cur, &state);
+	state.key = new_key(cur->profile, type, id);
+	return process_block(&state, info, name, blk);
+}
+
+static struct auth_info *
+new_key(struct sc_profile *profile, unsigned int type, unsigned int ref)
+{
+	struct auth_info *ai, **aip;
+
+	for (aip = &profile->auth_list; (ai = *aip); aip = &ai->next) {
+		if (ai->type == type && ai->ref == ref)
+			return ai;
+	}
+
+	ai = calloc(1, sizeof(*ai));
+	if (ai == NULL)
+		return NULL;
+	ai->type = type;
+	ai->ref = ref;
+	*aip = ai;
+	return ai;
+}
+
+static int
+do_key_value(struct state *cur, int argc, char **argv)
+{
+	struct auth_info *ai = cur->key;
+	const char	*key = argv[0];
+	size_t		key_len;
+	unsigned char	keybuf[32];
+
+	if (key[0] == '=') {
+		++key;
+		key_len = strlen(key);
+		memcpy(keybuf, key, key_len);
+	} else {
+		key_len = sizeof(keybuf);
+		if (sc_hex_to_bin(key, keybuf, &key_len)) {
+			parse_error(cur, "Error parsing PIN/key \"%s\"\n", key);
+			return 1;
+		}
+	}
+
+	memcpy(ai->key, keybuf, key_len);
+	ai->key_len = key_len;
+	return 0;
+}
+
+/*
+ * This function is called when the parser finds a block with an unknown
+ * name in the filesystem block. This will create a new filesystem
+ * object as the child of the current object.
+ */
+static int
+process_df(struct state *cur, struct block *info,
+		const char *name, scconf_block *blk)
+{
+	struct state	state;
+
+	init_state(cur, &state);
+	if (name == NULL) {
+		parse_error(cur, "No name given for DF object.");
+		return 1;
+	}
+	if (!(state.file = new_file(cur, name, SC_FILE_TYPE_DF)))
+		return 1;
+	return process_block(&state, info, name, blk);
+}
+
+static int
+process_ef(struct state *cur, struct block *info,
+		const char *name, scconf_block *blk)
+{
+	struct state	state;
+
+	init_state(cur, &state);
+	if (name == NULL) {
+		parse_error(cur, "No name given for EF object.");
+		return 1;
+	}
+	if (!(state.file = new_file(cur, name, SC_FILE_TYPE_WORKING_EF)))
+		return 1;
+	return process_block(&state, info, name, blk);
+}
+
+
+static int
+process_bso(struct state *cur, struct block *info,
+		const char *name, scconf_block *blk)
+{
+	struct state	state;
+
+	init_state(cur, &state);
+	if (name == NULL) {
+		parse_error(cur, "No name given for BSO object.");
+		return 1;
+	}
+	if (!(state.file = new_file(cur, name, SC_FILE_TYPE_BSO)))
+		return 1;
+	return process_block(&state, info, name, blk);
+}
+
+/*
+ * In the template the difference between any two file-ids
+ * should be greater then TEMPLATE_FILEID_MIN_DIFF.
+ */
+static int
+template_sanity_check(struct state *cur, struct sc_profile *templ)
+{
+	struct file_info *fi, *ffi;
+
+	for (fi = templ->ef_list; fi; fi = fi->next) {
+		struct sc_path fi_path =  fi->file->path;
+		int fi_id;
+
+		if (fi->file->type == SC_FILE_TYPE_BSO)
+			continue;
+
+		if (fi_path.len < 2) {
+			parse_error(cur, "Template insane: file-path length should not be less than 2 bytes");
+			return 1;
+		}
+
+		fi_id = fi_path.value[fi_path.len - 2] * 0x100
+				+ fi_path.value[fi_path.len - 1];
+
+		for (ffi = templ->ef_list; ffi; ffi = ffi->next) {
+			struct sc_path ffi_path =  ffi->file->path;
+			int dlt, ffi_id;
+
+			if (ffi->file->type == SC_FILE_TYPE_BSO)
+				continue;
+
+			if (ffi_path.len < 2) {
+				parse_error(cur, "Template insane: file-path length should not be less than 2 bytes");
+				return 1;
+			}
+
+			ffi_id = ffi_path.value[ffi_path.len - 2] * 0x100
+					+ ffi_path.value[ffi_path.len - 1];
+
+			dlt = fi_id > ffi_id ? fi_id - ffi_id : ffi_id - fi_id;
+			if (strcmp(ffi->ident, fi->ident))   {
+				if (dlt >= TEMPLATE_FILEID_MIN_DIFF)
+					continue;
+
+				parse_error(cur, "Template insane: file-ids should be substantially different");
+				return 1;
+			}
+		}
+	}
+
+	return SC_SUCCESS;
+}
+
+
+static int
+process_tmpl(struct state *cur, struct block *info,
+		const char *name, scconf_block *blk)
+{
+	struct state	state;
+	sc_template_t	*tinfo;
+	sc_profile_t	*templ;
+	int r;
+
+#ifdef DEBUG_PROFILE
+	printf("Process template:%s; block:%s\n", name, info->name);
+#endif
+	if (name == NULL) {
+		parse_error(cur, "No name given for template.");
+		return 1;
+	}
+
+	templ = calloc(1, sizeof(*templ));
+	if (templ == NULL) {
+		parse_error(cur, "memory allocation failed");
+		return 1;
+	}
+
+	tinfo = calloc(1, sizeof(*tinfo));
+	if (tinfo == NULL) {
+		parse_error(cur, "memory allocation failed");
+		free(templ);
+		return 1;
+	}
+	tinfo->name = strdup(name);
+	tinfo->data = templ;
+
+	tinfo->next = cur->profile->template_list;
+	cur->profile->template_list = tinfo;
+
+	init_state(cur, &state);
+	state.profile = tinfo->data;
+	state.file = NULL;
+
+	r = process_block(&state, info, name, blk);
+	if (!r)
+		r = template_sanity_check(cur, templ);
+
+#ifdef DEBUG_PROFILE
+	printf("Template %s processed; returns %i\n", name, r);
+#endif
+	return r;
+}
+
+/*
+ * Append new file at the end of the ef_list.
+ * This is crucial; the profile instantiation code relies on it
+ */
+static void append_file(sc_profile_t *profile, struct file_info *nfile)
+{
+	struct file_info	**list, *fi;
+
+	list = &profile->ef_list;
+	while ((fi = *list) != NULL)
+		list = &fi->next;
+	*list = nfile;
+}
+
+/*
+ * Add a new file to the profile.
+ * This function is called by sc_profile_add_file.
+ */
+static struct file_info *
+add_file(sc_profile_t *profile, const char *name,
+		sc_file_t *file, struct file_info *parent)
+{
+	struct file_info	*info;
+
+	info = calloc(1, sizeof(*info));
+	if (info == NULL)
+		return NULL;
+	info->instance = info;
+	info->ident = strdup(name);
+
+	info->parent = parent;
+	info->file = file;
+
+	append_file(profile, info);
+	return info;
+}
+
+/*
+ * Free file_info list
+ */
+static void
+free_file_list(struct file_info **list)
+{
+	struct file_info	*fi;
+
+	while ((fi = *list) != NULL) {
+		*list = fi->next;
+
+		if (fi->dont_free == 0)
+			sc_file_free(fi->file);
+		free(fi->profile_extension);
+		free(fi->ident);
+		free(fi);
+	}
+}
+
+/*
+ * Create a new file info object.
+ * This function is called by the profile parser.
+ */
+static struct file_info *
+new_file(struct state *cur, const char *name, unsigned int type)
+{
+	sc_profile_t	*profile = cur->profile;
+	struct file_info	*info;
+	sc_file_t	*file;
+	unsigned int	df_type = 0, dont_free = 0;
+	int	free_file = 0;
+
+	if ((info = sc_profile_find_file(profile, NULL, name)) != NULL)
+		return info;
+
+	/* Special cases for those EFs handled separately
+	 * by the PKCS15 logic */
+	if (strncasecmp(name, "PKCS15-", 7)) {
+		file = init_file(type);
+		free_file = 1;
+	} else if (!strcasecmp(name+7, "TokenInfo")) {
+		if (!profile->p15_spec) {
+			parse_error(cur, "no pkcs15 spec in profile");
+			return NULL;
+		}
+		file = profile->p15_spec->file_tokeninfo;
+		dont_free = 1;
+	} else if (!strcasecmp(name+7, "ODF")) {
+		if (!profile->p15_spec) {
+			parse_error(cur, "no pkcs15 spec in profile");
+			return NULL;
+		}
+		file = profile->p15_spec->file_odf;
+		dont_free = 1;
+	} else if (!strcasecmp(name+7, "UnusedSpace")) {
+		if (!profile->p15_spec) {
+			parse_error(cur, "no pkcs15 spec in profile");
+			return NULL;
+		}
+		file = profile->p15_spec->file_unusedspace;
+		dont_free = 1;
+	} else if (!strcasecmp(name+7, "AppDF")) {
+		file = init_file(SC_FILE_TYPE_DF);
+		free_file = 1;
+	} else {
+		if (map_str2int(cur, name+7, &df_type, pkcs15DfNames)
+				|| df_type >= SC_PKCS15_DF_TYPE_COUNT)
+			return NULL;
+
+		file = init_file(SC_FILE_TYPE_WORKING_EF);
+		profile->df[df_type] = file;
+		free_file = 1;
+	}
+	assert(file);
+	if (file->type != type) {
+		parse_error(cur, "inconsistent file type (should be %s)",
+			file->type == SC_FILE_TYPE_DF
+				? "DF" : file->type == SC_FILE_TYPE_BSO
+					? "BS0" : "EF");
+		if (free_file)
+			sc_file_free(file);
+		return NULL;
+	}
+
+	info = add_file(profile, name, file, cur->file);
+	if (info == NULL) {
+		parse_error(cur, "memory allocation failed");
+		return NULL;
+	}
+	info->dont_free = dont_free;
+	return info;
+}
+
+static int
+do_file_type(struct state *cur, int argc, char **argv)
+{
+	unsigned int	type;
+
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+
+	if (map_str2int(cur, argv[0], &type, fileTypeNames))
+		return 1;
+	cur->file->file->type = type;
+	return 0;
+}
+
+static int
+do_file_path(struct state *cur, int argc, char **argv)
+{
+	struct sc_file	*file = NULL;
+	struct sc_path	*path = NULL;
+
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+	file = cur->file->file;
+	path = &file->path;
+
+	/* sc_format_path doesn't return an error indication
+	 * when it's unable to parse the path */
+	sc_format_path(argv[0], path);
+	if (!path->len || (path->len & 1)) {
+		parse_error(cur, "Invalid path length\n");
+		return 1;
+	}
+	file->id = (path->value[path->len-2] << 8) | path->value[path->len-1];
+	return 0;
+}
+
+static int
+do_fileid(struct state *cur, int argc, char **argv)
+{
+	struct file_info *fi;
+	struct sc_file	*df, *file = NULL;
+	struct sc_path	temp, *path = NULL;
+
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+	file = cur->file->file;
+	path = &file->path;
+
+	/* sc_format_path doesn't return an error indication
+	 * when it's unable to parse the path */
+	sc_format_path(argv[0], &temp);
+	if (temp.len != 2) {
+		parse_error(cur, "Invalid file ID length\n");
+		return 1;
+	}
+
+	/* Get the DF, if any */
+	if ((fi = cur->file->parent) && (df = fi->file)) {
+		if (!df->path.len && !df->path.aid.len) {
+			parse_error(cur, "No path/fileid set for parent DF\n");
+			return 1;
+		}
+		if (df->path.len + 2 > sizeof(df->path.value)) {
+			parse_error(cur, "File path too long\n");
+			return 1;
+		}
+		*path = df->path;
+	}
+	if (path->len + 2 > sizeof(path->value)) {
+		parse_error(cur, "File path too long\n");
+		return 1;
+	}
+	memcpy(path->value + path->len, temp.value, 2);
+	path->len += 2;
+
+	file->id = (temp.value[0] << 8) | temp.value[1];
+	return 0;
+}
+
+static int
+do_structure(struct state *cur, int argc, char **argv)
+{
+	unsigned int	ef_structure;
+
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+
+	if (map_str2int(cur, argv[0], &ef_structure, fileStructureNames))
+		return 1;
+	cur->file->file->ef_structure = ef_structure;
+	return 0;
+}
+
+static int
+do_size(struct state *cur, int argc, char **argv)
+{
+	unsigned int	size;
+
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+
+	if (get_uint_eval(cur, argc, argv, &size))
+		return 1;
+	cur->file->file->size = size;
+	return 0;
+}
+
+static int
+do_reclength(struct state *cur, int argc, char **argv)
+{
+	unsigned int	reclength;
+
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+
+	if (get_uint(cur, argv[0], &reclength))
+		return 1;
+	cur->file->file->record_length = reclength;
+	return 0;
+}
+
+static int
+do_content(struct state *cur, int argc, char **argv)
+{
+	struct sc_file *file = NULL;
+	size_t len = (strlen(argv[0]) + 1) / 2;
+	int rv = 0;
+
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+	file = cur->file->file;
+
+	free(file->encoded_content);
+
+	file->encoded_content = malloc(len);
+	if (!file->encoded_content)
+		return 1;
+	rv = sc_hex_to_bin(argv[0], file->encoded_content, &len);
+	file->encoded_content_len = len;
+	return rv;
+}
+
+static int
+do_prop_attr(struct state *cur, int argc, char **argv)
+{
+	struct sc_file *file = NULL;
+	size_t len = (strlen(argv[0]) + 1) / 2;
+	int rv = 0;
+
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+	file = cur->file->file;
+
+	free(file->prop_attr);
+	file->prop_attr = malloc(len);
+	if (!file->prop_attr)
+		return 1;
+	rv = sc_hex_to_bin(argv[0], file->prop_attr, &len);
+	file->prop_attr_len = len;
+	return rv;
+}
+
+static int
+do_aid(struct state *cur, int argc, char **argv)
+{
+	struct sc_file	*file = NULL;
+	const char	*name = argv[0];
+	unsigned int	len;
+	int		res = 0;
+
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+	file = cur->file->file;
+
+	if (*name == '=') {
+		len = strlen(++name);
+		if (len > sizeof(file->name)) {
+			parse_error(cur, "AID \"%s\" too long\n", name);
+			return 1;
+		}
+		memcpy(file->name, name, len);
+		file->namelen = len;
+	}
+	else {
+		file->namelen = sizeof(file->name);
+		res = sc_hex_to_bin(name, file->name, &file->namelen);
+	}
+	return res;
+}
+
+static int
+do_exclusive_aid(struct state *cur, int argc, char **argv)
+{
+	struct sc_file	*file = NULL;
+	const char	*name = argv[0];
+	unsigned int	len;
+	int		res = 0;
+
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+	file = cur->file->file;
+
+#ifdef DEBUG_PROFILE
+	printf("do_exclusive_aid(): exclusive-aid '%s'\n", name);
+	printf("do_exclusive_aid(): current file '%s' (path:%s)\n", cur->file->ident, sc_print_path(&file->path));
+#endif
+	sc_format_path(name, &file->path);
+	if (file->path.len > SC_MAX_AID_SIZE)   {
+		parse_error(cur, "Path length is too big\n");
+		return 1;
+	}
+
+	memcpy(file->path.aid.value, file->path.value, file->path.len);
+	file->path.aid.len = file->path.len;
+
+	file->path.len = 0;
+	file->path.type = SC_PATH_TYPE_DF_NAME;
+
+#ifdef DEBUG_PROFILE
+	printf("do_exclusive_aid(): '%s' exclusive-aid path %s\n", cur->file->ident, sc_print_path(&file->path));
+#endif
+	if (*name == '=') {
+		len = strlen(++name);
+		if (len > sizeof(file->name)) {
+			parse_error(cur, "AID \"%s\" too long\n", name);
+			return 1;
+		}
+		memcpy(file->name, name, len);
+		file->namelen = len;
+	}
+	else {
+		file->namelen = sizeof(file->name);
+		res = sc_hex_to_bin(name, file->name, &file->namelen);
+	}
+	return res;
+}
+
+static int
+do_profile_extension(struct state *cur, int argc, char **argv)
+{
+	if (!cur->file) {
+		parse_error(cur, "Invalid state\n");
+		return 1;
+	}
+	return setstr(&cur->file->profile_extension, argv[0]);
+}
+
+/*
+ * Parse ACL list.
+ * The way we do this is we first split things like CHV1
+ * into a method (SC_AC_CHV) and a reference (1).
+ * When we're finished parsing the profile, the fake references
+ * are replaced by the real references given in KEY or PIN
+ * commands
+ */
+static int
+do_acl(struct state *cur, int argc, char **argv)
+{
+	struct sc_file	*file = NULL;
+	char		oper[64], *what = NULL;
+	memset(oper, 0, sizeof(oper));
+
+	if (!cur->file)
+		goto bad;
+	file = cur->file->file;
+
+	while (argc--) {
+		unsigned int	op, method, id;
+
+		if (strlen(*argv) >= sizeof(oper))
+			goto bad;
+		strlcpy(oper, *argv++, sizeof(oper));
+
+		if ((what = strchr(oper, '=')) == NULL)
+			goto bad;
+		*what++ = '\0';
+
+		if (*what == '$') {
+			method = SC_AC_SYMBOLIC;
+			if (map_str2int(cur, what+1, &id, pinIdNames))
+				return 1;
+		}
+		else if (get_authid(cur, what, &method, &id))
+			goto bad;
+
+
+		if (!strcmp(oper, "*")) {
+			for (op = 0; op < SC_MAX_AC_OPS; op++) {
+				sc_file_clear_acl_entries(file, op);
+				sc_file_add_acl_entry(file, op, method, id);
+			}
+		} else {
+			const sc_acl_entry_t *acl;
+
+			if (map_str2int(cur, oper, &op, fileOpNames))
+				goto bad;
+			if (!(acl = sc_file_get_acl_entry(file, op)))
+				goto bad;
+			if (acl->method == SC_AC_NEVER
+			 || acl->method == SC_AC_NONE
+			 || acl->method == SC_AC_UNKNOWN)
+				sc_file_clear_acl_entries(file, op);
+
+			sc_file_add_acl_entry(file, op, method, id);
+		}
+	}
+	return 0;
+
+bad:	parse_error(cur,
+		"Invalid ACL \"%s%s%s\"\n",
+		oper, what? "=" : "", what? what : "");
+	return 1;
+}
+
+static int
+process_pin(struct state *cur, struct block *info,
+		const char *name, scconf_block *blk)
+{
+	struct state	state;
+	unsigned int	id;
+
+	if (map_str2int(cur, name, &id, pinIdNames))
+		return 1;
+
+	init_state(cur, &state);
+	state.pin = new_pin(cur->profile, (int)id);
+
+	return process_block(&state, info, name, blk);
+}
+
+static struct pin_info *
+new_pin(struct sc_profile *profile, int id)
+{
+	struct pin_info	*pi, **tail;
+
+	for (tail = &profile->pin_list; (pi = *tail); tail = &pi->next) {
+		if (pi->id == id)
+			return pi;
+	}
+
+	/* Create pin info object. Most values are
+	 * set to their defaults in set_pin_defaults later
+	 * We can't do this here because these pin info objects
+	 * are usually created before we've read the card specific
+	 * profile
+	 */
+	pi = calloc(1, sizeof(*pi));
+	if (pi == NULL)
+		return NULL;
+	pi->id = id;
+	pi->pin.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
+	pi->pin.auth_method = SC_AC_CHV;
+	pi->pin.attrs.pin.type = (unsigned int)-1;
+	pi->pin.attrs.pin.flags = 0x32;
+	pi->pin.attrs.pin.max_length = 0;
+	pi->pin.attrs.pin.min_length = 0;
+	pi->pin.attrs.pin.stored_length = 0;
+	pi->pin.attrs.pin.pad_char = 0xA5;
+	pi->pin.attrs.pin.reference = -1;
+	pi->pin.tries_left = 3;
+
+	*tail = pi;
+	return pi;
+}
+
+static void set_pin_defaults(struct sc_profile *profile, struct pin_info *pi)
+{
+	struct sc_pkcs15_auth_info *info = &pi->pin;
+	struct sc_pkcs15_pin_attributes *pin_attrs = &info->attrs.pin;
+
+	info->auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
+
+	if (pin_attrs->type == (unsigned int) -1)
+		pin_attrs->type = profile->pin_encoding;
+	if (pin_attrs->max_length == 0)
+		pin_attrs->max_length = profile->pin_maxlen;
+	if (pin_attrs->min_length == 0)
+		pin_attrs->min_length = profile->pin_minlen;
+	if (pin_attrs->stored_length == 0) {
+		pin_attrs->stored_length = profile->pin_maxlen;
+		/* BCD encoded PIN takes half the space */
+		if (pin_attrs->type == SC_PKCS15_PIN_TYPE_BCD)
+			pin_attrs->stored_length = (pin_attrs->stored_length + 1) / 2;
+	}
+	if (pin_attrs->pad_char == 0xA5)
+		pin_attrs->pad_char = profile->pin_pad_char;
+}
+
+static int
+do_pin_file(struct state *cur, int argc, char **argv)
+{
+	free(cur->pin->file_name);
+	cur->pin->file_name = strdup(argv[0]);
+	return 0;
+}
+
+static int
+do_pin_offset(struct state *cur, int argc, char **argv)
+{
+	return get_uint(cur, argv[0], &cur->pin->file_offset);
+}
+
+static int
+do_pin_attempts(struct state *cur, int argc, char **argv)
+{
+	struct pin_info	*pi = cur->pin;
+	unsigned int	count;
+
+	if (get_uint(cur, argv[0], &count))
+		return 1;
+	pi->pin.tries_left = count;
+	return 0;
+}
+
+static int
+do_pin_maxunlocks(struct state *cur, int argc, char **argv)
+{
+	struct pin_info	*pi = cur->pin;
+	unsigned int	count;
+
+	if (get_uint(cur, argv[0], &count))
+		return 1;
+	pi->pin.max_unlocks = count;
+	return 0;
+}
+
+static int
+do_pin_type(struct state *cur, int argc, char **argv)
+{
+	unsigned int	type;
+
+	if (map_str2int(cur, argv[0], &type, pinTypeNames))
+		return 1;
+	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
+		return 1;
+	cur->pin->pin.attrs.pin.type = type;
+	return 0;
+}
+
+static int
+do_pin_reference(struct state *cur, int argc, char **argv)
+{
+	unsigned int	reference;
+
+	if (get_uint(cur, argv[0], &reference))
+		return 1;
+	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
+		return 1;
+	cur->pin->pin.attrs.pin.reference = reference;
+	return 0;
+}
+
+static int
+do_pin_authid(struct state *cur, int argc, char **argv)
+{
+	sc_pkcs15_format_id(argv[0], &cur->pin->pin.auth_id);
+	return 0;
+}
+
+static int
+do_pin_minlength(struct state *cur, int argc, char **argv)
+{
+	unsigned int	len;
+
+	if (get_uint(cur, argv[0], &len))
+		return 1;
+	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
+		return 1;
+	cur->pin->pin.attrs.pin.min_length = len;
+	return 0;
+}
+
+static int
+do_pin_maxlength(struct state *cur, int argc, char **argv)
+{
+	unsigned int	len;
+
+	if (get_uint(cur, argv[0], &len))
+		return 1;
+	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
+		return 1;
+	cur->pin->pin.attrs.pin.max_length = len;
+	return 0;
+}
+
+static int
+do_pin_storedlength(struct state *cur, int argc, char **argv)
+{
+	unsigned int	len;
+
+	if (get_uint(cur, argv[0], &len))
+		return 1;
+	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
+		return 1;
+	cur->pin->pin.attrs.pin.stored_length = len;
+	return 0;
+}
+
+static int
+do_pin_flags(struct state *cur, int argc, char **argv)
+{
+	unsigned int	flags;
+	int		i, r;
+
+	if (cur->pin->pin.auth_type != SC_PKCS15_PIN_AUTH_TYPE_PIN)
+		return -1;
+
+	cur->pin->pin.attrs.pin.flags = 0;
+	for (i = 0; i < argc; i++) {
+		if ((r = map_str2int(cur, argv[i], &flags, pinFlagNames)) < 0)
+			return r;
+		cur->pin->pin.attrs.pin.flags |= flags;
+	}
+
+	return 0;
+}
+
+static int
+process_macros(struct state *cur, struct block *info,
+		const char *dummy, scconf_block *blk)
+{
+	scconf_item	*item;
+	const char	*name;
+	int		 r;
+
+	for (item = blk->items; item; item = item->next) {
+		name = item->key;
+		if (item->type != SCCONF_ITEM_TYPE_VALUE || !name)
+			continue;
+#ifdef DEBUG_PROFILE
+		printf("Defining %s\n", name);
+#endif
+		r = new_macro(cur->profile, name, item->value.list);
+		if (r != SC_SUCCESS)
+			return r;
+	}
+
+	return SC_SUCCESS;
+}
+
+static int
+new_macro(sc_profile_t *profile, const char *name, scconf_list *value)
+{
+	sc_macro_t	*mac;
+
+	if (!profile || !name || !value)
+		return SC_ERROR_INVALID_ARGUMENTS;
+
+	if ((mac = find_macro(profile, name)) == NULL) {
+		mac = calloc(1, sizeof(*mac));
+		if (mac == NULL)
+			return SC_ERROR_OUT_OF_MEMORY;
+		mac->name = strdup(name);
+		mac->next = profile->macro_list;
+		profile->macro_list = mac;
+	}
+
+	mac->value = value;
+	return SC_SUCCESS;
+}
+
+static sc_macro_t *
+find_macro(sc_profile_t *profile, const char *name)
+{
+	sc_macro_t	*mac;
+
+	for (mac = profile->macro_list; mac; mac = mac->next) {
+		if (!strcmp(mac->name, name))
+			return mac;
+	}
+	return NULL;
+}
+
+/*
+ * Key section
+ */
+static struct command	key_commands[] = {
+ { "value",		1,	1,	do_key_value	},
+ { NULL, 0, 0, NULL }
+};
+
+/*
+ * Cardinfo section
+ */
+static struct command	ci_commands[] = {
+ { "driver",		1,	1,	do_card_driver	},
+ { "max-pin-length",	1,	1,	do_maxpinlength	},
+ { "min-pin-length",	1,	1,	do_minpinlength	},
+ { "pin-encoding",	1,	1,	do_default_pin_type },
+ { "pin-pad-char",	1,	1,	do_pin_pad_char },
+ { "pin-domains",	1,	1,	do_pin_domains	},
+ { "label",		1,	1,	do_card_label	},
+ { "manufacturer",	1,	1,	do_card_manufacturer},
+
+ { NULL, 0, 0, NULL }
+};
+
+static struct block	ci_blocks[] = {
+ { "key",		process_key,	key_commands,	NULL	},
+
+ { NULL, NULL, NULL, NULL }
+};
+
+/*
+ * Filesystem section
+ */
+static struct command	fs_commands[] = {
+ { "type",		1,	1,	do_file_type	},
+ { "path",		1,	1,	do_file_path	},
+ { "file-id",		1,	1,	do_fileid	},
+ { "structure",		1,	1,	do_structure	},
+ { "size",		1,	-1,	do_size		},
+ { "record-length",	1,	1,	do_reclength	},
+ { "AID",		1,	1,	do_aid		},
+ { "ACL",		1,	-1,	do_acl		},
+/* AID dependent sub-profile */
+ { "profile-extension",	1,	1,	do_profile_extension	},
+/* AID of the DFs without file-id */
+ { "exclusive-aid",	1,	1,	do_exclusive_aid	},
+ { "content",		1,	1,	do_content	},
+ { "prop-attr",		1,	1,	do_prop_attr	},
+
+ { NULL, 0, 0, NULL }
+};
+
+static struct block	fs_blocks[] = {
+ { "DF",		process_df,	fs_commands,	fs_blocks },
+ { "EF",		process_ef,	fs_commands,	fs_blocks },
+ { "BSO",		process_bso,	fs_commands,	fs_blocks },
+ { "template",		process_tmpl,	fs_commands,	fs_blocks },
+
+ { NULL, NULL, NULL, NULL }
+};
+
+/*
+ * Pin section
+ */
+static struct command	pi_commands[] = {
+ { "file",		1,	1,	do_pin_file		},
+ { "offset",		1,	1,	do_pin_offset		},
+ { "attempts",		1,	2,	do_pin_attempts		},
+ { "encoding",		1,	1,	do_pin_type		},
+ { "reference",		1,	1,	do_pin_reference	},
+ { "auth-id",		1,	1,	do_pin_authid		},
+ { "max-length",	1,	1,	do_pin_maxlength	},
+ { "min-length",	1,	1,	do_pin_minlength	},
+ { "stored-length",	1,	1,	do_pin_storedlength	},
+ { "max-unlocks",	1,	1,	do_pin_maxunlocks	},
+ { "flags",		1,	-1,	do_pin_flags		},
+ { NULL, 0, 0, NULL }
+};
+
+/*
+ * pkcs15 dialect section
+ */
+static struct command	p15_commands[] = {
+ { "direct-certificates",	1,	1,	do_direct_certificates },
+ { "encode-df-length",		1,	1,	do_encode_df_length },
+ { "do-last-update",		1,	1,	do_encode_update_field },
+ { "pkcs15-id-style",		1,	1,	do_pkcs15_id_style },
+ { "minidriver-support-style",	1,	1,	do_minidriver_support_style },
+ { NULL, 0, 0, NULL }
+};
+
+static struct block	root_blocks[] = {
+ { "filesystem",	process_block,	NULL,		fs_blocks },
+ { "cardinfo",		process_block,	ci_commands,	ci_blocks },
+ { "pin",		process_pin,	pi_commands,	NULL	},
+ { "option",		process_option,	NULL,		root_blocks },
+ { "macros",		process_macros,	NULL,		NULL	},
+ { "pkcs15",		process_block,	p15_commands,	NULL	},
+
+ { NULL, NULL, NULL, NULL }
+};
+
+static struct block	root_ops = {
+   "root",		process_block,	NULL,		root_blocks
+};
+
+static int
+is_macro_character(char c) {
+	if (isalnum(c) || c == '-' || c == '_')
+		return 1;
+	return 0;
+}
+
+static void
+get_inner_word(char *str, char word[WORD_SIZE]) {
+	char *inner = NULL;
+	size_t len = 0;
+
+	inner = str;
+	while (is_macro_character(*inner)) {
+		inner++;
+		len++;
+	}
+	len = len >= WORD_SIZE ? WORD_SIZE - 1 : len;
+	memcpy(word, str, len);
+	word[len] = '\0';
+}
+
+/*
+ * Checks for a reference loop for macro named start_name in macro definitions.
+ * Function returns 1 if a reference loop is detected, 0 otherwise.
+ */
+static int
+check_macro_reference_loop(const char *start_name, sc_macro_t *macro, sc_profile_t *profile, int depth) {
+	char *macro_value = NULL;
+	char *name = NULL;
+	char word[WORD_SIZE];
+
+	if (!start_name || !macro || !profile || depth == 16)
+		return 1;
+
+	/* Find name in macro value */
+	macro_value = macro->value->data;
+	if (!(name = strchr(macro_value, '$')))
+		return 0;
+	/* Extract the macro name from the string */
+	get_inner_word(name + 1, word);
+	/* Find whether name corresponds to some other macro */
+	if (!(macro = find_macro(profile, word)))
+		return 0;
+	/* Check for loop */
+	if (!strcmp(macro->name, start_name))
+		return 1;
+	return check_macro_reference_loop(start_name, macro, profile, depth + 1);
+}
+
+static int
+build_argv(struct state *cur, const char *cmdname,
+		scconf_list *list, char **argv, unsigned int max)
+{
+	unsigned int	argc;
+	const char	*str;
+	sc_macro_t	*macro;
+	int		r;
+
+	for (argc = 0; list; list = list->next) {
+		if (argc >= max) {
+			parse_error(cur, "%s: too many arguments", cmdname);
+			return SC_ERROR_INVALID_ARGUMENTS;
+		}
+
+		str = list->data;
+		if (str[0] != '$') {
+			/* When str contains macro inside, macro reference loop needs to be checked */
+			char *macro_name = NULL;
+			if ((macro_name = strchr(str, '$'))) {
+				/* Macro does not to start at the first position */
+				char word[WORD_SIZE];
+				get_inner_word(macro_name + 1, word);
+				if ((macro = find_macro(cur->profile, word))
+				    && check_macro_reference_loop(macro->name, macro, cur->profile, 0)) {
+					return SC_ERROR_SYNTAX_ERROR;
+				}
+			}
+
+			argv[argc++] = list->data;
+			continue;
+		}
+
+		/* Expand macro reference */
+		if (!(macro = find_macro(cur->profile, str + 1))) {
+			parse_error(cur, "%s: unknown macro \"%s\"",
+					cmdname, str);
+			return SC_ERROR_SYNTAX_ERROR;
+		}
+
+		if (list == macro->value) {
+			return SC_ERROR_SYNTAX_ERROR;
+		}
+		if (check_macro_reference_loop(macro->name, macro, cur->profile, 0)) {
+			return SC_ERROR_SYNTAX_ERROR;
+		}
+#ifdef DEBUG_PROFILE
+		{
+			scconf_list *list;
+
+			printf("Expanding macro %s:", mac->name);
+			for (list = mac->value; list; list = list->next)
+				printf(" %s", list->data);
+			printf("\n");
+		}
+#endif
+		r = build_argv(cur, cmdname, macro->value,
+				argv + argc, max - argc);
+		if (r < 0)
+			return r;
+
+		argc += r;
+	}
+
+	return argc;
+}
+
+static int
+process_command(struct state *cur, struct command *cmd_info, scconf_list *list)
+{
+	const char	*cmd = cmd_info->name;
+	char		*argv[32];
+	int		argc, max = 32;
+
+	if (cmd_info->max_args >= 0 && max > cmd_info->max_args)
+		max = cmd_info->max_args;
+
+	if ((argc = build_argv(cur, cmd, list, argv, max)) < 0)
+		return argc;
+
+	if (argc < cmd_info->min_args) {
+		parse_error(cur, "%s: not enough arguments\n", cmd);
+		return 1;
+	}
+	return cmd_info->func(cur, argc, argv);
+}
+
+static struct block *
+find_block_handler(struct block *bp, const char *name)
+{
+	if (bp == NULL)
+		return NULL;
+	for (; bp->name; bp++) {
+		if (!strcasecmp(bp->name, name))
+			return bp;
+	}
+	return NULL;
+}
+
+static struct command *
+find_cmd_handler(struct command *cp, const char *name)
+{
+	if (cp == NULL)
+		return NULL;
+	for (; cp->name; cp++) {
+		if (!strcasecmp(cp->name, name))
+			return cp;
+	}
+	return NULL;
+}
+
+static int
+process_block(struct state *cur, struct block *info,
+		const char *name, scconf_block *blk)
+{
+	scconf_item	*item;
+	struct command	*cp;
+	struct block	*bp;
+	const char	*cmd, *ident;
+	int		res = 0;
+
+	for (item = blk->items; res == 0 && item; item = item->next) {
+		cmd = item->key;
+		if (item->type == SCCONF_ITEM_TYPE_COMMENT)
+			continue;
+		if (!cmd) {
+			parse_error(cur, "Command can not be processed.");
+			return SC_ERROR_SYNTAX_ERROR;
+		}
+		if (item->type == SCCONF_ITEM_TYPE_BLOCK) {
+			scconf_list *nlist;
+
+			ident = NULL;
+			if ((nlist = item->value.block->name) != NULL) {
+				if (nlist->next) {
+					parse_error(cur, "Too many name components in block name.");
+					return SC_ERROR_SYNTAX_ERROR;
+				}
+				ident = nlist->data;
+			}
+#ifdef DEBUG_PROFILE
+			printf("Processing %s %s\n", cmd, ident? ident : "");
+#endif
+			if ((bp = find_block_handler(info->blk_info, cmd))) {
+				res = bp->handler(cur, bp, ident, item->value.block);
+				continue;
+			}
+		}
+		else if (item->type == SCCONF_ITEM_TYPE_VALUE) {
+#ifdef DEBUG_PROFILE
+			printf("Processing %s\n", cmd);
+#endif
+			if ((cp = find_cmd_handler(info->cmd_info, cmd))) {
+				res = process_command(cur, cp, item->value.list);
+				continue;
+			}
+		}
+		parse_error(cur, "Command \"%s\" not understood in this context.", cmd);
+		return SC_ERROR_SYNTAX_ERROR;
+	}
+
+	if (res > 0)
+		res = SC_ERROR_SYNTAX_ERROR;
+	return res;
+}
+
+static int
+process_conf(struct sc_profile *profile, scconf_context *conf)
+{
+	struct state	state;
+
+	memset(&state, 0, sizeof(state));
+	state.filename = conf->filename;
+	state.profile = profile;
+	return process_block(&state, &root_ops, "root", conf->root);
+}
+
+static struct file_info *
+sc_profile_find_file(struct sc_profile *pro,
+		const sc_path_t *path, const char *name)
+{
+	struct file_info	*fi;
+	unsigned int		len;
+	const u8			*value;
+
+	value = path ? path->value : (const u8*) "";
+	len = path ? path->len : 0;
+	for (fi = pro->ef_list; fi; fi = fi->next) {
+		sc_path_t *fpath = &fi->file->path;
+
+		if (!strcasecmp(fi->ident, name) && fpath->len >= len && !memcmp(fpath->value, value, len))
+			return fi;
+	}
+	return NULL;
+}
+
+
+static struct file_info *
+sc_profile_find_file_by_path(struct sc_profile *pro, const sc_path_t *path)
+{
+	struct file_info *fi, *out = NULL;
+	struct sc_path *fp_path, *fpp_path;
+
+#ifdef DEBUG_PROFILE
+	struct sc_context *ctx = pro->card->ctx;
+
+	sc_log(ctx, "profile's EF list:");
+	for (fi = pro->ef_list; fi; fi = fi->next)   {
+		sc_log(ctx, "'%s' (path:%s)",  fi->ident, sc_print_path(&fi->file->path));
+		sc_log(ctx, "fi parent %p", fi->parent);
+		if (fi->parent && fi->parent->file)
+			sc_log(ctx, "fi parent path %s", sc_print_path(&fi->parent->file->path));
+	}
+	sc_log(ctx, "find profile file by path:%s", sc_print_path(path));
+#endif
+
+	if (!path || (!path->len && !path->aid.len))
+		return NULL;
+
+	for (fi = pro->ef_list; fi; fi = fi->next) {
+		fp_path = &fi->file->path;
+		fpp_path = fi->parent ? &fi->parent->file->path : NULL;
+
+		if (fp_path->len != path->len)
+			continue;
+		if (fp_path->len && memcmp(fp_path->value, path->value, path->len))
+			continue;
+
+		if (path->aid.len && fp_path->aid.len)   {
+			if (memcmp(fp_path->aid.value, path->aid.value, path->aid.len))
+				continue;
+		}
+		else if (path->aid.len && !fp_path->aid.len && fpp_path)   {
+			if (fpp_path->type == SC_PATH_TYPE_DF_NAME && fpp_path->len)   {
+				if (fpp_path->len != path->aid.len)
+					continue;
+				if (memcmp(fpp_path->value, path->aid.value, path->aid.len))
+					continue;
+			}
+			else if (fpp_path->aid.len)   {
+				if (fpp_path->aid.len != path->aid.len)
+					continue;
+				if (memcmp(fpp_path->aid.value, path->aid.value, path->aid.len))
+					continue;
+			}
+		}
+
+		out = fi;
+	}
+
+#ifdef DEBUG_PROFILE
+	sc_log(ctx, "returns (%s)", out ? out->ident: "<null>");
+#endif
+	return out;
+}
+
+int
+sc_profile_get_parent(struct sc_profile *profile,
+		const char *name, sc_file_t **ret)
+{
+	struct file_info *fi = NULL;
+
+	if ((fi = sc_profile_find_file(profile, NULL, name)) == NULL)
+		return SC_ERROR_FILE_NOT_FOUND;
+
+	if (!fi->parent)
+		return SC_ERROR_FILE_NOT_FOUND;
+
+	sc_file_dup(ret, fi->parent->file);
+	if (*ret == NULL)
+		return SC_ERROR_OUT_OF_MEMORY;
+	return 0;
+}
+
+/*
+ * Split up KEY0 or CHV1 into SC_AC_XXX and a number
+ */
+static int
+get_authid(struct state *cur, const char *value,
+		unsigned int *type, unsigned int *num)
+{
+	char	temp[16];
+	size_t	n;
+
+	if (isdigit((unsigned char) *value)) {
+		*num = 0;
+		return get_uint(cur, value, type);
+	}
+
+	if (strlen(value) >= sizeof(temp))
+		return 1;
+
+	n = strcspn(value, "0123456789x");
+	strlcpy(temp, value, (sizeof(temp) > n) ? n + 1 : sizeof(temp));
+
+	if (map_str2int(cur, temp, type, aclNames))
+		return 1;
+	if (value[n])
+		return get_uint(cur, value + n, num);
+	*num = 0;
+	return 0;
+}
+
+static int
+get_uint(struct state *cur, const char *value, unsigned int *vp)
+{
+	char	*ep;
+
+	if (strstr(value, "0x") == value)
+		*vp = strtoul(value + 2, &ep, 16);
+	else if (strstr(value, "x") == value)
+		*vp = strtoul(value + 1, &ep, 16);
+	else
+		*vp = strtoul(value, &ep, 0);
+	if (*ep != '\0') {
+		parse_error(cur, "invalid integer argument \"%s\"\n", value);
+		return 1;
+	}
+	return 0;
+}
+
+static int
+get_bool(struct state *cur, const char *value, unsigned int *vp)
+{
+	if (!strcasecmp(value, "on")
+	 || !strcasecmp(value, "yes")
+	 || !strcasecmp(value, "true")) {
+		*vp = 1;
+	} else
+	if (!strcasecmp(value, "off")
+	 || !strcasecmp(value, "no")
+	 || !strcasecmp(value, "false")) {
+		*vp = 0;
+	} else {
+		parse_error(cur, "invalid boolean argument \"%s\"\n", value);
+		return 1;
+	}
+	return 0;
+}
+
+static int
+map_str2int(struct state *cur, const char *value,
+		unsigned int *vp, struct map *map)
+{
+	unsigned int	n;
+	const char	*what;
+
+	if (isdigit((unsigned char) *value))
+		return get_uint(cur, value, vp);
+	for (n = 0; map[n].name; n++) {
+		if (!strcasecmp(value, map[n].name)) {
+			*vp = map[n].val;
+			return 0;
+		}
+	}
+
+	/* Try to print a meaningful error message */
+	what = "argument";
+	for (n = 0; mapNames[n].name; n++) {
+		if (mapNames[n].addr == map) {
+			what = mapNames[n].name;
+			break;
+		}
+	}
+
+	parse_error(cur, "invalid %s \"%s\"\n", what, value);
+	return SC_ERROR_SYNTAX_ERROR;
+}
+
+static int
+setstr(char **strp, const char *value)
+{
+	if (*strp)
+		free(*strp);
+	*strp = strdup(value);
+	return 0;
+}
+
+/*
+ * Evaluate numeric expressions
+ */
+#include <setjmp.h>
+
+struct num_exp_ctx {
+	struct state *	state;
+	jmp_buf		error;
+
+	int		j;
+	char		word[WORD_SIZE];
+
+	char *		unget;
+	char *		str;
+	int		argc;
+	char **		argv;
+};
+
+static void	expr_eval(struct num_exp_ctx *, unsigned int *, unsigned int, int);
+
+static void
+expr_fail(struct num_exp_ctx *ctx)
+{
+	longjmp(ctx->error, 1);
+}
+
+static void
+expr_put(struct num_exp_ctx *ctx, int c)
+{
+	if (ctx->j >= (int)sizeof(ctx->word))
+		expr_fail(ctx);
+	ctx->word[ctx->j++] = (char)c;
+}
+
+static char *
+__expr_get(struct num_exp_ctx *ctx, int eof_okay)
+{
+	char	*s;
+
+	if ((s = ctx->unget) != NULL) {
+		ctx->unget = NULL;
+		return s;
+	}
+
+	ctx->j = 0;
+	s = ctx->str;
+	do {
+		if (s == NULL || *s == '\0') {
+			if (ctx->argc == 0) {
+				if (eof_okay)
+					return NULL;
+				expr_fail(ctx);
+			}
+			ctx->str = s = *(ctx->argv++);
+			ctx->argc--;
+		}
+
+		while (isspace((unsigned char)*s))
+			s++;
+	} while (*s == '\0');
+
+	if (isdigit((unsigned char)*s)) {
+		while (isdigit((unsigned char)*s))
+			expr_put(ctx, *s++);
+	}
+	else if (*s == '$') {
+		expr_put(ctx, *s++);
+		while (is_macro_character(*s))
+			expr_put(ctx, *s++);
+	}
+	else if (strchr("*/+-()|&", *s)) {
+		expr_put(ctx, *s++);
+	}
+	else {
+		expr_fail(ctx);
+	}
+	ctx->str = s;
+
+	expr_put(ctx, '\0');
+	return ctx->word;
+}
+
+static char *
+expr_get(struct num_exp_ctx *ctx)
+{
+	return __expr_get(ctx, 0);
+}
+
+static void
+expr_unget(struct num_exp_ctx *ctx, char *s)
+{
+	if (ctx->unget)
+		expr_fail(ctx);
+	ctx->unget = s;
+}
+
+static void
+expr_expect(struct num_exp_ctx *ctx, int c)
+{
+	char	*tok;
+
+	tok = expr_get(ctx);
+	if (tok[0] != (char)c || tok[1])
+		expr_fail(ctx);
+}
+
+#define MAX_BRACKETS 32
+static void
+expr_term(struct num_exp_ctx *ctx, unsigned int *vp, int opening_brackets)
+{
+	char	*tok;
+
+	tok = expr_get(ctx);
+	if (*tok == '(') {
+		if (opening_brackets + 1 > MAX_BRACKETS) {
+			parse_error(ctx->state, "Too many \"%s\" in expression", tok);
+			expr_fail(ctx);
+		}
+		expr_eval(ctx, vp, 1, opening_brackets + 1);
+		expr_expect(ctx, ')');
+	}
+	else if (isdigit((unsigned char)*tok)) {
+		char	*ep;
+
+		*vp = strtoul(tok, &ep, 0);
+		if (*ep)
+			expr_fail(ctx);
+	}
+	else if (*tok == '$') {
+		sc_macro_t	*mac;
+		char		*argv[32];
+		int		argc;
+
+		if (!(mac = find_macro(ctx->state->profile, tok + 1)))
+			expr_fail(ctx);
+		argc = build_argv(ctx->state, "<expr>", mac->value, argv, 32);
+		if (argc < 0 || get_uint_eval(ctx->state, argc, argv, vp) < 0)
+			expr_fail(ctx);
+	}
+	else {
+		parse_error(ctx->state, "Unexpected token \"%s\" in expression", tok);
+		expr_fail(ctx);
+	}
+}
+
+static void
+expr_eval(struct num_exp_ctx *ctx, unsigned int *vp, unsigned int pri, int opening_brackets)
+{
+	unsigned int	left, right, new_pri;
+	char		*tok, op;
+
+	expr_term(ctx, &left, opening_brackets);
+
+	while (1) {
+		tok = __expr_get(ctx, 1);
+		if (tok == NULL)
+			break;
+
+		op = tok[0];
+
+		new_pri = 0;
+		switch (op) {
+		case '*':
+		case '/':
+			new_pri++;
+			/* fall through */
+		case '+':
+		case '-':
+			new_pri++;
+			/* fall through */
+		case '&':
+			new_pri++;
+			/* fall through */
+		case '|':
+			new_pri++;
+			/* fall through */
+		case ')':
+			break;
+		default:
+			expr_fail(ctx);
+		}
+
+		if (new_pri < pri) {
+			expr_unget(ctx, tok);
+			break;
+		}
+		pri = new_pri;
+
+		expr_eval(ctx, &right, new_pri + 1, opening_brackets);
+		switch (op) {
+		case '*': left *= right; break;
+		case '/':
+			if (right == 0)
+				expr_fail(ctx);
+			left /= right; break;
+		case '+': left += right; break;
+		case '-': left -= right; break;
+		case '&': left &= right; break;
+		case '|': left |= right; break;
+		default: expr_fail(ctx);
+		}
+	}
+
+	*vp = left;
+}
+
+static int
+get_uint_eval(struct state *cur, int argc, char **argv, unsigned int *vp)
+{
+	struct num_exp_ctx	ctx;
+
+	memset(&ctx, 0, sizeof(ctx));
+	ctx.state = cur;
+	ctx.argc  = argc;
+	ctx.argv  = argv;
+
+	if (setjmp(ctx.error)) {
+		parse_error(cur, "invalid numeric expression\n");
+		return SC_ERROR_SYNTAX_ERROR;
+	}
+
+	expr_eval(&ctx, vp, 0, 0);
+	if (ctx.str[0] || ctx.argc)
+		expr_fail(&ctx);
+
+	return 0;
+}
+
+static void
+parse_error(struct state *cur, const char *fmt, ...)
+{
+	char	buffer[1024], *sp;
+	va_list	ap;
+
+	va_start(ap, fmt);
+	vsnprintf(buffer, sizeof(buffer), fmt, ap);
+	va_end(ap);
+
+	if ((sp = strchr(buffer, '\n')) != NULL)
+		*sp = '\0';
+
+	if (cur->profile->card && cur->profile->card->ctx)
+		sc_log(cur->profile->card->ctx, "%s: %s", cur->filename, buffer);
+	else
+		fprintf(stdout, "%s: %s\n", cur->filename, buffer);
+}
diff --git a/src/tools/pkcs11-tool.c b/src/tools/pkcs11-tool.c
index 69c374ff..d80ccac0 100644
--- a/src/tools/pkcs11-tool.c
+++ b/src/tools/pkcs11-tool.c
@@ -7671,7 +7671,7 @@ static int test_random(CK_SESSION_HANDLE session)
 
 	printf("C_SeedRandom() and C_GenerateRandom():\n");
 
-	rv = p11->C_SeedRandom(session, seed1, 100);
+	rv = p11->C_SeedRandom(session, seed1, 16);
 	if (rv == CKR_RANDOM_NO_RNG) {
 		printf("  RNG not available\n");
 		return 0;
@@ -7690,9 +7690,9 @@ static int test_random(CK_SESSION_HANDLE session)
 		errors++;
 	}
 
-	rv = p11->C_GenerateRandom(session, buf1, 100);
+	rv = p11->C_GenerateRandom(session, buf1, 16);
 	if (rv != CKR_OK) {
-		p11_perror("C_GenerateRandom(buf1,100)", rv);
+		p11_perror("C_GenerateRandom(buf1,16)", rv);
 		errors++;
 	}
 
@@ -7702,13 +7702,13 @@ static int test_random(CK_SESSION_HANDLE session)
 		errors++;
 	}
 
-	rv = p11->C_GenerateRandom(session, buf2, 100);
+	rv = p11->C_GenerateRandom(session, buf2, 16);
 	if (rv != CKR_OK) {
-		p11_perror("C_GenerateRandom(buf2,100)", rv);
+		p11_perror("C_GenerateRandom(buf2,16)", rv);
 		errors++;
 	}
 
-	if (errors == 0 && memcmp(buf1, buf2, 100) == 0) {
+	if (errors == 0 && memcmp(buf1, buf2, 10) == 0) {
 		printf("  ERR: C_GenerateRandom returned twice the same value!!!\n");
 		errors++;
 	}
